import{dq as ke,l as me,q as xe,ap as ye,u as Ee,aR as Se,a4 as ve,b as Ie,bd as Ne,e as Te,j as De,dr as We,ds as be,C as Ae,ar as ie,a3 as Me,I as Re,x as Ce,G as _e}from"./index-1OxaEeO3.js";import{an as Le}from"./n8n-4UEsHtUL.js";import{p as He}from"./flatted-DN8lQ2XG.js";import{d as Oe}from"./pinia-sugP77Im.js";import{u as Pe,a as Ue}from"./collaboration.store-Ol7bcCFc.js";import{r as A}from"./vendor-Dv5OeN6t.js";const Fe="/orchestration/worker/status",Ge=async r=>{await ke(r,"POST",Fe)},$e=100,Be=120*1e3,qe=Oe("orchestrationManager",{state:()=>({initialStatusReceived:!1,workers:{},workersHistory:{},workersLastUpdated:{},statusInterval:null}),actions:{updateWorkerStatus(r){this.workers[r.workerId]=r,this.workersHistory[r.workerId]||(this.workersHistory[r.workerId]=[]),this.workersHistory[r.workerId].push({data:r,timestamp:Date.now()}),this.workersHistory[r.workerId].length>$e&&this.workersHistory[r.workerId].shift(),this.workersLastUpdated[r.workerId]=Date.now(),this.initialStatusReceived=!0},removeStaleWorkers(){for(const r in this.workersLastUpdated)this.workersLastUpdated[r]+Be<Date.now()&&(delete this.workers[r],delete this.workersHistory[r],delete this.workersLastUpdated[r])},startWorkerStatusPolling(){const r=me();this.statusInterval||(this.statusInterval=setInterval(async()=>{await Ge(r.restApiContext),this.removeStaleWorkers()},1e3))},stopWorkerStatusPolling(){this.statusInterval&&(clearInterval(this.statusInterval),this.statusInterval=null)},getWorkerLastUpdated(r){return this.workersLastUpdated[r]??0},getWorkerStatus(r){return this.workers[r]},getWorkerStatusHistory(r){return this.workersHistory[r]??[]}}});function Qe({router:r}){const S=xe({router:r}),ue=ye(),D=Re(),w=Ee(),l=Ce(),le=_e(),M=Pe(),R=Se(),E=ve(),de=qe(),ce=Ue(),fe=Ie(),we=Ne(),x=Te(),a=De(),h=A(null),m=A([]),v=A(null);function pe(){v.value=ce.addEventListener(e=>{W(e)}),M.initialize()}function ge(){M.terminate(),typeof v.value=="function"&&v.value()}function I(e,n){m.value.push({message:e,retriesLeft:n}),h.value===null&&(h.value=setTimeout(N,20))}async function N(){h.value!==null&&(clearTimeout(h.value),h.value=null);const e=m.value.length;for(let n=0;n<e;n++){const c=m.value.shift();if(!await W(c.message,!0)){c.retriesLeft-=1,c.retriesLeft>0&&m.value.unshift(c);break}}m.value.length!==0&&h.value===null&&(h.value=setTimeout(N,25))}async function W(e,n){var T,C,_,L,H,O,P,U,F,G,$,B,q,j,K,V,z,Y,J,Q,X,Z,ee,te,oe,se,ae,re;if(e.type==="sendWorkerStatusMessage"){const s=e.data;return de.updateWorkerStatus(s.status),!0}if(e.type==="sendConsoleMessage"){const s=e.data;return console.log(s.source,...s.messages),!0}if(!["testWebhookReceived"].includes(e.type)&&n!==!0&&m.value.length)return I(e,5),!1;if(e.type==="nodeExecuteAfter"||e.type==="nodeExecuteBefore"){if(!x.isActionActive("workflowRunning"))return!1;const s=e.data;if(a.activeExecutionId!==s.executionId)return n!==!0&&I(event,5),!1}let k;if(e.type==="executionRecovered"){const s=(T=e.data)==null?void 0:T.executionId;if(x.isActionActive("workflowRunning")&&a.activeExecutionId===s){const t=await a.fetchExecutionDataById(a.activeExecutionId);if(t!=null&&t.data){t.data=He(t.data);const g={startData:(C=t.data)==null?void 0:C.startData,resultData:((_=t.data)==null?void 0:_.resultData)??{runData:{}},executionData:(L=t.data)==null?void 0:L.executionData};if(((H=a.workflowExecutionData)==null?void 0:H.workflowId)===t.workflowId){const f=(U=(P=(O=a.workflowExecutionData)==null?void 0:O.data)==null?void 0:P.resultData)==null?void 0:U.runData;if(f)for(const y of Object.keys(f))g.resultData.runData[y]=f[y]}const b={data:g,finished:t.finished,mode:t.mode,waitTill:(F=t.data)==null?void 0:F.waitTill,startedAt:t.startedAt,stoppedAt:t.stoppedAt,status:"crashed"};t.data&&(k={executionId:t.id,data:b})}}}if(e.type==="workflowFailedToActivate"&&a.workflowId===e.data.workflowId)return a.setWorkflowInactive(e.data.workflowId),a.setActive(!1),w.showError(new Error(e.data.errorMessage),l.baseText("workflowActivator.showError.title",{interpolate:{newStateName:"activated"}})+":"),!0;if(e.type==="workflowActivated")return a.setWorkflowActive(e.data.workflowId),!0;if(e.type==="workflowDeactivated")return a.setWorkflowInactive(e.data.workflowId),!0;if(e.type==="executionFinished"||e.type==="executionRecovered"){let s;e.type==="executionRecovered"&&k!==void 0?s=k:s=e.data;const{activeExecutionId:p}=a;if(p===s.executionId){const o=(B=($=(G=a.workflowExecutionData)==null?void 0:G.data)==null?void 0:$.resultData)==null?void 0:B.runData;if(o)for(const i of Object.keys(o))((J=(Y=(z=(V=(K=(j=(q=s.data.data.resultData.runData[i])==null?void 0:q[0])==null?void 0:j.data)==null?void 0:K.main)==null?void 0:V[0])==null?void 0:z[0])==null?void 0:Y.json)==null?void 0:J.isArtificialRecoveredEventItem)===!0&&o[i].length>0&&(s.data.data.resultData.runData[i]=o[i]);a.finishActiveExecution(s)}if(!x.isActionActive("workflowRunning"))return!1;if(p!==s.executionId)return n!==!0&&I(event,5),!1;const t=s.data;let g=he(t.data);t.status==="crashed"?g=l.baseText("pushConnection.executionFailed.message"):t.status==="canceled"&&(g=l.baseText("executionsList.showMessage.stopExecution.message",{interpolate:{activeExecutionId:p}}));const b=(Z=(X=(Q=t==null?void 0:t.data)==null?void 0:Q.resultData)==null?void 0:X.error)==null?void 0:Z.lineNumber;We.emit("error-line-number",b||"final");const f=S.getCurrentWorkflow();if(t.waitTill!==void 0){const o=a.workflowSettings,i=fe.saveManualExecutions,u=o.saveManualExecutions===void 0?i:o.saveManualExecutions;let d;u?d=`<a href="/workflow/${f.id}/executions/${p}">View the execution</a> to see what happened after this node.`:(be.emit("registerGlobalLinkAction",{key:"open-settings",action:async()=>{a.isNewWorkflow&&await S.saveAsNewWorkflow(),x.openModal(Ae)}}),d='<a data-action="open-settings">Turn on saving manual executions</a> and run again to see what happened after this node.'),D.titleSet(f.name,"IDLE"),w.showToast({title:"Workflow started waiting",message:`${d} <a href="https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.wait/" target="_blank">More info</a>`,type:"success",duration:0})}else if(t.finished!==!0){if(D.titleSet(f.name,"ERROR"),((ee=t.data.resultData.error)==null?void 0:ee.name)==="ExpressionError"&&t.data.resultData.error.context.functionality==="pairedItem"){const o=t.data.resultData.error;S.getWorkflowDataToSave().then(i=>{const u={caused_by_credential:!1,error_message:o.description,error_title:o.message,error_type:o.context.type,node_graph_string:JSON.stringify(Le(i,S.getNodeTypes()).nodeGraph),workflow_id:a.workflowId};if(o.context.nodeCause&&["paired_item_no_info","paired_item_invalid_info"].includes(o.context.type)){const d=f.getNode(o.context.nodeCause);d&&(u.is_pinned=!!f.getPinDataOfNode(d.name),u.mode=d.parameters.mode,u.node_type=d.type,u.operation=d.parameters.operation,u.resource=d.parameters.resource)}le.track("Instance FE emitted paired item error",u,{withPostHog:!0})})}if(((te=t.data.resultData.error)==null?void 0:te.name)==="SubworkflowOperationError"){const o=t.data.resultData.error;a.subWorkflowExecutionError=o,w.showMessage({title:o.message,message:o.description,type:"error",duration:0})}else if(((oe=t.data.resultData.error)==null?void 0:oe.name)==="NodeOperationError"&&t.data.resultData.error.functionality==="configuration-node"){let o;const i=t.data.resultData.error;i.node.name?o=`Error in sub-node ‘${i.node.name}‘`:o="Problem executing workflow",w.showMessage({title:o,message:((i==null?void 0:i.description)??g)+l.baseText("pushConnection.executionError.openNode",{interpolate:{node:i.node.name}}),type:"error",duration:0,dangerouslyUseHTMLString:!0})}else{let o;t.mode==="manual"&&t.status==="canceled"?w.showMessage({title:l.baseText("nodeView.showMessage.stopExecutionTry.title"),type:"success"}):(t.data.resultData.lastNodeExecuted?o=`Problem in node ‘${t.data.resultData.lastNodeExecuted}‘`:o="Problem executing workflow",w.showMessage({title:o,message:g,type:"error",duration:0,dangerouslyUseHTMLString:!0}))}}else{D.titleSet(f.name,"IDLE");const o=a.getWorkflowExecution;if(o!=null&&o.executedNode){const i=a.getNodeByName(o.executedNode),u=i&&E.getNodeType(i.type,i.typeVersion),d=o&&o.executedNode&&((re=(ae=(se=o.data)==null?void 0:se.resultData)==null?void 0:ae.runData)==null?void 0:re[o.executedNode]);u!=null&&u.polling&&!d?w.showMessage({title:l.baseText("pushConnection.pollingNode.dataNotFound",{interpolate:{service:ie(u)}}),message:l.baseText("pushConnection.pollingNode.dataNotFound.message",{interpolate:{service:ie(u)}}),type:"success"}):w.showMessage({title:l.baseText("pushConnection.nodeExecutedSuccessfully"),type:"success"})}else w.showMessage({title:l.baseText("pushConnection.workflowExecutedSuccessfully"),type:"success"})}a.getWorkflowRunData&&(t.data.resultData.runData=a.getWorkflowRunData),a.executingNode.length=0,a.setWorkflowExecutionData(t),x.removeActiveAction("workflowRunning"),ue.updateNodesExecutionIssues();const y=t.data.resultData.lastNodeExecuted;let ne=0;y&&t.data.resultData.runData[y]&&!g&&(ne=t.data.resultData.runData[y][0].data.main[0].length),Me().run("pushConnection.executionFinished",{itemsCount:ne,nodeName:t.data.resultData.lastNodeExecuted,errorMessage:g,runDataExecutedStartData:t.data.startData,resultDataError:t.data.resultData.error}),t.data.resultData.error||we.trackSuccessfulWorkflowExecution(t)}else if(e.type==="executionStarted"){const s=e.data,p={id:s.executionId,finished:!1,status:"running",mode:s.mode,startedAt:s.startedAt,retryOf:s.retryOf,workflowId:s.workflowId,workflowName:s.workflowName};a.addActiveExecution(p)}else if(e.type==="nodeExecuteAfter"){const s=e.data;a.addNodeExecutionData(s),a.removeExecutingNode(s.nodeName)}else if(e.type==="nodeExecuteBefore"){const s=e.data;a.addExecutingNode(s.nodeName)}else if(e.type==="testWebhookDeleted")e.data.workflowId===a.workflowId&&(a.executionWaitingForWebhook=!1,x.removeActiveAction("workflowRunning"));else if(e.type==="testWebhookReceived"){const s=e.data;s.workflowId===a.workflowId&&(a.executionWaitingForWebhook=!1,a.activeExecutionId=s.executionId),N()}else if(e.type==="reloadNodeType")await E.getNodeTypes(),await E.getFullNodesProperties([e.data]);else if(e.type==="removeNodeType"){const p=[e.data];await R.fetchCredentialTypes(!1).then(()=>{E.removeNodeTypes(p)})}else e.type==="nodeDescriptionUpdated"&&(await E.getNodeTypes(),await R.fetchCredentialTypes(!0));return!0}function he(e){const n=e.resultData.error;let c;if(e.resultData.lastNodeExecuted&&n)c=n.message||n.description;else if(c=l.baseText("pushConnection.executionError",{interpolate:{error:"!"}}),n!=null&&n.message){let k;"node"in n&&(k=typeof n.node=="string"?n.node:n.node.name);const T=k?`${k}: ${n.message}`:n.message;c=l.baseText("pushConnection.executionError",{interpolate:{error:`.${l.baseText("pushConnection.executionError.details",{interpolate:{details:T}})}`}})}return c}return{initialize:pe,terminate:ge,pushMessageReceived:W,queuePushMessage:I,processWaitingPushMessages:N,pushMessageQueue:m,removeEventListener:v,retryTimeout:h}}export{$e as W,qe as a,Qe as u};
//# sourceMappingURL=usePushConnection-PQgFeT_8.js.map
