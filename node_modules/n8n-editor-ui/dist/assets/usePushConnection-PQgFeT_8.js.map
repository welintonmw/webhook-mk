{"version":3,"file":"usePushConnection-PQgFeT_8.js","sources":["../../src/api/orchestration.ts","../../src/stores/orchestration.store.ts","../../src/composables/usePushConnection.ts"],"sourcesContent":["import type { IRestApiContext } from '@/Interface';\nimport { makeRestApiRequest } from '@/utils/apiUtils';\n\nconst GET_STATUS_ENDPOINT = '/orchestration/worker/status';\n\nexport const sendGetWorkerStatus = async (context: IRestApiContext): Promise<void> => {\n\tawait makeRestApiRequest(context, 'POST', GET_STATUS_ENDPOINT);\n};\n","import { defineStore } from 'pinia';\nimport type { IPushDataWorkerStatusPayload } from '../Interface';\nimport { useRootStore } from './root.store';\nimport { sendGetWorkerStatus } from '../api/orchestration';\n\nexport const WORKER_HISTORY_LENGTH = 100;\nconst STALE_SECONDS = 120 * 1000;\n\nexport interface IOrchestrationStoreState {\n\tinitialStatusReceived: boolean;\n\tworkers: { [id: string]: IPushDataWorkerStatusPayload };\n\tworkersHistory: {\n\t\t[id: string]: IWorkerHistoryItem[];\n\t};\n\tworkersLastUpdated: { [id: string]: number };\n\tstatusInterval: NodeJS.Timer | null;\n}\n\nexport interface IWorkerHistoryItem {\n\ttimestamp: number;\n\tdata: IPushDataWorkerStatusPayload;\n}\n\nexport const useOrchestrationStore = defineStore('orchestrationManager', {\n\tstate: (): IOrchestrationStoreState => ({\n\t\tinitialStatusReceived: false,\n\t\tworkers: {},\n\t\tworkersHistory: {},\n\t\tworkersLastUpdated: {},\n\t\tstatusInterval: null,\n\t}),\n\tactions: {\n\t\tupdateWorkerStatus(data: IPushDataWorkerStatusPayload) {\n\t\t\tthis.workers[data.workerId] = data;\n\t\t\tif (!this.workersHistory[data.workerId]) {\n\t\t\t\tthis.workersHistory[data.workerId] = [];\n\t\t\t}\n\t\t\tthis.workersHistory[data.workerId].push({ data, timestamp: Date.now() });\n\t\t\tif (this.workersHistory[data.workerId].length > WORKER_HISTORY_LENGTH) {\n\t\t\t\tthis.workersHistory[data.workerId].shift();\n\t\t\t}\n\t\t\tthis.workersLastUpdated[data.workerId] = Date.now();\n\n\t\t\tthis.initialStatusReceived = true;\n\t\t},\n\t\tremoveStaleWorkers() {\n\t\t\tfor (const id in this.workersLastUpdated) {\n\t\t\t\tif (this.workersLastUpdated[id] + STALE_SECONDS < Date.now()) {\n\t\t\t\t\tdelete this.workers[id];\n\t\t\t\t\tdelete this.workersHistory[id];\n\t\t\t\t\tdelete this.workersLastUpdated[id];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstartWorkerStatusPolling() {\n\t\t\tconst rootStore = useRootStore();\n\t\t\tif (!this.statusInterval) {\n\t\t\t\tthis.statusInterval = setInterval(async () => {\n\t\t\t\t\tawait sendGetWorkerStatus(rootStore.restApiContext);\n\t\t\t\t\tthis.removeStaleWorkers();\n\t\t\t\t}, 1000);\n\t\t\t}\n\t\t},\n\t\tstopWorkerStatusPolling() {\n\t\t\tif (this.statusInterval) {\n\t\t\t\tclearInterval(this.statusInterval);\n\t\t\t\tthis.statusInterval = null;\n\t\t\t}\n\t\t},\n\t\tgetWorkerLastUpdated(workerId: string): number {\n\t\t\treturn this.workersLastUpdated[workerId] ?? 0;\n\t\t},\n\t\tgetWorkerStatus(workerId: string): IPushDataWorkerStatusPayload | undefined {\n\t\t\treturn this.workers[workerId];\n\t\t},\n\t\tgetWorkerStatusHistory(workerId: string): IWorkerHistoryItem[] {\n\t\t\treturn this.workersHistory[workerId] ?? [];\n\t\t},\n\t},\n});\n","import type {\n\tIExecutionResponse,\n\tIExecutionsCurrentSummaryExtended,\n\tIPushData,\n\tIPushDataExecutionFinished,\n} from '@/Interface';\n\nimport { useNodeHelpers } from '@/composables/useNodeHelpers';\nimport { useTitleChange } from '@/composables/useTitleChange';\nimport { useToast } from '@/composables/useToast';\n\nimport type {\n\tExpressionError,\n\tIDataObject,\n\tINodeTypeNameVersion,\n\tIRun,\n\tIRunExecutionData,\n\tIWorkflowBase,\n\tSubworkflowOperationError,\n\tIExecuteContextData,\n\tNodeOperationError,\n\tINodeTypeDescription,\n} from 'n8n-workflow';\nimport { TelemetryHelpers } from 'n8n-workflow';\n\nimport { WORKFLOW_SETTINGS_MODAL_KEY } from '@/constants';\nimport { getTriggerNodeServiceName } from '@/utils/nodeTypesUtils';\nimport { codeNodeEditorEventBus, globalLinkActionsEventBus } from '@/event-bus';\nimport { useUIStore } from '@/stores/ui.store';\nimport { useWorkflowsStore } from '@/stores/workflows.store';\nimport { useNodeTypesStore } from '@/stores/nodeTypes.store';\nimport { useCredentialsStore } from '@/stores/credentials.store';\nimport { useSettingsStore } from '@/stores/settings.store';\nimport { parse } from 'flatted';\nimport { useSegment } from '@/stores/segment.store';\nimport { ref } from 'vue';\nimport { useOrchestrationStore } from '@/stores/orchestration.store';\nimport { usePushConnectionStore } from '@/stores/pushConnection.store';\nimport { useCollaborationStore } from '@/stores/collaboration.store';\nimport { useExternalHooks } from '@/composables/useExternalHooks';\nimport type { useRouter } from 'vue-router';\nimport { useWorkflowHelpers } from '@/composables/useWorkflowHelpers';\nimport { useI18n } from '@/composables/useI18n';\nimport { useTelemetry } from '@/composables/useTelemetry';\nimport type { PushMessageQueueItem } from '@/types';\n\nexport function usePushConnection({ router }: { router: ReturnType<typeof useRouter> }) {\n\tconst workflowHelpers = useWorkflowHelpers({ router });\n\tconst nodeHelpers = useNodeHelpers();\n\tconst titleChange = useTitleChange();\n\tconst toast = useToast();\n\tconst i18n = useI18n();\n\tconst telemetry = useTelemetry();\n\n\tconst collaborationStore = useCollaborationStore();\n\tconst credentialsStore = useCredentialsStore();\n\tconst nodeTypesStore = useNodeTypesStore();\n\tconst orchestrationManagerStore = useOrchestrationStore();\n\tconst pushStore = usePushConnectionStore();\n\tconst settingsStore = useSettingsStore();\n\tconst segmentStore = useSegment();\n\tconst uiStore = useUIStore();\n\tconst workflowsStore = useWorkflowsStore();\n\n\tconst retryTimeout = ref<NodeJS.Timeout | null>(null);\n\tconst pushMessageQueue = ref<PushMessageQueueItem[]>([]);\n\tconst removeEventListener = ref<(() => void) | null>(null);\n\n\tfunction initialize() {\n\t\tremoveEventListener.value = pushStore.addEventListener((message) => {\n\t\t\tvoid pushMessageReceived(message);\n\t\t});\n\t\tcollaborationStore.initialize();\n\t}\n\n\tfunction terminate() {\n\t\tcollaborationStore.terminate();\n\t\tif (typeof removeEventListener.value === 'function') {\n\t\t\tremoveEventListener.value();\n\t\t}\n\t}\n\n\t/**\n\t * Sometimes the push message is faster as the result from\n\t * the REST API so we do not know yet what execution ID\n\t * is currently active. So internally resend the message\n\t * a few more times\n\t */\n\tfunction queuePushMessage(event: IPushData, retryAttempts: number) {\n\t\tpushMessageQueue.value.push({ message: event, retriesLeft: retryAttempts });\n\n\t\tif (retryTimeout.value === null) {\n\t\t\tretryTimeout.value = setTimeout(processWaitingPushMessages, 20);\n\t\t}\n\t}\n\n\t/**\n\t * Process the push messages which are waiting in the queue\n\t */\n\tasync function processWaitingPushMessages() {\n\t\tif (retryTimeout.value !== null) {\n\t\t\tclearTimeout(retryTimeout.value);\n\t\t\tretryTimeout.value = null;\n\t\t}\n\n\t\tconst queueLength = pushMessageQueue.value.length;\n\t\tfor (let i = 0; i < queueLength; i++) {\n\t\t\tconst messageData = pushMessageQueue.value.shift() as PushMessageQueueItem;\n\n\t\t\tconst result = await pushMessageReceived(messageData.message, true);\n\t\t\tif (!result) {\n\t\t\t\t// Was not successful\n\t\t\t\tmessageData.retriesLeft -= 1;\n\n\t\t\t\tif (messageData.retriesLeft > 0) {\n\t\t\t\t\t// If still retries are left add it back and stop execution\n\t\t\t\t\tpushMessageQueue.value.unshift(messageData);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (pushMessageQueue.value.length !== 0 && retryTimeout.value === null) {\n\t\t\tretryTimeout.value = setTimeout(processWaitingPushMessages, 25);\n\t\t}\n\t}\n\n\t/**\n\t * Process a newly received message\n\t */\n\tasync function pushMessageReceived(receivedData: IPushData, isRetry?: boolean): Promise<boolean> {\n\t\tconst retryAttempts = 5;\n\n\t\tif (receivedData.type === 'sendWorkerStatusMessage') {\n\t\t\tconst pushData = receivedData.data;\n\t\t\torchestrationManagerStore.updateWorkerStatus(pushData.status);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (receivedData.type === 'sendConsoleMessage') {\n\t\t\tconst pushData = receivedData.data;\n\t\t\tconsole.log(pushData.source, ...pushData.messages);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (\n\t\t\t!['testWebhookReceived'].includes(receivedData.type) &&\n\t\t\tisRetry !== true &&\n\t\t\tpushMessageQueue.value.length\n\t\t) {\n\t\t\t// If there are already messages in the queue add the new one that all of them\n\t\t\t// get executed in order\n\t\t\tqueuePushMessage(receivedData, retryAttempts);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (receivedData.type === 'nodeExecuteAfter' || receivedData.type === 'nodeExecuteBefore') {\n\t\t\tif (!uiStore.isActionActive('workflowRunning')) {\n\t\t\t\t// No workflow is running so ignore the messages\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconst pushData = receivedData.data;\n\t\t\tif (workflowsStore.activeExecutionId !== pushData.executionId) {\n\t\t\t\t// The data is not for the currently active execution or\n\t\t\t\t// we do not have the execution id yet.\n\t\t\t\tif (isRetry !== true) {\n\t\t\t\t\tqueuePushMessage(event as unknown as IPushData, retryAttempts);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// recovered execution data is handled like executionFinished data, however for security reasons\n\t\t// we need to fetch the data from the server again rather than push it to all clients\n\t\tlet recoveredPushData: IPushDataExecutionFinished | undefined = undefined;\n\t\tif (receivedData.type === 'executionRecovered') {\n\t\t\tconst recoveredExecutionId = receivedData.data?.executionId;\n\t\t\tconst isWorkflowRunning = uiStore.isActionActive('workflowRunning');\n\t\t\tif (isWorkflowRunning && workflowsStore.activeExecutionId === recoveredExecutionId) {\n\t\t\t\t// pull execution data for the recovered execution from the server\n\t\t\t\tconst executionData = await workflowsStore.fetchExecutionDataById(\n\t\t\t\t\tworkflowsStore.activeExecutionId,\n\t\t\t\t);\n\t\t\t\tif (executionData?.data) {\n\t\t\t\t\t// data comes in as 'flatten' object, so we need to parse it\n\t\t\t\t\texecutionData.data = parse(executionData.data as unknown as string) as IRunExecutionData;\n\t\t\t\t\tconst iRunExecutionData: IRunExecutionData = {\n\t\t\t\t\t\tstartData: executionData.data?.startData,\n\t\t\t\t\t\tresultData: executionData.data?.resultData ?? { runData: {} },\n\t\t\t\t\t\texecutionData: executionData.data?.executionData,\n\t\t\t\t\t};\n\t\t\t\t\tif (workflowsStore.workflowExecutionData?.workflowId === executionData.workflowId) {\n\t\t\t\t\t\tconst activeRunData = workflowsStore.workflowExecutionData?.data?.resultData?.runData;\n\t\t\t\t\t\tif (activeRunData) {\n\t\t\t\t\t\t\tfor (const key of Object.keys(activeRunData)) {\n\t\t\t\t\t\t\t\tiRunExecutionData.resultData.runData[key] = activeRunData[key];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst iRun: IRun = {\n\t\t\t\t\t\tdata: iRunExecutionData,\n\t\t\t\t\t\tfinished: executionData.finished,\n\t\t\t\t\t\tmode: executionData.mode,\n\t\t\t\t\t\twaitTill: executionData.data?.waitTill,\n\t\t\t\t\t\tstartedAt: executionData.startedAt,\n\t\t\t\t\t\tstoppedAt: executionData.stoppedAt,\n\t\t\t\t\t\tstatus: 'crashed',\n\t\t\t\t\t};\n\t\t\t\t\tif (executionData.data) {\n\t\t\t\t\t\trecoveredPushData = {\n\t\t\t\t\t\t\texecutionId: executionData.id,\n\t\t\t\t\t\t\tdata: iRun,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\treceivedData.type === 'workflowFailedToActivate' &&\n\t\t\tworkflowsStore.workflowId === receivedData.data.workflowId\n\t\t) {\n\t\t\tworkflowsStore.setWorkflowInactive(receivedData.data.workflowId);\n\t\t\tworkflowsStore.setActive(false);\n\n\t\t\ttoast.showError(\n\t\t\t\tnew Error(receivedData.data.errorMessage),\n\t\t\t\ti18n.baseText('workflowActivator.showError.title', {\n\t\t\t\t\tinterpolate: { newStateName: 'activated' },\n\t\t\t\t}) + ':',\n\t\t\t);\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif (receivedData.type === 'workflowActivated') {\n\t\t\tworkflowsStore.setWorkflowActive(receivedData.data.workflowId);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (receivedData.type === 'workflowDeactivated') {\n\t\t\tworkflowsStore.setWorkflowInactive(receivedData.data.workflowId);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (receivedData.type === 'executionFinished' || receivedData.type === 'executionRecovered') {\n\t\t\t// The workflow finished executing\n\t\t\tlet pushData: IPushDataExecutionFinished;\n\t\t\tif (receivedData.type === 'executionRecovered' && recoveredPushData !== undefined) {\n\t\t\t\tpushData = recoveredPushData;\n\t\t\t} else {\n\t\t\t\tpushData = receivedData.data as IPushDataExecutionFinished;\n\t\t\t}\n\n\t\t\tconst { activeExecutionId } = workflowsStore;\n\t\t\tif (activeExecutionId === pushData.executionId) {\n\t\t\t\tconst activeRunData = workflowsStore.workflowExecutionData?.data?.resultData?.runData;\n\t\t\t\tif (activeRunData) {\n\t\t\t\t\tfor (const key of Object.keys(activeRunData)) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tpushData.data.data.resultData.runData[key]?.[0]?.data?.main?.[0]?.[0]?.json\n\t\t\t\t\t\t\t\t?.isArtificialRecoveredEventItem === true &&\n\t\t\t\t\t\t\tactiveRunData[key].length > 0\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\tpushData.data.data.resultData.runData[key] = activeRunData[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tworkflowsStore.finishActiveExecution(pushData);\n\t\t\t}\n\n\t\t\tif (!uiStore.isActionActive('workflowRunning')) {\n\t\t\t\t// No workflow is running so ignore the messages\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (activeExecutionId !== pushData.executionId) {\n\t\t\t\t// The workflow which did finish execution did either not get started\n\t\t\t\t// by this session or we do not have the execution id yet.\n\t\t\t\tif (isRetry !== true) {\n\t\t\t\t\tqueuePushMessage(event as unknown as IPushData, retryAttempts);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst runDataExecuted = pushData.data;\n\n\t\t\tlet runDataExecutedErrorMessage = getExecutionError(runDataExecuted.data);\n\n\t\t\tif (runDataExecuted.status === 'crashed') {\n\t\t\t\trunDataExecutedErrorMessage = i18n.baseText('pushConnection.executionFailed.message');\n\t\t\t} else if (runDataExecuted.status === 'canceled') {\n\t\t\t\trunDataExecutedErrorMessage = i18n.baseText(\n\t\t\t\t\t'executionsList.showMessage.stopExecution.message',\n\t\t\t\t\t{\n\t\t\t\t\t\tinterpolate: { activeExecutionId },\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst lineNumber = runDataExecuted?.data?.resultData?.error?.lineNumber;\n\n\t\t\tcodeNodeEditorEventBus.emit('error-line-number', lineNumber || 'final');\n\n\t\t\tconst workflow = workflowHelpers.getCurrentWorkflow();\n\t\t\tif (runDataExecuted.waitTill !== undefined) {\n\t\t\t\tconst workflowSettings = workflowsStore.workflowSettings;\n\t\t\t\tconst saveManualExecutions = settingsStore.saveManualExecutions;\n\n\t\t\t\tconst isSavingExecutions =\n\t\t\t\t\tworkflowSettings.saveManualExecutions === undefined\n\t\t\t\t\t\t? saveManualExecutions\n\t\t\t\t\t\t: workflowSettings.saveManualExecutions;\n\n\t\t\t\tlet action;\n\t\t\t\tif (!isSavingExecutions) {\n\t\t\t\t\tglobalLinkActionsEventBus.emit('registerGlobalLinkAction', {\n\t\t\t\t\t\tkey: 'open-settings',\n\t\t\t\t\t\taction: async () => {\n\t\t\t\t\t\t\tif (workflowsStore.isNewWorkflow) await workflowHelpers.saveAsNewWorkflow();\n\t\t\t\t\t\t\tuiStore.openModal(WORKFLOW_SETTINGS_MODAL_KEY);\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\n\t\t\t\t\taction =\n\t\t\t\t\t\t'<a data-action=\"open-settings\">Turn on saving manual executions</a> and run again to see what happened after this node.';\n\t\t\t\t} else {\n\t\t\t\t\taction = `<a href=\"/workflow/${workflow.id}/executions/${activeExecutionId}\">View the execution</a> to see what happened after this node.`;\n\t\t\t\t}\n\n\t\t\t\t// Workflow did start but had been put to wait\n\t\t\t\ttitleChange.titleSet(workflow.name as string, 'IDLE');\n\t\t\t\ttoast.showToast({\n\t\t\t\t\ttitle: 'Workflow started waiting',\n\t\t\t\t\tmessage: `${action} <a href=\"https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.wait/\" target=\"_blank\">More info</a>`,\n\t\t\t\t\ttype: 'success',\n\t\t\t\t\tduration: 0,\n\t\t\t\t});\n\t\t\t} else if (runDataExecuted.finished !== true) {\n\t\t\t\ttitleChange.titleSet(workflow.name as string, 'ERROR');\n\n\t\t\t\tif (\n\t\t\t\t\trunDataExecuted.data.resultData.error?.name === 'ExpressionError' &&\n\t\t\t\t\t(runDataExecuted.data.resultData.error as ExpressionError).context.functionality ===\n\t\t\t\t\t\t'pairedItem'\n\t\t\t\t) {\n\t\t\t\t\tconst error = runDataExecuted.data.resultData.error as ExpressionError;\n\n\t\t\t\t\tvoid workflowHelpers.getWorkflowDataToSave().then((workflowData) => {\n\t\t\t\t\t\tconst eventData: IDataObject = {\n\t\t\t\t\t\t\tcaused_by_credential: false,\n\t\t\t\t\t\t\terror_message: error.description,\n\t\t\t\t\t\t\terror_title: error.message,\n\t\t\t\t\t\t\terror_type: error.context.type,\n\t\t\t\t\t\t\tnode_graph_string: JSON.stringify(\n\t\t\t\t\t\t\t\tTelemetryHelpers.generateNodesGraph(\n\t\t\t\t\t\t\t\t\tworkflowData as IWorkflowBase,\n\t\t\t\t\t\t\t\t\tworkflowHelpers.getNodeTypes(),\n\t\t\t\t\t\t\t\t).nodeGraph,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tworkflow_id: workflowsStore.workflowId,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\terror.context.nodeCause &&\n\t\t\t\t\t\t\t['paired_item_no_info', 'paired_item_invalid_info'].includes(\n\t\t\t\t\t\t\t\terror.context.type as string,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst node = workflow.getNode(error.context.nodeCause as string);\n\n\t\t\t\t\t\t\tif (node) {\n\t\t\t\t\t\t\t\teventData.is_pinned = !!workflow.getPinDataOfNode(node.name);\n\t\t\t\t\t\t\t\teventData.mode = node.parameters.mode;\n\t\t\t\t\t\t\t\teventData.node_type = node.type;\n\t\t\t\t\t\t\t\teventData.operation = node.parameters.operation;\n\t\t\t\t\t\t\t\teventData.resource = node.parameters.resource;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttelemetry.track('Instance FE emitted paired item error', eventData, {\n\t\t\t\t\t\t\twithPostHog: true,\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (runDataExecuted.data.resultData.error?.name === 'SubworkflowOperationError') {\n\t\t\t\t\tconst error = runDataExecuted.data.resultData.error as SubworkflowOperationError;\n\n\t\t\t\t\tworkflowsStore.subWorkflowExecutionError = error;\n\n\t\t\t\t\ttoast.showMessage({\n\t\t\t\t\t\ttitle: error.message,\n\t\t\t\t\t\tmessage: error.description,\n\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\tduration: 0,\n\t\t\t\t\t});\n\t\t\t\t} else if (\n\t\t\t\t\trunDataExecuted.data.resultData.error?.name === 'NodeOperationError' &&\n\t\t\t\t\t(runDataExecuted.data.resultData.error as NodeOperationError).functionality ===\n\t\t\t\t\t\t'configuration-node'\n\t\t\t\t) {\n\t\t\t\t\t// If the error is a configuration error of the node itself doesn't get executed so we can't use lastNodeExecuted for the title\n\t\t\t\t\tlet title: string;\n\t\t\t\t\tconst nodeError = runDataExecuted.data.resultData.error as NodeOperationError;\n\t\t\t\t\tif (nodeError.node.name) {\n\t\t\t\t\t\ttitle = `Error in sub-node ‘${nodeError.node.name}‘`;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttitle = 'Problem executing workflow';\n\t\t\t\t\t}\n\n\t\t\t\t\ttoast.showMessage({\n\t\t\t\t\t\ttitle,\n\t\t\t\t\t\tmessage:\n\t\t\t\t\t\t\t(nodeError?.description ?? runDataExecutedErrorMessage) +\n\t\t\t\t\t\t\ti18n.baseText('pushConnection.executionError.openNode', {\n\t\t\t\t\t\t\t\tinterpolate: {\n\t\t\t\t\t\t\t\t\tnode: nodeError.node.name,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\tduration: 0,\n\t\t\t\t\t\tdangerouslyUseHTMLString: true,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tlet title: string;\n\t\t\t\t\tconst isManualExecutionCancelled =\n\t\t\t\t\t\trunDataExecuted.mode === 'manual' && runDataExecuted.status === 'canceled';\n\n\t\t\t\t\t// Do not show the error message if the workflow got canceled manually\n\t\t\t\t\tif (isManualExecutionCancelled) {\n\t\t\t\t\t\ttoast.showMessage({\n\t\t\t\t\t\t\ttitle: i18n.baseText('nodeView.showMessage.stopExecutionTry.title'),\n\t\t\t\t\t\t\ttype: 'success',\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (runDataExecuted.data.resultData.lastNodeExecuted) {\n\t\t\t\t\t\t\ttitle = `Problem in node ‘${runDataExecuted.data.resultData.lastNodeExecuted}‘`;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttitle = 'Problem executing workflow';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttoast.showMessage({\n\t\t\t\t\t\t\ttitle,\n\t\t\t\t\t\t\tmessage: runDataExecutedErrorMessage,\n\t\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\t\tduration: 0,\n\t\t\t\t\t\t\tdangerouslyUseHTMLString: true,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Workflow did execute without a problem\n\t\t\t\ttitleChange.titleSet(workflow.name as string, 'IDLE');\n\n\t\t\t\tconst execution = workflowsStore.getWorkflowExecution;\n\t\t\t\tif (execution?.executedNode) {\n\t\t\t\t\tconst node = workflowsStore.getNodeByName(execution.executedNode);\n\t\t\t\t\tconst nodeType = node && nodeTypesStore.getNodeType(node.type, node.typeVersion);\n\t\t\t\t\tconst nodeOutput =\n\t\t\t\t\t\texecution &&\n\t\t\t\t\t\texecution.executedNode &&\n\t\t\t\t\t\texecution.data?.resultData?.runData?.[execution.executedNode];\n\t\t\t\t\tif (nodeType?.polling && !nodeOutput) {\n\t\t\t\t\t\ttoast.showMessage({\n\t\t\t\t\t\t\ttitle: i18n.baseText('pushConnection.pollingNode.dataNotFound', {\n\t\t\t\t\t\t\t\tinterpolate: {\n\t\t\t\t\t\t\t\t\tservice: getTriggerNodeServiceName(nodeType),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\tmessage: i18n.baseText('pushConnection.pollingNode.dataNotFound.message', {\n\t\t\t\t\t\t\t\tinterpolate: {\n\t\t\t\t\t\t\t\t\tservice: getTriggerNodeServiceName(nodeType),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\ttype: 'success',\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttoast.showMessage({\n\t\t\t\t\t\t\ttitle: i18n.baseText('pushConnection.nodeExecutedSuccessfully'),\n\t\t\t\t\t\t\ttype: 'success',\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttoast.showMessage({\n\t\t\t\t\t\ttitle: i18n.baseText('pushConnection.workflowExecutedSuccessfully'),\n\t\t\t\t\t\ttype: 'success',\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// It does not push the runData as it got already pushed with each\n\t\t\t// node that did finish. For that reason copy in here the data\n\t\t\t// which we already have.\n\t\t\tif (workflowsStore.getWorkflowRunData) {\n\t\t\t\trunDataExecuted.data.resultData.runData = workflowsStore.getWorkflowRunData;\n\t\t\t}\n\n\t\t\tworkflowsStore.executingNode.length = 0;\n\t\t\tworkflowsStore.setWorkflowExecutionData(runDataExecuted as IExecutionResponse);\n\t\t\tuiStore.removeActiveAction('workflowRunning');\n\n\t\t\t// Set the node execution issues on all the nodes which produced an error so that\n\t\t\t// it can be displayed in the node-view\n\t\t\tnodeHelpers.updateNodesExecutionIssues();\n\n\t\t\tconst lastNodeExecuted: string | undefined = runDataExecuted.data.resultData.lastNodeExecuted;\n\t\t\tlet itemsCount = 0;\n\t\t\tif (\n\t\t\t\tlastNodeExecuted &&\n\t\t\t\trunDataExecuted.data.resultData.runData[lastNodeExecuted] &&\n\t\t\t\t!runDataExecutedErrorMessage\n\t\t\t) {\n\t\t\t\titemsCount =\n\t\t\t\t\trunDataExecuted.data.resultData.runData[lastNodeExecuted][0].data!.main[0]!.length;\n\t\t\t}\n\n\t\t\tvoid useExternalHooks().run('pushConnection.executionFinished', {\n\t\t\t\titemsCount,\n\t\t\t\tnodeName: runDataExecuted.data.resultData.lastNodeExecuted,\n\t\t\t\terrorMessage: runDataExecutedErrorMessage,\n\t\t\t\trunDataExecutedStartData: runDataExecuted.data.startData,\n\t\t\t\tresultDataError: runDataExecuted.data.resultData.error,\n\t\t\t});\n\t\t\tif (!runDataExecuted.data.resultData.error) {\n\t\t\t\tsegmentStore.trackSuccessfulWorkflowExecution(runDataExecuted);\n\t\t\t}\n\t\t} else if (receivedData.type === 'executionStarted') {\n\t\t\tconst pushData = receivedData.data;\n\n\t\t\tconst executionData: IExecutionsCurrentSummaryExtended = {\n\t\t\t\tid: pushData.executionId,\n\t\t\t\tfinished: false,\n\t\t\t\tstatus: 'running',\n\t\t\t\tmode: pushData.mode,\n\t\t\t\tstartedAt: pushData.startedAt,\n\t\t\t\tretryOf: pushData.retryOf,\n\t\t\t\tworkflowId: pushData.workflowId,\n\t\t\t\tworkflowName: pushData.workflowName,\n\t\t\t};\n\n\t\t\tworkflowsStore.addActiveExecution(executionData);\n\t\t} else if (receivedData.type === 'nodeExecuteAfter') {\n\t\t\t// A node finished to execute. Add its data\n\t\t\tconst pushData = receivedData.data;\n\t\t\tworkflowsStore.addNodeExecutionData(pushData);\n\t\t\tworkflowsStore.removeExecutingNode(pushData.nodeName);\n\t\t} else if (receivedData.type === 'nodeExecuteBefore') {\n\t\t\t// A node started to be executed. Set it as executing.\n\t\t\tconst pushData = receivedData.data;\n\t\t\tworkflowsStore.addExecutingNode(pushData.nodeName);\n\t\t} else if (receivedData.type === 'testWebhookDeleted') {\n\t\t\t// A test-webhook was deleted\n\t\t\tconst pushData = receivedData.data;\n\n\t\t\tif (pushData.workflowId === workflowsStore.workflowId) {\n\t\t\t\tworkflowsStore.executionWaitingForWebhook = false;\n\t\t\t\tuiStore.removeActiveAction('workflowRunning');\n\t\t\t}\n\t\t} else if (receivedData.type === 'testWebhookReceived') {\n\t\t\t// A test-webhook did get called\n\t\t\tconst pushData = receivedData.data;\n\n\t\t\tif (pushData.workflowId === workflowsStore.workflowId) {\n\t\t\t\tworkflowsStore.executionWaitingForWebhook = false;\n\t\t\t\tworkflowsStore.activeExecutionId = pushData.executionId;\n\t\t\t}\n\n\t\t\tvoid processWaitingPushMessages();\n\t\t} else if (receivedData.type === 'reloadNodeType') {\n\t\t\tawait nodeTypesStore.getNodeTypes();\n\t\t\tawait nodeTypesStore.getFullNodesProperties([receivedData.data]);\n\t\t} else if (receivedData.type === 'removeNodeType') {\n\t\t\tconst pushData = receivedData.data;\n\n\t\t\tconst nodesToBeRemoved: INodeTypeNameVersion[] = [pushData];\n\n\t\t\t// Force reload of all credential types\n\t\t\tawait credentialsStore.fetchCredentialTypes(false).then(() => {\n\t\t\t\tnodeTypesStore.removeNodeTypes(nodesToBeRemoved as INodeTypeDescription[]);\n\t\t\t});\n\t\t} else if (receivedData.type === 'nodeDescriptionUpdated') {\n\t\t\tawait nodeTypesStore.getNodeTypes();\n\t\t\tawait credentialsStore.fetchCredentialTypes(true);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction getExecutionError(data: IRunExecutionData | IExecuteContextData) {\n\t\tconst error = data.resultData.error;\n\n\t\tlet errorMessage: string;\n\n\t\tif (data.resultData.lastNodeExecuted && error) {\n\t\t\terrorMessage = error.message || error.description;\n\t\t} else {\n\t\t\terrorMessage = i18n.baseText('pushConnection.executionError', {\n\t\t\t\tinterpolate: { error: '!' },\n\t\t\t});\n\n\t\t\tif (error?.message) {\n\t\t\t\tlet nodeName: string | undefined;\n\t\t\t\tif ('node' in error) {\n\t\t\t\t\tnodeName = typeof error.node === 'string' ? error.node : error.node!.name;\n\t\t\t\t}\n\n\t\t\t\tconst receivedError = nodeName ? `${nodeName}: ${error.message}` : error.message;\n\t\t\t\terrorMessage = i18n.baseText('pushConnection.executionError', {\n\t\t\t\t\tinterpolate: {\n\t\t\t\t\t\terror: `.${i18n.baseText('pushConnection.executionError.details', {\n\t\t\t\t\t\t\tinterpolate: {\n\t\t\t\t\t\t\t\tdetails: receivedError,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})}`,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn errorMessage;\n\t}\n\n\treturn {\n\t\tinitialize,\n\t\tterminate,\n\t\tpushMessageReceived,\n\t\tqueuePushMessage,\n\t\tprocessWaitingPushMessages,\n\t\tpushMessageQueue,\n\t\tremoveEventListener,\n\t\tretryTimeout,\n\t};\n}\n"],"names":["GET_STATUS_ENDPOINT","sendGetWorkerStatus","context","makeRestApiRequest","WORKER_HISTORY_LENGTH","STALE_SECONDS","useOrchestrationStore","defineStore","data","id","rootStore","useRootStore","workerId","usePushConnection","router","workflowHelpers","useWorkflowHelpers","nodeHelpers","useNodeHelpers","titleChange","useTitleChange","toast","useToast","i18n","useI18n","telemetry","useTelemetry","collaborationStore","useCollaborationStore","credentialsStore","useCredentialsStore","nodeTypesStore","useNodeTypesStore","orchestrationManagerStore","pushStore","usePushConnectionStore","settingsStore","useSettingsStore","segmentStore","useSegment","uiStore","useUIStore","workflowsStore","useWorkflowsStore","retryTimeout","ref","pushMessageQueue","removeEventListener","initialize","message","pushMessageReceived","terminate","queuePushMessage","event","retryAttempts","processWaitingPushMessages","queueLength","i","messageData","receivedData","isRetry","pushData","recoveredPushData","recoveredExecutionId","_a","executionData","parse","iRunExecutionData","_b","_c","_d","_e","activeRunData","_h","_g","_f","key","iRun","_i","activeExecutionId","_l","_k","_j","_s","_r","_q","_p","_o","_n","_m","runDataExecuted","runDataExecutedErrorMessage","getExecutionError","lineNumber","_v","_u","_t","codeNodeEditorEventBus","workflow","workflowSettings","saveManualExecutions","isSavingExecutions","action","globalLinkActionsEventBus","WORKFLOW_SETTINGS_MODAL_KEY","_w","error","workflowData","eventData","TelemetryHelpers.generateNodesGraph","node","_x","_y","title","nodeError","execution","nodeType","nodeOutput","_B","_A","_z","getTriggerNodeServiceName","lastNodeExecuted","itemsCount","useExternalHooks","nodesToBeRemoved","errorMessage","nodeName","receivedError"],"mappings":"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"}