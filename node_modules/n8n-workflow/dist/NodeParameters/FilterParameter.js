"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateFilterParameter = exports.executeFilter = exports.executeFilterCondition = exports.FilterError = void 0;
const TypeValidation_1 = require("../TypeValidation");
const LoggerProxy = __importStar(require("../LoggerProxy"));
class FilterError extends Error {
    constructor(message, description) {
        super(message);
        this.description = description;
    }
}
exports.FilterError = FilterError;
function parseSingleFilterValue(value, type, strict = false) {
    if (type === 'any' || value === null || value === undefined) {
        return { valid: true, newValue: value };
    }
    if (type === 'boolean' && !strict) {
        return { valid: true, newValue: Boolean(value) };
    }
    if (type === 'number' && Number.isNaN(value)) {
        return { valid: true, newValue: value };
    }
    return (0, TypeValidation_1.validateFieldType)('filter', value, type, { strict, parseStrings: true });
}
const withIndefiniteArticle = (noun) => {
    const article = 'aeiou'.includes(noun.charAt(0)) ? 'an' : 'a';
    return `${article} ${noun}`;
};
function parseFilterConditionValues(condition, options, metadata) {
    var _a, _b, _c, _d;
    const index = (_a = metadata.index) !== null && _a !== void 0 ? _a : 0;
    const itemIndex = (_b = metadata.itemIndex) !== null && _b !== void 0 ? _b : 0;
    const errorFormat = (_c = metadata.errorFormat) !== null && _c !== void 0 ? _c : 'full';
    const strict = options.typeValidation === 'strict';
    const { operator } = condition;
    const rightType = (_d = operator.rightType) !== null && _d !== void 0 ? _d : operator.type;
    const parsedLeftValue = parseSingleFilterValue(condition.leftValue, operator.type, strict);
    const parsedRightValue = parseSingleFilterValue(condition.rightValue, rightType, strict);
    const leftValid = parsedLeftValue.valid ||
        (metadata.unresolvedExpressions &&
            typeof condition.leftValue === 'string' &&
            condition.leftValue.startsWith('='));
    const rightValid = parsedRightValue.valid ||
        !!operator.singleValue ||
        (metadata.unresolvedExpressions &&
            typeof condition.rightValue === 'string' &&
            condition.rightValue.startsWith('='));
    const leftValueString = String(condition.leftValue);
    const rightValueString = String(condition.rightValue);
    const suffix = errorFormat === 'full' ? `[condition ${index}, item ${itemIndex}]` : `[item ${itemIndex}]`;
    const composeInvalidTypeMessage = (type, fromType, value) => {
        fromType = fromType.toLocaleLowerCase();
        if (strict) {
            return `Wrong type: '${value}' is ${withIndefiniteArticle(fromType)} but was expecting ${withIndefiniteArticle(type)} ${suffix}`;
        }
        return `Conversion error: the ${fromType} '${value}' can't be converted to ${withIndefiniteArticle(type)} ${suffix}`;
    };
    const invalidTypeDescription = 'Try changing the type of comparison.';
    if (!leftValid) {
        return {
            ok: false,
            error: new FilterError(composeInvalidTypeMessage(operator.type, typeof condition.leftValue, leftValueString), invalidTypeDescription),
        };
    }
    if (!rightValid) {
        return {
            ok: false,
            error: new FilterError(composeInvalidTypeMessage(rightType, typeof condition.rightValue, rightValueString), invalidTypeDescription),
        };
    }
    return {
        ok: true,
        result: {
            left: parsedLeftValue.valid ? parsedLeftValue.newValue : undefined,
            right: parsedRightValue.valid ? parsedRightValue.newValue : undefined,
        },
    };
}
function parseRegexPattern(pattern) {
    const regexMatch = (pattern || '').match(new RegExp('^/(.*?)/([gimusy]*)$'));
    let regex;
    if (!regexMatch) {
        regex = new RegExp((pattern || '').toString());
    }
    else {
        regex = new RegExp(regexMatch[1], regexMatch[2]);
    }
    return regex;
}
function executeFilterCondition(condition, filterOptions, metadata = {}) {
    const ignoreCase = !filterOptions.caseSensitive;
    const { operator } = condition;
    const parsedValues = parseFilterConditionValues(condition, filterOptions, metadata);
    if (!parsedValues.ok) {
        throw parsedValues.error;
    }
    let { left: leftValue, right: rightValue } = parsedValues.result;
    const exists = leftValue !== undefined && leftValue !== null && !Number.isNaN(leftValue);
    if (condition.operator.operation === 'exists') {
        return exists;
    }
    else if (condition.operator.operation === 'notExists') {
        return !exists;
    }
    switch (operator.type) {
        case 'string': {
            if (ignoreCase) {
                if (typeof leftValue === 'string') {
                    leftValue = leftValue.toLocaleLowerCase();
                }
                if (typeof rightValue === 'string' &&
                    !(condition.operator.operation === 'regex' || condition.operator.operation === 'notRegex')) {
                    rightValue = rightValue.toLocaleLowerCase();
                }
            }
            const left = (leftValue !== null && leftValue !== void 0 ? leftValue : '');
            const right = (rightValue !== null && rightValue !== void 0 ? rightValue : '');
            switch (condition.operator.operation) {
                case 'empty':
                    return left.length === 0;
                case 'notEmpty':
                    return left.length !== 0;
                case 'equals':
                    return left === right;
                case 'notEquals':
                    return left !== right;
                case 'contains':
                    return left.includes(right);
                case 'notContains':
                    return !left.includes(right);
                case 'startsWith':
                    return left.startsWith(right);
                case 'notStartsWith':
                    return !left.startsWith(right);
                case 'endsWith':
                    return left.endsWith(right);
                case 'notEndsWith':
                    return !left.endsWith(right);
                case 'regex':
                    return parseRegexPattern(right).test(left);
                case 'notRegex':
                    return !parseRegexPattern(right).test(left);
            }
            break;
        }
        case 'number': {
            const left = leftValue;
            const right = rightValue;
            switch (condition.operator.operation) {
                case 'empty':
                    return !exists;
                case 'notEmpty':
                    return exists;
                case 'equals':
                    return left === right;
                case 'notEquals':
                    return left !== right;
                case 'gt':
                    return left > right;
                case 'lt':
                    return left < right;
                case 'gte':
                    return left >= right;
                case 'lte':
                    return left <= right;
            }
        }
        case 'dateTime': {
            const left = leftValue;
            const right = rightValue;
            if (condition.operator.operation === 'empty') {
                return !exists;
            }
            else if (condition.operator.operation === 'notEmpty') {
                return exists;
            }
            if (!left || !right) {
                return false;
            }
            switch (condition.operator.operation) {
                case 'equals':
                    return left.toMillis() === right.toMillis();
                case 'notEquals':
                    return left.toMillis() !== right.toMillis();
                case 'after':
                    return left.toMillis() > right.toMillis();
                case 'before':
                    return left.toMillis() < right.toMillis();
                case 'afterOrEquals':
                    return left.toMillis() >= right.toMillis();
                case 'beforeOrEquals':
                    return left.toMillis() <= right.toMillis();
            }
        }
        case 'boolean': {
            const left = leftValue;
            const right = rightValue;
            switch (condition.operator.operation) {
                case 'empty':
                    return !exists;
                case 'notEmpty':
                    return exists;
                case 'true':
                    return left;
                case 'false':
                    return !left;
                case 'equals':
                    return left === right;
                case 'notEquals':
                    return left !== right;
            }
        }
        case 'array': {
            const left = (leftValue !== null && leftValue !== void 0 ? leftValue : []);
            const rightNumber = rightValue;
            switch (condition.operator.operation) {
                case 'contains':
                    if (ignoreCase && typeof rightValue === 'string') {
                        rightValue = rightValue.toLocaleLowerCase();
                    }
                    return left.includes(rightValue);
                case 'notContains':
                    if (ignoreCase && typeof rightValue === 'string') {
                        rightValue = rightValue.toLocaleLowerCase();
                    }
                    return !left.includes(rightValue);
                case 'lengthEquals':
                    return left.length === rightNumber;
                case 'lengthNotEquals':
                    return left.length !== rightNumber;
                case 'lengthGt':
                    return left.length > rightNumber;
                case 'lengthLt':
                    return left.length < rightNumber;
                case 'lengthGte':
                    return left.length >= rightNumber;
                case 'lengthLte':
                    return left.length <= rightNumber;
                case 'empty':
                    return left.length === 0;
                case 'notEmpty':
                    return left.length !== 0;
            }
        }
        case 'object': {
            const left = leftValue;
            switch (condition.operator.operation) {
                case 'empty':
                    return !left || Object.keys(left).length === 0;
                case 'notEmpty':
                    return !!left && Object.keys(left).length !== 0;
            }
        }
    }
    LoggerProxy.warn(`Unknown filter parameter operator "${operator.type}:${operator.operation}"`);
    return false;
}
exports.executeFilterCondition = executeFilterCondition;
function executeFilter(value, { itemIndex } = {}) {
    const conditionPass = (condition, index) => executeFilterCondition(condition, value.options, { index, itemIndex });
    if (value.combinator === 'and') {
        return value.conditions.every(conditionPass);
    }
    else if (value.combinator === 'or') {
        return value.conditions.some(conditionPass);
    }
    LoggerProxy.warn(`Unknown filter combinator "${value.combinator}"`);
    return false;
}
exports.executeFilter = executeFilter;
const validateFilterParameter = (nodeProperties, value) => {
    return value.conditions.reduce((issues, condition, index) => {
        const key = `${nodeProperties.name}.${index}`;
        try {
            parseFilterConditionValues(condition, value.options, {
                index,
                unresolvedExpressions: true,
                errorFormat: 'inline',
            });
        }
        catch (error) {
            if (error instanceof FilterError) {
                issues[key].push(error.message);
            }
        }
        return issues;
    }, {});
};
exports.validateFilterParameter = validateFilterParameter;
//# sourceMappingURL=FilterParameter.js.map