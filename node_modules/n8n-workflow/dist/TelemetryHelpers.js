"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateNodesGraph = exports.getDomainPath = exports.ANONYMIZATION_CHARACTER = exports.getDomainBase = exports.isNumber = exports.getNodeTypeForName = void 0;
const NodeHelpers_1 = require("./NodeHelpers");
const application_error_1 = require("./errors/application.error");
const Constants_1 = require("./Constants");
function getNodeTypeForName(workflow, nodeName) {
    return workflow.nodes.find((node) => node.name === nodeName);
}
exports.getNodeTypeForName = getNodeTypeForName;
function isNumber(value) {
    return typeof value === 'number';
}
exports.isNumber = isNumber;
const countPlaceholders = (text) => {
    const placeholder = /(\{[a-zA-Z0-9_]+\})/g;
    let returnData = 0;
    try {
        const matches = text.matchAll(placeholder);
        for (const _ of matches)
            returnData++;
    }
    catch (error) { }
    return returnData;
};
const countPlaceholdersInParameters = (parameters) => {
    let returnData = 0;
    for (const parameter of parameters) {
        if (!parameter.value) {
            returnData++;
        }
        else {
            returnData += countPlaceholders(String(parameter.value));
        }
    }
    return returnData;
};
function areOverlapping(topLeft, bottomRight, targetPos) {
    return (targetPos[0] > topLeft[0] &&
        targetPos[1] > topLeft[1] &&
        targetPos[0] < bottomRight[0] &&
        targetPos[1] < bottomRight[1]);
}
const URL_PARTS_REGEX = /(?<protocolPlusDomain>.*?\..*?)(?<pathname>\/.*)/;
function getDomainBase(raw, urlParts = URL_PARTS_REGEX) {
    var _a;
    try {
        const url = new URL(raw);
        return [url.protocol, url.hostname].join('//');
    }
    catch {
        const match = urlParts.exec(raw);
        if (!((_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.protocolPlusDomain))
            return '';
        return match.groups.protocolPlusDomain;
    }
}
exports.getDomainBase = getDomainBase;
function isSensitive(segment) {
    if (/^v\d+$/.test(segment))
        return false;
    return /%40/.test(segment) || /\d/.test(segment) || /^[0-9A-F]{8}/i.test(segment);
}
exports.ANONYMIZATION_CHARACTER = '*';
function sanitizeRoute(raw, check = isSensitive, char = exports.ANONYMIZATION_CHARACTER) {
    return raw
        .split('/')
        .map((segment) => (check(segment) ? char.repeat(segment.length) : segment))
        .join('/');
}
function getDomainPath(raw, urlParts = URL_PARTS_REGEX) {
    var _a;
    try {
        const url = new URL(raw);
        if (!url.hostname)
            throw new application_error_1.ApplicationError('Malformed URL');
        return sanitizeRoute(url.pathname);
    }
    catch {
        const match = urlParts.exec(raw);
        if (!((_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.pathname))
            return '';
        const route = match.groups.pathname.split('?').shift();
        return sanitizeRoute(route);
    }
}
exports.getDomainPath = getDomainPath;
function generateNodesGraph(workflow, nodeTypes, options) {
    var _a, _b, _c, _d;
    const nodeGraph = {
        node_types: [],
        node_connections: [],
        nodes: {},
        notes: {},
        is_pinned: Object.keys((_a = workflow.pinData) !== null && _a !== void 0 ? _a : {}).length > 0,
    };
    const nameIndices = {};
    const webhookNodeNames = [];
    const notes = ((_b = workflow.nodes) !== null && _b !== void 0 ? _b : []).filter((node) => node.type === Constants_1.STICKY_NODE_TYPE);
    const otherNodes = ((_c = workflow.nodes) !== null && _c !== void 0 ? _c : []).filter((node) => node.type !== Constants_1.STICKY_NODE_TYPE);
    notes.forEach((stickyNote, index) => {
        var _a;
        const stickyType = nodeTypes.getByNameAndVersion(Constants_1.STICKY_NODE_TYPE, stickyNote.typeVersion);
        if (!stickyType) {
            return;
        }
        let nodeParameters = {};
        try {
            nodeParameters =
                (_a = (0, NodeHelpers_1.getNodeParameters)(stickyType.description.properties, stickyNote.parameters, true, false, stickyNote)) !== null && _a !== void 0 ? _a : {};
        }
        catch {
        }
        const height = typeof nodeParameters.height === 'number' ? nodeParameters.height : 0;
        const width = typeof nodeParameters.width === 'number' ? nodeParameters.width : 0;
        const topLeft = stickyNote.position;
        const bottomRight = [topLeft[0] + width, topLeft[1] + height];
        const overlapping = Boolean(otherNodes.find((node) => areOverlapping(topLeft, bottomRight, node.position)));
        nodeGraph.notes[index] = {
            overlapping,
            position: topLeft,
            height,
            width,
        };
    });
    otherNodes.forEach((node, index) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12;
        nodeGraph.node_types.push(node.type);
        const nodeItem = {
            id: node.id,
            type: node.type,
            version: node.typeVersion,
            position: node.position,
        };
        if (options === null || options === void 0 ? void 0 : options.sourceInstanceId) {
            nodeItem.src_instance_id = options.sourceInstanceId;
        }
        if (node.id && ((_a = options === null || options === void 0 ? void 0 : options.nodeIdMap) === null || _a === void 0 ? void 0 : _a[node.id])) {
            nodeItem.src_node_id = options.nodeIdMap[node.id];
        }
        if (node.type === Constants_1.AGENT_LANGCHAIN_NODE_TYPE) {
            nodeItem.agent = (_b = node.parameters.agent) !== null && _b !== void 0 ? _b : 'conversationalAgent';
        }
        else if (node.type === Constants_1.HTTP_REQUEST_NODE_TYPE && node.typeVersion === 1) {
            try {
                nodeItem.domain = new URL(node.parameters.url).hostname;
            }
            catch {
                nodeItem.domain = getDomainBase(node.parameters.url);
            }
        }
        else if (node.type === Constants_1.HTTP_REQUEST_NODE_TYPE && node.typeVersion > 1) {
            const { authentication } = node.parameters;
            nodeItem.credential_type = {
                none: 'none',
                genericCredentialType: node.parameters.genericAuthType,
                predefinedCredentialType: node.parameters.nodeCredentialType,
            }[authentication];
            nodeItem.credential_set = node.credentials ? Object.keys(node.credentials).length > 0 : false;
            const { url } = node.parameters;
            nodeItem.domain_base = getDomainBase(url);
            nodeItem.domain_path = getDomainPath(url);
            nodeItem.method = node.parameters.requestMethod;
        }
        else if (Constants_1.HTTP_REQUEST_TOOL_LANGCHAIN_NODE_TYPE === node.type) {
            if (!nodeItem.toolSettings)
                nodeItem.toolSettings = {};
            nodeItem.toolSettings.url_type = 'other';
            nodeItem.toolSettings.uses_auth = false;
            nodeItem.toolSettings.placeholders = 0;
            nodeItem.toolSettings.query_from_model_only = false;
            nodeItem.toolSettings.headers_from_model_only = false;
            nodeItem.toolSettings.body_from_model_only = false;
            const toolUrl = (_d = (_c = node.parameters) === null || _c === void 0 ? void 0 : _c.url) !== null && _d !== void 0 ? _d : '';
            nodeItem.toolSettings.placeholders += countPlaceholders(toolUrl);
            const authType = (_f = (_e = node.parameters) === null || _e === void 0 ? void 0 : _e.authentication) !== null && _f !== void 0 ? _f : '';
            if (authType && authType !== 'none') {
                nodeItem.toolSettings.uses_auth = true;
            }
            if (toolUrl.startsWith('{') && toolUrl.endsWith('}')) {
                nodeItem.toolSettings.url_type = 'any';
            }
            else if (toolUrl.includes('google.com')) {
                nodeItem.toolSettings.url_type = 'google';
            }
            if ((_g = node.parameters) === null || _g === void 0 ? void 0 : _g.sendBody) {
                if (((_h = node.parameters) === null || _h === void 0 ? void 0 : _h.specifyBody) === 'model') {
                    nodeItem.toolSettings.body_from_model_only = true;
                }
                if ((_j = node.parameters) === null || _j === void 0 ? void 0 : _j.jsonBody) {
                    nodeItem.toolSettings.placeholders += countPlaceholders((_k = node.parameters) === null || _k === void 0 ? void 0 : _k.jsonBody);
                }
                if ((_l = node.parameters) === null || _l === void 0 ? void 0 : _l.parametersBody) {
                    const parameters = ((_m = node.parameters) === null || _m === void 0 ? void 0 : _m.parametersBody)
                        .values;
                    nodeItem.toolSettings.placeholders += countPlaceholdersInParameters(parameters);
                }
            }
            if ((_o = node.parameters) === null || _o === void 0 ? void 0 : _o.sendHeaders) {
                if (((_p = node.parameters) === null || _p === void 0 ? void 0 : _p.specifyHeaders) === 'model') {
                    nodeItem.toolSettings.headers_from_model_only = true;
                }
                if ((_q = node.parameters) === null || _q === void 0 ? void 0 : _q.jsonHeaders) {
                    nodeItem.toolSettings.placeholders += countPlaceholders((_r = node.parameters) === null || _r === void 0 ? void 0 : _r.jsonHeaders);
                }
                if ((_s = node.parameters) === null || _s === void 0 ? void 0 : _s.parametersHeaders) {
                    const parameters = ((_t = node.parameters) === null || _t === void 0 ? void 0 : _t.parametersHeaders)
                        .values;
                    nodeItem.toolSettings.placeholders += countPlaceholdersInParameters(parameters);
                }
            }
            if ((_u = node.parameters) === null || _u === void 0 ? void 0 : _u.sendQuery) {
                if (((_v = node.parameters) === null || _v === void 0 ? void 0 : _v.specifyQuery) === 'model') {
                    nodeItem.toolSettings.query_from_model_only = true;
                }
                if ((_w = node.parameters) === null || _w === void 0 ? void 0 : _w.jsonQuery) {
                    nodeItem.toolSettings.placeholders += countPlaceholders((_x = node.parameters) === null || _x === void 0 ? void 0 : _x.jsonQuery);
                }
                if ((_y = node.parameters) === null || _y === void 0 ? void 0 : _y.parametersQuery) {
                    const parameters = ((_z = node.parameters) === null || _z === void 0 ? void 0 : _z.parametersQuery)
                        .values;
                    nodeItem.toolSettings.placeholders += countPlaceholdersInParameters(parameters);
                }
            }
        }
        else if (node.type === Constants_1.WEBHOOK_NODE_TYPE) {
            webhookNodeNames.push(node.name);
        }
        else {
            try {
                const nodeType = nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
                if (nodeType) {
                    const nodeParameters = (0, NodeHelpers_1.getNodeParameters)(nodeType.description.properties, node.parameters, true, false, node);
                    if (nodeParameters) {
                        const keys = [
                            'operation',
                            'resource',
                            'mode',
                        ];
                        keys.forEach((key) => {
                            var _a;
                            if (nodeParameters.hasOwnProperty(key)) {
                                nodeItem[key] = (_a = nodeParameters[key]) === null || _a === void 0 ? void 0 : _a.toString();
                            }
                        });
                    }
                }
            }
            catch (e) {
                if (!(e instanceof Error && e.message.includes('Unrecognized node type'))) {
                    throw e;
                }
            }
        }
        if ((options === null || options === void 0 ? void 0 : options.isCloudDeployment) === true) {
            if (node.type === Constants_1.OPENAI_LANGCHAIN_NODE_TYPE) {
                nodeItem.prompts =
                    (_2 = ((_1 = (_0 = node.parameters) === null || _0 === void 0 ? void 0 : _0.messages) !== null && _1 !== void 0 ? _1 : {}).values) !== null && _2 !== void 0 ? _2 : [];
            }
            if (node.type === Constants_1.AGENT_LANGCHAIN_NODE_TYPE) {
                const prompts = {};
                if ((_3 = node.parameters) === null || _3 === void 0 ? void 0 : _3.text) {
                    prompts.text = node.parameters.text;
                }
                const nodeOptions = (_4 = node.parameters) === null || _4 === void 0 ? void 0 : _4.options;
                if (nodeOptions) {
                    const optionalMessagesKeys = [
                        'humanMessage',
                        'systemMessage',
                        'humanMessageTemplate',
                        'prefix',
                        'suffixChat',
                        'suffix',
                        'prefixPrompt',
                        'suffixPrompt',
                    ];
                    for (const key of optionalMessagesKeys) {
                        if (nodeOptions[key]) {
                            prompts[key] = nodeOptions[key];
                        }
                    }
                }
                if (Object.keys(prompts).length) {
                    nodeItem.prompts = prompts;
                }
            }
            if (node.type === Constants_1.CHAIN_SUMMARIZATION_LANGCHAIN_NODE_TYPE) {
                nodeItem.prompts = ((_7 = ((_6 = (_5 = node.parameters) === null || _5 === void 0 ? void 0 : _5.options) !== null && _6 !== void 0 ? _6 : {})
                    .summarizationMethodAndPrompts) !== null && _7 !== void 0 ? _7 : {}).values;
            }
            if (Constants_1.LANGCHAIN_CUSTOM_TOOLS.includes(node.type)) {
                nodeItem.prompts = {
                    description: (_9 = (_8 = node.parameters) === null || _8 === void 0 ? void 0 : _8.description) !== null && _9 !== void 0 ? _9 : '',
                };
            }
            if (node.type === Constants_1.CHAIN_LLM_LANGCHAIN_NODE_TYPE) {
                nodeItem.prompts =
                    (_12 = ((_11 = (_10 = node.parameters) === null || _10 === void 0 ? void 0 : _10.messages) !== null && _11 !== void 0 ? _11 : {}).messageValues) !== null && _12 !== void 0 ? _12 : [];
            }
        }
        nodeGraph.nodes[index.toString()] = nodeItem;
        nameIndices[node.name] = index.toString();
    });
    const getGraphConnectionItem = (startNode, connectionItem) => {
        return { start: nameIndices[startNode], end: nameIndices[connectionItem.node] };
    };
    Object.keys((_d = workflow.connections) !== null && _d !== void 0 ? _d : []).forEach((nodeName) => {
        var _a;
        const connections = (_a = workflow.connections) === null || _a === void 0 ? void 0 : _a[nodeName];
        if (!connections) {
            return;
        }
        Object.keys(connections).forEach((key) => {
            connections[key].forEach((element) => {
                (element !== null && element !== void 0 ? element : []).forEach((element2) => {
                    nodeGraph.node_connections.push(getGraphConnectionItem(nodeName, element2));
                });
            });
        });
    });
    return { nodeGraph, nameIndices, webhookNodeNames };
}
exports.generateNodesGraph = generateNodesGraph;
//# sourceMappingURL=TelemetryHelpers.js.map