"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeOperationError = void 0;
const node_error_1 = require("./abstract/node.error");
const application_error_1 = require("./application.error");
const Constants_1 = require("../Constants");
class NodeOperationError extends node_error_1.NodeError {
    constructor(node, error, options = {}) {
        var _a;
        if (error instanceof NodeOperationError) {
            return error;
        }
        let obfuscateErrorMessage = false;
        if (typeof error === 'string') {
            error = new Error(error);
        }
        else if (!(error instanceof application_error_1.ApplicationError)) {
            obfuscateErrorMessage = true;
        }
        super(node, error);
        if (error instanceof node_error_1.NodeError && ((_a = error === null || error === void 0 ? void 0 : error.messages) === null || _a === void 0 ? void 0 : _a.length)) {
            error.messages.forEach((message) => this.addToMessages(message));
        }
        if (obfuscateErrorMessage)
            this.message = Constants_1.OBFUSCATED_ERROR_MESSAGE;
        if (options.message)
            this.message = options.message;
        if (options.level)
            this.level = options.level;
        if (options.functionality)
            this.functionality = options.functionality;
        if (options.type)
            this.type = options.type;
        this.description = options.description;
        this.context.runIndex = options.runIndex;
        this.context.itemIndex = options.itemIndex;
        if (this.message === this.description) {
            this.description = undefined;
        }
        [this.message, this.messages] = this.setDescriptiveErrorMessage(this.message, this.messages, undefined, options.messageMapping);
    }
}
exports.NodeOperationError = NodeOperationError;
//# sourceMappingURL=node-operation.error.js.map