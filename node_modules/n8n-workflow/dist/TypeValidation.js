"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateFieldType = exports.tryToParseJwt = exports.tryToParseUrl = exports.getValueDescription = exports.tryToParseObject = exports.tryToParseArray = exports.tryToParseTime = exports.tryToParseDateTime = exports.tryToParseBoolean = exports.tryToParseAlphanumericString = exports.tryToParseString = exports.tryToParseNumber = void 0;
const luxon_1 = require("luxon");
const isObject_1 = __importDefault(require("lodash/isObject"));
const errors_1 = require("./errors");
const tryToParseNumber = (value) => {
    const isValidNumber = !isNaN(Number(value));
    if (!isValidNumber) {
        throw new errors_1.ApplicationError('Failed to parse value to number', { extra: { value } });
    }
    return Number(value);
};
exports.tryToParseNumber = tryToParseNumber;
const tryToParseString = (value) => {
    if (typeof value === 'object')
        return JSON.stringify(value);
    if (typeof value === 'undefined')
        return '';
    if (typeof value === 'string' ||
        typeof value === 'bigint' ||
        typeof value === 'boolean' ||
        typeof value === 'number') {
        return value.toString();
    }
    return String(value);
};
exports.tryToParseString = tryToParseString;
const tryToParseAlphanumericString = (value) => {
    const parsed = (0, exports.tryToParseString)(value);
    const regex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
    if (!regex.test(parsed)) {
        throw new errors_1.ApplicationError('Value is not a valid alphanumeric string', { extra: { value } });
    }
    return parsed;
};
exports.tryToParseAlphanumericString = tryToParseAlphanumericString;
const tryToParseBoolean = (value) => {
    if (typeof value === 'boolean') {
        return value;
    }
    if (typeof value === 'string' && ['true', 'false'].includes(value.toLowerCase())) {
        return value.toLowerCase() === 'true';
    }
    if (!(typeof value === 'string' && value.trim() === '')) {
        const num = Number(value);
        if (num === 0) {
            return false;
        }
        else if (num === 1) {
            return true;
        }
    }
    throw new errors_1.ApplicationError('Failed to parse value as boolean', {
        extra: { value },
    });
};
exports.tryToParseBoolean = tryToParseBoolean;
const tryToParseDateTime = (value) => {
    if (value instanceof luxon_1.DateTime && value.isValid) {
        return value;
    }
    if (value instanceof Date) {
        const fromJSDate = luxon_1.DateTime.fromJSDate(value);
        if (fromJSDate.isValid) {
            return fromJSDate;
        }
    }
    const dateString = String(value).trim();
    const isoDate = luxon_1.DateTime.fromISO(dateString, { setZone: true });
    if (isoDate.isValid) {
        return isoDate;
    }
    const httpDate = luxon_1.DateTime.fromHTTP(dateString, { setZone: true });
    if (httpDate.isValid) {
        return httpDate;
    }
    const rfc2822Date = luxon_1.DateTime.fromRFC2822(dateString, { setZone: true });
    if (rfc2822Date.isValid) {
        return rfc2822Date;
    }
    const sqlDate = luxon_1.DateTime.fromSQL(dateString, { setZone: true });
    if (sqlDate.isValid) {
        return sqlDate;
    }
    const parsedDateTime = luxon_1.DateTime.fromMillis(Date.parse(dateString));
    if (parsedDateTime.isValid) {
        return parsedDateTime;
    }
    throw new errors_1.ApplicationError('Value is not a valid date', { extra: { dateString } });
};
exports.tryToParseDateTime = tryToParseDateTime;
const tryToParseTime = (value) => {
    const isTimeInput = /^\d{2}:\d{2}(:\d{2})?((\-|\+)\d{4})?((\-|\+)\d{1,2}(:\d{2})?)?$/s.test(String(value));
    if (!isTimeInput) {
        throw new errors_1.ApplicationError('Value is not a valid time', { extra: { value } });
    }
    return String(value);
};
exports.tryToParseTime = tryToParseTime;
const tryToParseArray = (value) => {
    try {
        if (typeof value === 'object' && Array.isArray(value)) {
            return value;
        }
        let parsed;
        try {
            parsed = JSON.parse(String(value));
        }
        catch (e) {
            parsed = JSON.parse(String(value).replace(/'/g, '"'));
        }
        if (!Array.isArray(parsed)) {
            throw new errors_1.ApplicationError('Value is not a valid array', { extra: { value } });
        }
        return parsed;
    }
    catch (e) {
        throw new errors_1.ApplicationError('Value is not a valid array', { extra: { value } });
    }
};
exports.tryToParseArray = tryToParseArray;
const tryToParseObject = (value) => {
    if (value && typeof value === 'object' && !Array.isArray(value)) {
        return value;
    }
    try {
        const o = JSON.parse(String(value));
        if (typeof o !== 'object' || Array.isArray(o)) {
            throw new errors_1.ApplicationError('Value is not a valid object', { extra: { value } });
        }
        return o;
    }
    catch (e) {
        throw new errors_1.ApplicationError('Value is not a valid object', { extra: { value } });
    }
};
exports.tryToParseObject = tryToParseObject;
const getValueDescription = (value) => {
    if (typeof value === 'object') {
        if (value === null)
            return "'null'";
        if (Array.isArray(value))
            return 'array';
        return 'object';
    }
    return `'${String(value)}'`;
};
exports.getValueDescription = getValueDescription;
const tryToParseUrl = (value) => {
    if (typeof value === 'string' && !value.includes('://')) {
        value = `http://${value}`;
    }
    const urlPattern = /^(https?|ftp|file):\/\/\S+|www\.\S+/;
    if (!urlPattern.test(String(value))) {
        throw new errors_1.ApplicationError(`The value "${String(value)}" is not a valid url.`, {
            extra: { value },
        });
    }
    return String(value);
};
exports.tryToParseUrl = tryToParseUrl;
const tryToParseJwt = (value) => {
    const error = new errors_1.ApplicationError(`The value "${String(value)}" is not a valid JWT token.`, {
        extra: { value },
    });
    if (!value)
        throw error;
    const jwtPattern = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_.+/=]*$/;
    if (!jwtPattern.test(String(value)))
        throw error;
    return String(value);
};
exports.tryToParseJwt = tryToParseJwt;
function validateFieldType(fieldName, value, type, options = {}) {
    var _a, _b, _c;
    if (value === null || value === undefined)
        return { valid: true };
    const strict = (_a = options.strict) !== null && _a !== void 0 ? _a : false;
    const valueOptions = (_b = options.valueOptions) !== null && _b !== void 0 ? _b : [];
    const parseStrings = (_c = options.parseStrings) !== null && _c !== void 0 ? _c : false;
    const defaultErrorMessage = `'${fieldName}' expects a ${type} but we got ${(0, exports.getValueDescription)(value)}`;
    switch (type.toLowerCase()) {
        case 'string': {
            if (!parseStrings)
                return { valid: true, newValue: value };
            try {
                if (strict && typeof value !== 'string') {
                    return { valid: false, errorMessage: defaultErrorMessage };
                }
                return { valid: true, newValue: (0, exports.tryToParseString)(value) };
            }
            catch (e) {
                return { valid: false, errorMessage: defaultErrorMessage };
            }
        }
        case 'string-alphanumeric': {
            try {
                return { valid: true, newValue: (0, exports.tryToParseAlphanumericString)(value) };
            }
            catch (e) {
                return {
                    valid: false,
                    errorMessage: 'Value is not a valid alphanumeric string, only letters, numbers and underscore allowed',
                };
            }
        }
        case 'number': {
            try {
                if (strict && typeof value !== 'number') {
                    return { valid: false, errorMessage: defaultErrorMessage };
                }
                return { valid: true, newValue: (0, exports.tryToParseNumber)(value) };
            }
            catch (e) {
                return { valid: false, errorMessage: defaultErrorMessage };
            }
        }
        case 'boolean': {
            try {
                if (strict && typeof value !== 'boolean') {
                    return { valid: false, errorMessage: defaultErrorMessage };
                }
                return { valid: true, newValue: (0, exports.tryToParseBoolean)(value) };
            }
            catch (e) {
                return { valid: false, errorMessage: defaultErrorMessage };
            }
        }
        case 'datetime': {
            try {
                return { valid: true, newValue: (0, exports.tryToParseDateTime)(value) };
            }
            catch (e) {
                const luxonDocsURL = 'https://moment.github.io/luxon/api-docs/index.html#datetimefromformat';
                const errorMessage = `${defaultErrorMessage} <br/><br/> Consider using <a href="${luxonDocsURL}" target="_blank"><code>DateTime.fromFormat</code></a> to work with custom date formats.`;
                return { valid: false, errorMessage };
            }
        }
        case 'time': {
            try {
                return { valid: true, newValue: (0, exports.tryToParseTime)(value) };
            }
            catch (e) {
                return {
                    valid: false,
                    errorMessage: `'${fieldName}' expects time (hh:mm:(:ss)) but we got ${(0, exports.getValueDescription)(value)}.`,
                };
            }
        }
        case 'object': {
            try {
                if (strict && !(0, isObject_1.default)(value)) {
                    return { valid: false, errorMessage: defaultErrorMessage };
                }
                return { valid: true, newValue: (0, exports.tryToParseObject)(value) };
            }
            catch (e) {
                return { valid: false, errorMessage: defaultErrorMessage };
            }
        }
        case 'array': {
            if (strict && !Array.isArray(value)) {
                return { valid: false, errorMessage: defaultErrorMessage };
            }
            try {
                return { valid: true, newValue: (0, exports.tryToParseArray)(value) };
            }
            catch (e) {
                return { valid: false, errorMessage: defaultErrorMessage };
            }
        }
        case 'options': {
            const validOptions = valueOptions.map((option) => option.value).join(', ');
            const isValidOption = valueOptions.some((option) => option.value === value);
            if (!isValidOption) {
                return {
                    valid: false,
                    errorMessage: `'${fieldName}' expects one of the following values: [${validOptions}] but we got ${(0, exports.getValueDescription)(value)}`,
                };
            }
            return { valid: true, newValue: value };
        }
        case 'url': {
            try {
                return { valid: true, newValue: (0, exports.tryToParseUrl)(value) };
            }
            catch (e) {
                return { valid: false, errorMessage: defaultErrorMessage };
            }
        }
        case 'jwt': {
            try {
                return { valid: true, newValue: (0, exports.tryToParseJwt)(value) };
            }
            catch (e) {
                return {
                    valid: false,
                    errorMessage: 'Value is not a valid JWT token',
                };
            }
        }
        default: {
            return { valid: true, newValue: value };
        }
    }
}
exports.validateFieldType = validateFieldType;
//# sourceMappingURL=TypeValidation.js.map