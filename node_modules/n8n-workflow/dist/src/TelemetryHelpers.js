"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateNodesGraph = exports.getNodeTypeForName = void 0;
function getNodeTypeForName(workflow, nodeName) {
    return workflow.nodes.find((node) => node.name === nodeName);
}
exports.getNodeTypeForName = getNodeTypeForName;
function generateNodesGraph(workflow) {
    const nodesGraph = {
        node_types: [],
        node_connections: [],
        nodes: {},
    };
    const nodeNameAndIndex = {};
    workflow.nodes.forEach((node, index) => {
        nodesGraph.node_types.push(node.type);
        const nodeItem = {
            type: node.type,
        };
        if (node.type === 'n8n-nodes-base.httpRequest') {
            try {
                nodeItem.domain = new URL(node.parameters.url).hostname;
            }
            catch (e) {
                nodeItem.domain = node.parameters.url;
            }
        }
        else {
            Object.keys(node.parameters).forEach((parameterName) => {
                if (parameterName === 'operation' || parameterName === 'resource') {
                    nodeItem[parameterName] = node.parameters[parameterName];
                }
            });
        }
        nodesGraph.nodes[`${index}`] = nodeItem;
        nodeNameAndIndex[node.name] = index.toString();
    });
    const getGraphConnectionItem = (startNode, connectionItem) => {
        return { start: nodeNameAndIndex[startNode], end: nodeNameAndIndex[connectionItem.node] };
    };
    Object.keys(workflow.connections).forEach((nodeName) => {
        const connections = workflow.connections[nodeName];
        connections.main.forEach((element) => {
            element.forEach((element2) => {
                nodesGraph.node_connections.push(getGraphConnectionItem(nodeName, element2));
            });
        });
    });
    return { nodeGraph: nodesGraph, nameIndices: nodeNameAndIndex };
}
exports.generateNodesGraph = generateNodesGraph;
//# sourceMappingURL=TelemetryHelpers.js.map