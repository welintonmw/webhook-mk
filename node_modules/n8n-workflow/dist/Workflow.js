"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Workflow = void 0;
const Interfaces_1 = require("./Interfaces");
const NodeHelpers = __importStar(require("./NodeHelpers"));
const ObservableObject = __importStar(require("./ObservableObject"));
const RoutingNode_1 = require("./RoutingNode");
const Expression_1 = require("./Expression");
const Constants_1 = require("./Constants");
const application_error_1 = require("./errors/application.error");
function dedupe(arr) {
    return [...new Set(arr)];
}
class Workflow {
    constructor(parameters) {
        this.nodes = {};
        this.id = parameters.id;
        this.name = parameters.name;
        this.nodeTypes = parameters.nodeTypes;
        this.pinData = parameters.pinData;
        let nodeType;
        for (const node of parameters.nodes) {
            this.nodes[node.name] = node;
            nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
            if (nodeType === undefined) {
                continue;
            }
            const nodeParameters = NodeHelpers.getNodeParameters(nodeType.description.properties, node.parameters, true, false, node);
            node.parameters = nodeParameters !== null ? nodeParameters : {};
        }
        this.connectionsBySourceNode = parameters.connections;
        this.connectionsByDestinationNode = this.__getConnectionsByDestination(parameters.connections);
        this.active = parameters.active || false;
        this.staticData = ObservableObject.create(parameters.staticData || {}, undefined, {
            ignoreEmptyOnFirstChild: true,
        });
        this.settings = parameters.settings || {};
        this.expression = new Expression_1.Expression(this);
    }
    __getConnectionsByDestination(connections) {
        const returnConnection = {};
        let connectionInfo;
        let maxIndex;
        for (const sourceNode in connections) {
            if (!connections.hasOwnProperty(sourceNode)) {
                continue;
            }
            for (const type of Object.keys(connections[sourceNode])) {
                if (!connections[sourceNode].hasOwnProperty(type)) {
                    continue;
                }
                for (const inputIndex in connections[sourceNode][type]) {
                    if (!connections[sourceNode][type].hasOwnProperty(inputIndex)) {
                        continue;
                    }
                    for (connectionInfo of connections[sourceNode][type][inputIndex]) {
                        if (!returnConnection.hasOwnProperty(connectionInfo.node)) {
                            returnConnection[connectionInfo.node] = {};
                        }
                        if (!returnConnection[connectionInfo.node].hasOwnProperty(connectionInfo.type)) {
                            returnConnection[connectionInfo.node][connectionInfo.type] = [];
                        }
                        maxIndex = returnConnection[connectionInfo.node][connectionInfo.type].length - 1;
                        for (let j = maxIndex; j < connectionInfo.index; j++) {
                            returnConnection[connectionInfo.node][connectionInfo.type].push([]);
                        }
                        returnConnection[connectionInfo.node][connectionInfo.type][connectionInfo.index].push({
                            node: sourceNode,
                            type,
                            index: parseInt(inputIndex, 10),
                        });
                    }
                }
            }
        }
        return returnConnection;
    }
    checkIfWorkflowCanBeActivated(ignoreNodeTypes) {
        let node;
        let nodeType;
        for (const nodeName of Object.keys(this.nodes)) {
            node = this.nodes[nodeName];
            if (node.disabled === true) {
                continue;
            }
            if (ignoreNodeTypes !== undefined && ignoreNodeTypes.includes(node.type)) {
                continue;
            }
            nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
            if (nodeType === undefined) {
                continue;
            }
            if (nodeType.poll !== undefined ||
                nodeType.trigger !== undefined ||
                nodeType.webhook !== undefined) {
                return true;
            }
        }
        return false;
    }
    checkReadyForExecution(inputData) {
        let node;
        let nodeType;
        let nodeIssues = null;
        const workflowIssues = {};
        let checkNodes = [];
        if (inputData.destinationNode) {
            checkNodes = this.getParentNodes(inputData.destinationNode);
            checkNodes.push(inputData.destinationNode);
        }
        else if (inputData.startNode) {
            checkNodes = this.getChildNodes(inputData.startNode);
            checkNodes.push(inputData.startNode);
        }
        for (const nodeName of checkNodes) {
            nodeIssues = null;
            node = this.nodes[nodeName];
            if (node.disabled === true) {
                continue;
            }
            nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
            if (nodeType === undefined) {
                nodeIssues = {
                    typeUnknown: true,
                };
            }
            else {
                nodeIssues = NodeHelpers.getNodeParametersIssues(nodeType.description.properties, node, inputData.pinDataNodeNames);
            }
            if (nodeIssues !== null) {
                workflowIssues[node.name] = nodeIssues;
            }
        }
        if (Object.keys(workflowIssues).length === 0) {
            return null;
        }
        return workflowIssues;
    }
    getStaticData(type, node) {
        var _a;
        let key;
        if (type === 'global') {
            key = 'global';
        }
        else if (type === 'node') {
            if (node === undefined) {
                throw new application_error_1.ApplicationError('The request data of context type "node" the node parameter has to be set!');
            }
            key = `node:${node.name}`;
        }
        else {
            throw new application_error_1.ApplicationError('Unknown context type. Only `global` and `node` are supported.', {
                extra: { contextType: type },
            });
        }
        if ((_a = this.testStaticData) === null || _a === void 0 ? void 0 : _a[key])
            return this.testStaticData[key];
        if (this.staticData[key] === undefined) {
            this.staticData[key] = ObservableObject.create({}, this.staticData);
        }
        return this.staticData[key];
    }
    setTestStaticData(testStaticData) {
        this.testStaticData = testStaticData;
    }
    getTriggerNodes() {
        return this.queryNodes((nodeType) => !!nodeType.trigger);
    }
    getPollNodes() {
        return this.queryNodes((nodeType) => !!nodeType.poll);
    }
    queryNodes(checkFunction) {
        const returnNodes = [];
        let node;
        let nodeType;
        for (const nodeName of Object.keys(this.nodes)) {
            node = this.nodes[nodeName];
            if (node.disabled === true) {
                continue;
            }
            nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
            if (nodeType !== undefined && checkFunction(nodeType)) {
                returnNodes.push(node);
            }
        }
        return returnNodes;
    }
    getNode(nodeName) {
        if (this.nodes.hasOwnProperty(nodeName)) {
            return this.nodes[nodeName];
        }
        return null;
    }
    getPinDataOfNode(nodeName) {
        return this.pinData ? this.pinData[nodeName] : undefined;
    }
    renameNodeInParameterValue(parameterValue, currentName, newName, { hasRenamableContent } = { hasRenamableContent: false }) {
        if (typeof parameterValue !== 'object') {
            if (typeof parameterValue === 'string' &&
                (parameterValue.charAt(0) === '=' || hasRenamableContent)) {
                if (parameterValue.includes(currentName)) {
                    const escapedOldName = backslashEscape(currentName);
                    const escapedNewName = dollarEscape(newName);
                    const setNewName = (expression, oldPattern) => expression.replace(new RegExp(oldPattern, 'g'), `$1${escapedNewName}$2`);
                    if (parameterValue.includes('$(')) {
                        const oldPattern = String.raw `(\$\(['"])${escapedOldName}(['"]\))`;
                        parameterValue = setNewName(parameterValue, oldPattern);
                    }
                    if (parameterValue.includes('$node[')) {
                        const oldPattern = String.raw `(\$node\[['"])${escapedOldName}(['"]\])`;
                        parameterValue = setNewName(parameterValue, oldPattern);
                    }
                    if (parameterValue.includes('$node.')) {
                        const oldPattern = String.raw `(\$node\.)${escapedOldName}(\.?)`;
                        parameterValue = setNewName(parameterValue, oldPattern);
                        if (hasDotNotationBannedChar(newName)) {
                            const regex = new RegExp(`.${backslashEscape(newName)}( |\\.)`, 'g');
                            parameterValue = parameterValue.replace(regex, `["${escapedNewName}"]$1`);
                        }
                    }
                    if (parameterValue.includes('$items(')) {
                        const oldPattern = String.raw `(\$items\(['"])${escapedOldName}(['"],|['"]\))`;
                        parameterValue = setNewName(parameterValue, oldPattern);
                    }
                }
            }
            return parameterValue;
        }
        if (Array.isArray(parameterValue)) {
            const returnArray = [];
            for (const currentValue of parameterValue) {
                returnArray.push(this.renameNodeInParameterValue(currentValue, currentName, newName));
            }
            return returnArray;
        }
        const returnData = {};
        for (const parameterName of Object.keys(parameterValue || {})) {
            returnData[parameterName] = this.renameNodeInParameterValue(parameterValue[parameterName], currentName, newName, { hasRenamableContent });
        }
        return returnData;
    }
    renameNode(currentName, newName) {
        if (this.nodes[currentName] !== undefined) {
            this.nodes[newName] = this.nodes[currentName];
            this.nodes[newName].name = newName;
            delete this.nodes[currentName];
        }
        for (const node of Object.values(this.nodes)) {
            node.parameters = this.renameNodeInParameterValue(node.parameters, currentName, newName);
            if (Constants_1.NODES_WITH_RENAMABLE_CONTENT.has(node.type)) {
                node.parameters.jsCode = this.renameNodeInParameterValue(node.parameters.jsCode, currentName, newName, { hasRenamableContent: true });
            }
        }
        if (this.connectionsBySourceNode.hasOwnProperty(currentName)) {
            this.connectionsBySourceNode[newName] = this.connectionsBySourceNode[currentName];
            delete this.connectionsBySourceNode[currentName];
        }
        let sourceNode;
        let type;
        let sourceIndex;
        let connectionIndex;
        let connectionData;
        for (sourceNode of Object.keys(this.connectionsBySourceNode)) {
            for (type of Object.keys(this.connectionsBySourceNode[sourceNode])) {
                for (sourceIndex of Object.keys(this.connectionsBySourceNode[sourceNode][type])) {
                    for (connectionIndex of Object.keys(this.connectionsBySourceNode[sourceNode][type][parseInt(sourceIndex, 10)])) {
                        connectionData =
                            this.connectionsBySourceNode[sourceNode][type][parseInt(sourceIndex, 10)][parseInt(connectionIndex, 10)];
                        if (connectionData.node === currentName) {
                            connectionData.node = newName;
                        }
                    }
                }
            }
        }
        this.connectionsByDestinationNode = this.__getConnectionsByDestination(this.connectionsBySourceNode);
    }
    getHighestNode(nodeName, type = 'main', nodeConnectionIndex, checkedNodes) {
        const currentHighest = [];
        if (this.nodes[nodeName].disabled === false) {
            currentHighest.push(nodeName);
        }
        if (!this.connectionsByDestinationNode.hasOwnProperty(nodeName)) {
            return currentHighest;
        }
        if (!this.connectionsByDestinationNode[nodeName].hasOwnProperty(type)) {
            return currentHighest;
        }
        checkedNodes = checkedNodes || [];
        if (checkedNodes.includes(nodeName)) {
            return currentHighest;
        }
        checkedNodes.push(nodeName);
        const returnNodes = [];
        let addNodes;
        let connectionsByIndex;
        for (let connectionIndex = 0; connectionIndex < this.connectionsByDestinationNode[nodeName][type].length; connectionIndex++) {
            if (nodeConnectionIndex !== undefined && nodeConnectionIndex !== connectionIndex) {
                continue;
            }
            connectionsByIndex = this.connectionsByDestinationNode[nodeName][type][connectionIndex];
            connectionsByIndex.forEach((connection) => {
                if (checkedNodes.includes(connection.node)) {
                    return;
                }
                addNodes = this.getHighestNode(connection.node, type, undefined, checkedNodes);
                if (addNodes.length === 0) {
                    if (this.nodes[connection.node].disabled !== true) {
                        addNodes = [connection.node];
                    }
                }
                addNodes.forEach((name) => {
                    if (returnNodes.indexOf(name) === -1) {
                        returnNodes.push(name);
                    }
                });
            });
        }
        return returnNodes;
    }
    getChildNodes(nodeName, type = 'main', depth = -1) {
        return this.getConnectedNodes(this.connectionsBySourceNode, nodeName, type, depth);
    }
    getParentNodes(nodeName, type = 'main', depth = -1) {
        return this.getConnectedNodes(this.connectionsByDestinationNode, nodeName, type, depth);
    }
    getConnectedNodes(connections, nodeName, connectionType = 'main', depth = -1, checkedNodesIncoming) {
        depth = depth === -1 ? -1 : depth;
        const newDepth = depth === -1 ? depth : depth - 1;
        if (depth === 0) {
            return [];
        }
        if (!connections.hasOwnProperty(nodeName)) {
            return [];
        }
        let types;
        if (connectionType === 'ALL') {
            types = Object.keys(connections[nodeName]);
        }
        else if (connectionType === 'ALL_NON_MAIN') {
            types = Object.keys(connections[nodeName]).filter((type) => type !== 'main');
        }
        else {
            types = [connectionType];
        }
        let addNodes;
        let nodeIndex;
        let i;
        let parentNodeName;
        const returnNodes = [];
        types.forEach((type) => {
            if (!connections[nodeName].hasOwnProperty(type)) {
                return;
            }
            const checkedNodes = checkedNodesIncoming ? [...checkedNodesIncoming] : [];
            if (checkedNodes.includes(nodeName)) {
                return;
            }
            checkedNodes.push(nodeName);
            connections[nodeName][type].forEach((connectionsByIndex) => {
                connectionsByIndex.forEach((connection) => {
                    if (checkedNodes.includes(connection.node)) {
                        return;
                    }
                    returnNodes.unshift(connection.node);
                    addNodes = this.getConnectedNodes(connections, connection.node, connectionType, newDepth, checkedNodes);
                    for (i = addNodes.length; i--; i > 0) {
                        parentNodeName = addNodes[i];
                        nodeIndex = returnNodes.indexOf(parentNodeName);
                        if (nodeIndex !== -1) {
                            returnNodes.splice(nodeIndex, 1);
                        }
                        returnNodes.unshift(parentNodeName);
                    }
                });
            });
        });
        return returnNodes;
    }
    getParentNodesByDepth(nodeName, maxDepth = -1) {
        return this.searchNodesBFS(this.connectionsByDestinationNode, nodeName, maxDepth);
    }
    searchNodesBFS(connections, sourceNode, maxDepth = -1) {
        const returnConns = [];
        const type = 'main';
        let queue = [];
        queue.push({
            name: sourceNode,
            depth: 0,
            indicies: [],
        });
        const visited = {};
        let depth = 0;
        while (queue.length > 0) {
            if (maxDepth !== -1 && depth > maxDepth) {
                break;
            }
            depth++;
            const toAdd = [...queue];
            queue = [];
            toAdd.forEach((curr) => {
                if (visited[curr.name]) {
                    visited[curr.name].indicies = dedupe(visited[curr.name].indicies.concat(curr.indicies));
                    return;
                }
                visited[curr.name] = curr;
                if (curr.name !== sourceNode) {
                    returnConns.push(curr);
                }
                if (!connections.hasOwnProperty(curr.name) ||
                    !connections[curr.name].hasOwnProperty(type)) {
                    return;
                }
                connections[curr.name][type].forEach((connectionsByIndex) => {
                    connectionsByIndex.forEach((connection) => {
                        queue.push({
                            name: connection.node,
                            indicies: [connection.index],
                            depth,
                        });
                    });
                });
            });
        }
        return returnConns;
    }
    getParentMainInputNode(node) {
        if (node) {
            const nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
            const outputs = NodeHelpers.getNodeOutputs(this, node, nodeType.description);
            if (!!outputs.find((output) => { var _a; return ((_a = output === null || output === void 0 ? void 0 : output.type) !== null && _a !== void 0 ? _a : output) !== "main"; })) {
                const nonMainNodesConnected = outputs === null || outputs === void 0 ? void 0 : outputs.reduce((acc, outputName) => {
                    var _a;
                    const parentNodes = this.getChildNodes(node.name, (_a = outputName === null || outputName === void 0 ? void 0 : outputName.type) !== null && _a !== void 0 ? _a : outputName);
                    if (parentNodes.length > 0) {
                        acc.push(...parentNodes);
                    }
                    return acc;
                }, []);
                if (nonMainNodesConnected.length) {
                    const returnNode = this.getNode(nonMainNodesConnected[0]);
                    if (returnNode === null) {
                        throw new application_error_1.ApplicationError(`Node "${nonMainNodesConnected[0]}" not found`);
                    }
                    return this.getParentMainInputNode(returnNode);
                }
            }
        }
        return node;
    }
    getNodeConnectionIndexes(nodeName, parentNodeName, type = 'main', depth = -1, checkedNodes) {
        const node = this.getNode(parentNodeName);
        if (node === null) {
            return undefined;
        }
        depth = depth === -1 ? -1 : depth;
        const newDepth = depth === -1 ? depth : depth - 1;
        if (depth === 0) {
            return undefined;
        }
        if (!this.connectionsByDestinationNode.hasOwnProperty(nodeName)) {
            return undefined;
        }
        if (!this.connectionsByDestinationNode[nodeName].hasOwnProperty(type)) {
            return undefined;
        }
        checkedNodes = checkedNodes || [];
        if (checkedNodes.includes(nodeName)) {
            return undefined;
        }
        checkedNodes.push(nodeName);
        let outputIndex;
        for (const connectionsByIndex of this.connectionsByDestinationNode[nodeName][type]) {
            for (let destinationIndex = 0; destinationIndex < connectionsByIndex.length; destinationIndex++) {
                const connection = connectionsByIndex[destinationIndex];
                if (parentNodeName === connection.node) {
                    return {
                        sourceIndex: connection.index,
                        destinationIndex,
                    };
                }
                if (checkedNodes.includes(connection.node)) {
                    continue;
                }
                outputIndex = this.getNodeConnectionIndexes(connection.node, parentNodeName, type, newDepth, checkedNodes);
                if (outputIndex !== undefined) {
                    return outputIndex;
                }
            }
        }
        return undefined;
    }
    __getStartNode(nodeNames) {
        let node;
        let nodeType;
        for (const nodeName of nodeNames) {
            node = this.nodes[nodeName];
            if (nodeNames.length === 1 && !node.disabled) {
                return node;
            }
            nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
            if (nodeType.description.name === Constants_1.MANUAL_CHAT_TRIGGER_LANGCHAIN_NODE_TYPE) {
                continue;
            }
            if (nodeType && (nodeType.trigger !== undefined || nodeType.poll !== undefined)) {
                if (node.disabled === true) {
                    continue;
                }
                return node;
            }
        }
        const sortedNodeNames = Object.values(this.nodes)
            .sort((a, b) => Constants_1.STARTING_NODE_TYPES.indexOf(a.type) - Constants_1.STARTING_NODE_TYPES.indexOf(b.type))
            .map((n) => n.name);
        for (const nodeName of sortedNodeNames) {
            node = this.nodes[nodeName];
            if (Constants_1.STARTING_NODE_TYPES.includes(node.type)) {
                if (node.disabled === true) {
                    continue;
                }
                return node;
            }
        }
        return undefined;
    }
    getStartNode(destinationNode) {
        if (destinationNode) {
            const nodeNames = this.getHighestNode(destinationNode);
            if (nodeNames.length === 0) {
                nodeNames.push(destinationNode);
            }
            const node = this.__getStartNode(nodeNames);
            if (node !== undefined) {
                return node;
            }
            return this.nodes[nodeNames[0]];
        }
        return this.__getStartNode(Object.keys(this.nodes));
    }
    async createWebhookIfNotExists(webhookData, nodeExecuteFunctions, mode, activation) {
        const webhookExists = await this.runWebhookMethod('checkExists', webhookData, nodeExecuteFunctions, mode, activation);
        if (!webhookExists) {
            await this.runWebhookMethod('create', webhookData, nodeExecuteFunctions, mode, activation);
        }
    }
    async deleteWebhook(webhookData, nodeExecuteFunctions, mode, activation) {
        await this.runWebhookMethod('delete', webhookData, nodeExecuteFunctions, mode, activation);
    }
    async runWebhookMethod(method, webhookData, nodeExecuteFunctions, mode, activation) {
        var _a, _b;
        const node = this.getNode(webhookData.node);
        if (!node)
            return;
        const nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
        const webhookFn = (_b = (_a = nodeType.webhookMethods) === null || _a === void 0 ? void 0 : _a[webhookData.webhookDescription.name]) === null || _b === void 0 ? void 0 : _b[method];
        if (webhookFn === undefined)
            return;
        const thisArgs = nodeExecuteFunctions.getExecuteHookFunctions(this, node, webhookData.workflowExecuteAdditionalData, mode, activation, webhookData);
        return await webhookFn.call(thisArgs);
    }
    async runTrigger(node, getTriggerFunctions, additionalData, mode, activation) {
        const triggerFunctions = getTriggerFunctions(this, node, additionalData, mode, activation);
        const nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
        if (nodeType === undefined) {
            throw new application_error_1.ApplicationError('Node with unknown node type', {
                extra: { nodeName: node.name },
                tags: { nodeType: node.type },
            });
        }
        if (!nodeType.trigger) {
            throw new application_error_1.ApplicationError('Node type does not have a trigger function defined', {
                extra: { nodeName: node.name },
                tags: { nodeType: node.type },
            });
        }
        if (mode === 'manual') {
            const triggerResponse = await nodeType.trigger.call(triggerFunctions);
            triggerResponse.manualTriggerResponse = new Promise((resolve, reject) => {
                triggerFunctions.emit = ((resolveEmit) => (data, responsePromise, donePromise) => {
                    var _a;
                    additionalData.hooks.hookFunctions.sendResponse = [
                        async (response) => {
                            if (responsePromise) {
                                responsePromise.resolve(response);
                            }
                        },
                    ];
                    if (donePromise) {
                        (_a = additionalData.hooks.hookFunctions.workflowExecuteAfter) === null || _a === void 0 ? void 0 : _a.unshift(async (runData) => {
                            return donePromise.resolve(runData);
                        });
                    }
                    resolveEmit(data);
                })(resolve);
                triggerFunctions.emitError = ((rejectEmit) => (error, responsePromise) => {
                    additionalData.hooks.hookFunctions.sendResponse = [
                        async () => {
                            if (responsePromise) {
                                responsePromise.reject(error);
                            }
                        },
                    ];
                    rejectEmit(error);
                })(reject);
            });
            return triggerResponse;
        }
        return await nodeType.trigger.call(triggerFunctions);
    }
    async runPoll(node, pollFunctions) {
        const nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
        if (nodeType === undefined) {
            throw new application_error_1.ApplicationError('Node with unknown node type', {
                extra: { nodeName: node.name },
                tags: { nodeType: node.type },
            });
        }
        if (!nodeType.poll) {
            throw new application_error_1.ApplicationError('Node type does not have a poll function defined', {
                extra: { nodeName: node.name },
                tags: { nodeType: node.type },
            });
        }
        return await nodeType.poll.call(pollFunctions);
    }
    async runWebhook(webhookData, node, additionalData, nodeExecuteFunctions, mode) {
        const nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
        if (nodeType === undefined) {
            throw new application_error_1.ApplicationError('Unknown node type of webhook node', {
                extra: { nodeName: node.name },
            });
        }
        else if (nodeType.webhook === undefined) {
            throw new application_error_1.ApplicationError('Node does not have any webhooks defined', {
                extra: { nodeName: node.name },
            });
        }
        const closeFunctions = [];
        const context = nodeExecuteFunctions.getExecuteWebhookFunctions(this, node, additionalData, mode, webhookData, closeFunctions);
        return nodeType instanceof Interfaces_1.Node
            ? await nodeType.webhook(context)
            : await nodeType.webhook.call(context);
    }
    async runNode(executionData, runExecutionData, runIndex, additionalData, nodeExecuteFunctions, mode, abortSignal) {
        var _a;
        const { node } = executionData;
        let inputData = executionData.data;
        if (node.disabled === true) {
            if (inputData.hasOwnProperty('main') && inputData.main.length > 0) {
                if (inputData.main[0] === null) {
                    return { data: undefined };
                }
                return { data: [inputData.main[0]] };
            }
            return { data: undefined };
        }
        const nodeType = this.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
        if (nodeType === undefined) {
            throw new application_error_1.ApplicationError('Node type is unknown so cannot run it', {
                tags: { nodeType: node.type },
            });
        }
        let connectionInputData = [];
        if (nodeType.execute || (!nodeType.poll && !nodeType.trigger && !nodeType.webhook)) {
            if (((_a = inputData.main) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                connectionInputData = inputData.main[0];
            }
            const forceInputNodeExecution = this.settings.executionOrder !== 'v1';
            if (!forceInputNodeExecution) {
                for (const mainData of inputData.main) {
                    if (mainData === null || mainData === void 0 ? void 0 : mainData.length) {
                        connectionInputData = mainData;
                        break;
                    }
                }
            }
            if (connectionInputData.length === 0) {
                return { data: undefined };
            }
        }
        if (runExecutionData.resultData.lastNodeExecuted === node.name &&
            runExecutionData.resultData.error !== undefined) {
            if (runExecutionData.resultData.error.name === 'NodeOperationError' ||
                runExecutionData.resultData.error.name === 'NodeApiError') {
                throw runExecutionData.resultData.error;
            }
            const error = new Error(runExecutionData.resultData.error.message);
            error.stack = runExecutionData.resultData.error.stack;
            throw error;
        }
        if (node.executeOnce === true) {
            const newInputData = {};
            for (const inputName of Object.keys(inputData)) {
                newInputData[inputName] = inputData[inputName].map((input) => {
                    return input && input.slice(0, 1);
                });
            }
            inputData = newInputData;
        }
        if (nodeType.execute) {
            const closeFunctions = [];
            const context = nodeExecuteFunctions.getExecuteFunctions(this, runExecutionData, runIndex, connectionInputData, inputData, node, additionalData, executionData, mode, closeFunctions, abortSignal);
            const data = nodeType instanceof Interfaces_1.Node
                ? await nodeType.execute(context)
                : await nodeType.execute.call(context);
            const closeFunctionsResults = await Promise.allSettled(closeFunctions.map(async (fn) => await fn()));
            const closingErrors = closeFunctionsResults
                .filter((result) => result.status === 'rejected')
                .map((result) => result.reason);
            if (closingErrors.length > 0) {
                if (closingErrors[0] instanceof Error)
                    throw closingErrors[0];
                throw new application_error_1.ApplicationError("Error on execution node's close function(s)", {
                    extra: { nodeName: node.name },
                    tags: { nodeType: node.type },
                    cause: closingErrors,
                });
            }
            return { data };
        }
        else if (nodeType.poll) {
            if (mode === 'manual') {
                const thisArgs = nodeExecuteFunctions.getExecutePollFunctions(this, node, additionalData, mode, 'manual');
                return { data: await nodeType.poll.call(thisArgs) };
            }
            return { data: inputData.main };
        }
        else if (nodeType.trigger) {
            if (mode === 'manual') {
                const triggerResponse = await this.runTrigger(node, nodeExecuteFunctions.getExecuteTriggerFunctions, additionalData, mode, 'manual');
                if (triggerResponse === undefined) {
                    return { data: null };
                }
                if (triggerResponse.manualTriggerFunction !== undefined) {
                    await triggerResponse.manualTriggerFunction();
                }
                const response = await triggerResponse.manualTriggerResponse;
                let closeFunction;
                if (triggerResponse.closeFunction) {
                    closeFunction = triggerResponse.closeFunction;
                }
                if (response.length === 0) {
                    return { data: null, closeFunction };
                }
                return { data: response, closeFunction };
            }
            return { data: inputData.main };
        }
        else if (nodeType.webhook) {
            return { data: inputData.main };
        }
        else {
            const routingNode = new RoutingNode_1.RoutingNode(this, node, connectionInputData, runExecutionData !== null && runExecutionData !== void 0 ? runExecutionData : null, additionalData, mode);
            return {
                data: await routingNode.runNode(inputData, runIndex, nodeType, executionData, nodeExecuteFunctions, undefined, abortSignal),
            };
        }
    }
}
exports.Workflow = Workflow;
function hasDotNotationBannedChar(nodeName) {
    const DOT_NOTATION_BANNED_CHARS = /^(\d)|[\\ `!@#$%^&*()_+\-=[\]{};':"\\|,.<>?~]/g;
    return DOT_NOTATION_BANNED_CHARS.test(nodeName);
}
function backslashEscape(nodeName) {
    const BACKSLASH_ESCAPABLE_CHARS = /[.*+?^${}()|[\]\\]/g;
    return nodeName.replace(BACKSLASH_ESCAPABLE_CHARS, (char) => `\\${char}`);
}
function dollarEscape(nodeName) {
    return nodeName.replace(new RegExp('\\$', 'g'), '$$$$');
}
//# sourceMappingURL=Workflow.js.map