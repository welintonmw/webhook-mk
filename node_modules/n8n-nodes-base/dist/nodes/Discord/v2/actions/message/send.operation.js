"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.description = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const utilities_1 = require("../../../../../utils/utilities");
const transport_1 = require("../../transport");
const common_description_1 = require("../common.description");
const utils_1 = require("../../helpers/utils");
const properties = [
    {
        displayName: 'Send To',
        name: 'sendTo',
        type: 'options',
        options: [
            {
                name: 'User',
                value: 'user',
            },
            {
                name: 'Channel',
                value: 'channel',
            },
        ],
        default: 'channel',
        description: 'Send message to a channel or DM to a user',
    },
    {
        ...common_description_1.userRLC,
        displayOptions: {
            show: {
                sendTo: ['user'],
            },
        },
    },
    {
        ...common_description_1.textChannelRLC,
        displayOptions: {
            show: {
                sendTo: ['channel'],
            },
        },
    },
    {
        displayName: 'Message',
        name: 'content',
        type: 'string',
        default: '',
        description: 'The content of the message (up to 2000 characters)',
        placeholder: 'e.g. My message',
        typeOptions: {
            rows: 2,
        },
    },
    {
        displayName: 'Options',
        name: 'options',
        type: 'collection',
        placeholder: 'Add Option',
        default: {},
        options: [
            {
                displayName: 'Flags',
                name: 'flags',
                type: 'multiOptions',
                default: [],
                description: 'Message flags. <a href="https://discord.com/developers/docs/resources/channel#message-object-message-flags" target="_blank">More info</a>.‚Äù.',
                options: [
                    {
                        name: 'Suppress Embeds',
                        value: 'SUPPRESS_EMBEDS',
                    },
                    {
                        name: 'Suppress Notifications',
                        value: 'SUPPRESS_NOTIFICATIONS',
                    },
                ],
            },
            {
                displayName: 'Message to Reply to',
                name: 'message_reference',
                type: 'string',
                default: '',
                description: 'Fill this to make your message a reply. Add the message ID.',
                placeholder: 'e.g. 1059467601836773386',
            },
            {
                displayName: 'Text-to-Speech (TTS)',
                name: 'tts',
                type: 'boolean',
                default: false,
                description: 'Whether to have a bot reading the message directly in the channel',
            },
        ],
    },
    common_description_1.embedsFixedCollection,
    common_description_1.filesFixedCollection,
];
const displayOptions = {
    show: {
        resource: ['message'],
        operation: ['send'],
    },
    hide: {
        authentication: ['webhook'],
    },
};
exports.description = (0, utilities_1.updateDisplayOptions)(displayOptions, properties);
async function execute(guildId, userGuilds) {
    var _a, _b;
    const returnData = [];
    const items = this.getInputData();
    const isOAuth2 = this.getNodeParameter('authentication', 0) === 'oAuth2';
    for (let i = 0; i < items.length; i++) {
        const content = this.getNodeParameter('content', i);
        const options = (0, utils_1.prepareOptions)(this.getNodeParameter('options', i, {}), guildId);
        const embeds = (_a = this.getNodeParameter('embeds', i, undefined)) === null || _a === void 0 ? void 0 : _a.values;
        const files = (_b = this.getNodeParameter('files', i, undefined)) === null || _b === void 0 ? void 0 : _b.values;
        const body = {
            content,
            ...options,
        };
        if (embeds) {
            body.embeds = utils_1.prepareEmbeds.call(this, embeds);
        }
        try {
            const sendTo = this.getNodeParameter('sendTo', i);
            let channelId = '';
            if (sendTo === 'user') {
                const userId = this.getNodeParameter('userId', i, undefined, {
                    extractValue: true,
                });
                if (isOAuth2) {
                    try {
                        await transport_1.discordApiRequest.call(this, 'GET', `/guilds/${guildId}/members/${userId}`);
                    }
                    catch (error) {
                        if (error instanceof n8n_workflow_1.NodeApiError && error.httpCode === '404') {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), `User with the id ${userId} is not a member of the selected guild`, {
                                itemIndex: i,
                            });
                        }
                        throw new n8n_workflow_1.NodeOperationError(this.getNode(), error, {
                            itemIndex: i,
                        });
                    }
                }
                channelId = (await transport_1.discordApiRequest.call(this, 'POST', '/users/@me/channels', {
                    recipient_id: userId,
                })).id;
                if (!channelId) {
                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Could not create a channel to send direct message to', { itemIndex: i });
                }
            }
            if (sendTo === 'channel') {
                channelId = this.getNodeParameter('channelId', i, undefined, {
                    extractValue: true,
                });
            }
            if (isOAuth2 && sendTo !== 'user') {
                await utils_1.checkAccessToChannel.call(this, channelId, userGuilds, i);
            }
            if (!channelId) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Channel ID is required', { itemIndex: i });
            }
            let response = [];
            if (files === null || files === void 0 ? void 0 : files.length) {
                const multiPartBody = await utils_1.prepareMultiPartForm.call(this, items, files, body, i);
                response = await transport_1.discordApiMultiPartRequest.call(this, 'POST', `/channels/${channelId}/messages`, multiPartBody);
            }
            else {
                response = await transport_1.discordApiRequest.call(this, 'POST', `/channels/${channelId}/messages`, body);
            }
            const executionData = this.helpers.constructExecutionMetaData(this.helpers.returnJsonArray(response), { itemData: { item: i } });
            returnData.push(...executionData);
        }
        catch (error) {
            const err = utils_1.parseDiscordError.call(this, error, i);
            if (this.continueOnFail(error)) {
                returnData.push(...utils_1.prepareErrorData.call(this, err, i));
                continue;
            }
            throw err;
        }
    }
    return returnData;
}
exports.execute = execute;
//# sourceMappingURL=send.operation.js.map