"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.description = void 0;
const utilities_1 = require("../../../../../utils/utilities");
const utils_1 = require("../../helpers/utils");
const transport_1 = require("../../transport");
const common_description_1 = require("../common.description");
const properties = [
    common_description_1.channelRLC,
    {
        displayName: 'Name',
        name: 'name',
        type: 'string',
        default: '',
        description: "The new name of the channel. Fill this field only if you want to change the channel's name.",
        placeholder: 'e.g. new-channel-name',
    },
    {
        displayName: 'Options',
        name: 'options',
        type: 'collection',
        placeholder: 'Add Option',
        default: {},
        options: [
            {
                displayName: 'Age-Restricted (NSFW)',
                name: 'nsfw',
                type: 'boolean',
                default: false,
                description: 'Whether the content of the channel might be nsfw (not safe for work)',
            },
            {
                displayName: 'Bitrate',
                name: 'bitrate',
                type: 'number',
                default: 8000,
                typeOptions: {
                    minValue: 8000,
                    maxValue: 96000,
                },
                description: 'The bitrate (in bits) of the voice channel',
                hint: 'Only applicable to voice channels',
            },
            common_description_1.categoryRLC,
            {
                displayName: 'Position',
                name: 'position',
                type: 'number',
                default: 1,
            },
            {
                displayName: 'Rate Limit Per User',
                name: 'rate_limit_per_user',
                type: 'number',
                default: 0,
                description: 'Amount of seconds a user has to wait before sending another message',
            },
            {
                displayName: 'Topic',
                name: 'topic',
                type: 'string',
                default: '',
                typeOptions: {
                    rows: 2,
                },
                description: 'The channel topic description (0-1024 characters)',
                placeholder: 'e.g. This channel is aboutâ€¦',
            },
            {
                displayName: 'User Limit',
                name: 'user_limit',
                type: 'number',
                default: 0,
                typeOptions: {
                    minValue: 0,
                    maxValue: 99,
                },
                placeholder: 'e.g. 20',
                hint: 'Only applicable to voice channels',
                description: 'The limit for the number of members that can be in the channel (0 refers to no limit)',
            },
        ],
    },
];
const displayOptions = {
    show: {
        resource: ['channel'],
        operation: ['update'],
    },
    hide: {
        authentication: ['webhook'],
    },
};
exports.description = (0, utilities_1.updateDisplayOptions)(displayOptions, properties);
async function execute(_guildId, userGuilds) {
    const returnData = [];
    const items = this.getInputData();
    const getChannelId = await utils_1.setupChannelGetter.call(this, userGuilds);
    for (let i = 0; i < items.length; i++) {
        try {
            const channelId = await getChannelId(i);
            const name = this.getNodeParameter('name', i);
            const options = this.getNodeParameter('options', i);
            if (options.categoryId) {
                options.parent_id = options.categoryId.value;
                delete options.categoryId;
            }
            const body = {
                name,
                ...options,
            };
            const response = await transport_1.discordApiRequest.call(this, 'PATCH', `/channels/${channelId}`, body);
            const executionData = this.helpers.constructExecutionMetaData(this.helpers.returnJsonArray(response), { itemData: { item: i } });
            returnData.push(...executionData);
        }
        catch (error) {
            const err = utils_1.parseDiscordError.call(this, error, i);
            if (this.continueOnFail(error)) {
                returnData.push(...utils_1.prepareErrorData.call(this, err, i));
                continue;
            }
            throw err;
        }
    }
    return returnData;
}
exports.execute = execute;
//# sourceMappingURL=update.operation.js.map