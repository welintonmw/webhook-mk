"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupChannelGetter = exports.checkAccessToChannel = exports.checkAccessToGuild = exports.prepareMultiPartForm = exports.prepareEmbeds = exports.prepareOptions = exports.prepareErrorData = exports.parseDiscordError = exports.createSimplifyFunction = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const lodash_1 = require("lodash");
const form_data_1 = __importDefault(require("form-data"));
const mime_types_1 = require("mime-types");
const utilities_1 = require("../../../../utils/utilities");
const transport_1 = require("../transport");
const createSimplifyFunction = (includedFields) => (item) => {
    const result = {};
    for (const field of includedFields) {
        if (item[field] === undefined)
            continue;
        result[field] = item[field];
    }
    return result;
};
exports.createSimplifyFunction = createSimplifyFunction;
function parseDiscordError(error, itemIndex = 0) {
    var _a, _b, _c, _d, _e;
    let errorData = error.cause.error;
    const errorOptions = { itemIndex };
    if (!errorData && error.description) {
        try {
            const errorString = error.description.split(' - ')[1];
            if (errorString) {
                errorData = (0, n8n_workflow_1.jsonParse)(errorString);
            }
        }
        catch (err) { }
    }
    if (errorData === null || errorData === void 0 ? void 0 : errorData.message) {
        errorOptions.message = errorData.message;
    }
    if (((_b = (_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes('bad request')) && errorData) {
        if (errorData === null || errorData === void 0 ? void 0 : errorData.message) {
            errorOptions.message = errorData.message;
        }
        if ((_c = errorData === null || errorData === void 0 ? void 0 : errorData.errors) === null || _c === void 0 ? void 0 : _c.embeds) {
            const embedErrors = (_d = errorData.errors.embeds) === null || _d === void 0 ? void 0 : _d[0];
            const embedErrorsKeys = Object.keys(embedErrors).map((key) => (0, utilities_1.capitalize)(key));
            if (embedErrorsKeys.length) {
                const message = embedErrorsKeys.length === 1
                    ? `The parameter ${embedErrorsKeys[0]} is not properly formatted`
                    : `The parameters ${embedErrorsKeys.join(', ')} are not properly formatted`;
                errorOptions.message = message;
                errorOptions.description = 'Review the formatting or clear it';
            }
            return new n8n_workflow_1.NodeOperationError(this.getNode(), errorData.errors, errorOptions);
        }
        if ((_e = errorData === null || errorData === void 0 ? void 0 : errorData.errors) === null || _e === void 0 ? void 0 : _e.message_reference) {
            errorOptions.message = "The message to reply to ID can't be found";
            errorOptions.description =
                'Check the "Message to Reply to" parameter and remove it if you don\'t want to reply to an existing message';
            return new n8n_workflow_1.NodeOperationError(this.getNode(), errorData.errors, errorOptions);
        }
        if (errorOptions.message === 'Cannot send an empty message') {
            errorOptions.description =
                'Something has to be send to the channel whether it is a message, an embed or a file';
        }
    }
    return new n8n_workflow_1.NodeOperationError(this.getNode(), errorData || error, errorOptions);
}
exports.parseDiscordError = parseDiscordError;
function prepareErrorData(error, i) {
    let description = error.description;
    try {
        description = JSON.parse(error.description);
    }
    catch (err) { }
    return this.helpers.constructExecutionMetaData(this.helpers.returnJsonArray({ error: error.message, description }), { itemData: { item: i } });
}
exports.prepareErrorData = prepareErrorData;
function prepareOptions(options, guildId) {
    if (options.flags) {
        if (options.flags.length === 2) {
            options.flags = (1 << 2) + (1 << 12);
        }
        else if (options.flags.includes('SUPPRESS_EMBEDS')) {
            options.flags = 1 << 2;
        }
        else if (options.flags.includes('SUPPRESS_NOTIFICATIONS')) {
            options.flags = 1 << 12;
        }
    }
    if (options.message_reference) {
        options.message_reference = {
            message_id: options.message_reference,
            guild_id: guildId,
        };
    }
    return options;
}
exports.prepareOptions = prepareOptions;
function prepareEmbeds(embeds) {
    return embeds
        .map((embed) => {
        let embedReturnData = {};
        if (embed.inputMethod === 'json') {
            if (typeof embed.json === 'object') {
                embedReturnData = embed.json;
            }
            try {
                embedReturnData = (0, n8n_workflow_1.jsonParse)(embed.json);
            }
            catch (error) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Not a valid JSON', error);
            }
        }
        else {
            delete embed.inputMethod;
            for (const key of Object.keys(embed)) {
                if (embed[key] !== '') {
                    embedReturnData[key] = embed[key];
                }
            }
        }
        if (embedReturnData.author) {
            embedReturnData.author = {
                name: embedReturnData.author,
            };
        }
        if (embedReturnData.color && typeof embedReturnData.color === 'string') {
            embedReturnData.color = parseInt(embedReturnData.color.replace('#', ''), 16);
        }
        if (embedReturnData.video) {
            embedReturnData.video = {
                url: embedReturnData.video,
                width: 1270,
                height: 720,
            };
        }
        if (embedReturnData.thumbnail) {
            embedReturnData.thumbnail = {
                url: embedReturnData.thumbnail,
            };
        }
        if (embedReturnData.image) {
            embedReturnData.image = {
                url: embedReturnData.image,
            };
        }
        return embedReturnData;
    })
        .filter((embed) => !(0, lodash_1.isEmpty)(embed));
}
exports.prepareEmbeds = prepareEmbeds;
async function prepareMultiPartForm(items, files, jsonPayload, i) {
    var _a;
    const multiPartBody = new form_data_1.default();
    const attachments = [];
    const filesData = [];
    for (const [index, file] of files.entries()) {
        const binaryData = (_a = items[i].binary) === null || _a === void 0 ? void 0 : _a[file.inputFieldName];
        if (!binaryData) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), `Input item [${i}] does not contain binary data on property ${file.inputFieldName}`);
        }
        let filename = binaryData.fileName;
        if (!filename.includes('.')) {
            if (binaryData.fileExtension) {
                filename += `.${binaryData.fileExtension}`;
            }
            if (binaryData.mimeType) {
                filename += `.${(0, mime_types_1.extension)(binaryData.mimeType)}`;
            }
        }
        attachments.push({
            id: index,
            filename,
        });
        filesData.push({
            data: await this.helpers.getBinaryDataBuffer(i, file.inputFieldName),
            name: filename,
            mime: binaryData.mimeType,
        });
    }
    multiPartBody.append('payload_json', JSON.stringify({ ...jsonPayload, attachments }), {
        contentType: 'application/json',
    });
    for (const [index, binaryData] of filesData.entries()) {
        multiPartBody.append(`files[${index}]`, binaryData.data, {
            contentType: binaryData.name,
            filename: binaryData.mime,
        });
    }
    return multiPartBody;
}
exports.prepareMultiPartForm = prepareMultiPartForm;
function checkAccessToGuild(node, guildId, userGuilds, itemIndex = 0) {
    if (!userGuilds.some((guild) => guild.id === guildId)) {
        throw new n8n_workflow_1.NodeOperationError(node, `You do not have access to the guild with the id ${guildId}`, {
            itemIndex,
            level: 'warning',
        });
    }
}
exports.checkAccessToGuild = checkAccessToGuild;
async function checkAccessToChannel(channelId, userGuilds, itemIndex = 0) {
    let guildId = '';
    try {
        const channel = await transport_1.discordApiRequest.call(this, 'GET', `/channels/${channelId}`);
        guildId = channel.guild_id;
    }
    catch (error) { }
    if (!guildId) {
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), `Could not find server for channel with the id ${channelId}`, {
            itemIndex,
        });
    }
    checkAccessToGuild(this.getNode(), guildId, userGuilds, itemIndex);
}
exports.checkAccessToChannel = checkAccessToChannel;
async function setupChannelGetter(userGuilds) {
    const isOAuth2 = this.getNodeParameter('authentication', 0) === 'oAuth2';
    return async (i) => {
        const channelId = this.getNodeParameter('channelId', i, undefined, {
            extractValue: true,
        });
        if (isOAuth2)
            await checkAccessToChannel.call(this, channelId, userGuilds, i);
        return channelId;
    };
}
exports.setupChannelGetter = setupChannelGetter;
//# sourceMappingURL=utils.js.map