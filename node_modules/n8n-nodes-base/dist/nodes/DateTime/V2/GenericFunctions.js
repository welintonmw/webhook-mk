"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseDate = void 0;
const luxon_1 = require("luxon");
const moment_timezone_1 = __importDefault(require("moment-timezone"));
const n8n_workflow_1 = require("n8n-workflow");
function parseDate(date, options = {}) {
    let parsedDate;
    if (date instanceof luxon_1.DateTime) {
        parsedDate = date;
    }
    else {
        if (!Number.isNaN(Number(date)) && !options.fromFormat) {
            date = Number(date);
            if (!Number.isInteger(date)) {
                date = date * 1000;
            }
        }
        let timezone = options.timezone;
        if (Number.isInteger(date)) {
            const timestampLengthInMilliseconds1990 = 12;
            if (date.toString().length < timestampLengthInMilliseconds1990) {
                parsedDate = luxon_1.DateTime.fromSeconds(date);
            }
            else {
                parsedDate = luxon_1.DateTime.fromMillis(date);
            }
        }
        else {
            if (!timezone && date.includes('+')) {
                const offset = date.split('+')[1].slice(0, 2);
                timezone = `Etc/GMT-${offset * 1}`;
            }
            if (options.fromFormat) {
                parsedDate = luxon_1.DateTime.fromFormat(date, options.fromFormat);
            }
            else {
                parsedDate = luxon_1.DateTime.fromISO((0, moment_timezone_1.default)(date).toISOString());
            }
        }
        parsedDate = parsedDate.setZone(timezone || 'Etc/UTC');
        if (parsedDate.invalidReason === 'unparsable') {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Invalid date format');
        }
    }
    return parsedDate;
}
exports.parseDate = parseDate;
//# sourceMappingURL=GenericFunctions.js.map