"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.description = exports.properties = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const transport_1 = require("../../transport");
const descriptions_1 = require("../../descriptions");
const utilities_1 = require("../../../../../../utils/utilities");
exports.properties = [
    descriptions_1.messageRLC,
    {
        displayName: 'Input Data Field Name',
        name: 'binaryPropertyName',
        hint: 'The name of the input field containing the binary file data to be attached',
        type: 'string',
        required: true,
        default: 'data',
        placeholder: 'e.g. data',
    },
    {
        displayName: 'Options',
        name: 'options',
        type: 'collection',
        placeholder: 'Add Option',
        default: {},
        options: [
            {
                displayName: 'File Name',
                name: 'fileName',
                description: 'Filename of the attachment. If not set will the file-name of the binary property be used, if it exists.',
                type: 'string',
                default: '',
            },
        ],
    },
];
const displayOptions = {
    show: {
        resource: ['messageAttachment'],
        operation: ['add'],
    },
};
exports.description = (0, utilities_1.updateDisplayOptions)(displayOptions, exports.properties);
async function execute(index, items) {
    let responseData;
    const messageId = this.getNodeParameter('messageId', index, undefined, {
        extractValue: true,
    });
    const binaryPropertyName = this.getNodeParameter('binaryPropertyName', 0);
    const options = this.getNodeParameter('options', index);
    if (items[index].binary === undefined) {
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'No binary data exists on item!');
    }
    if (items[index].binary &&
        items[index].binary[binaryPropertyName] === undefined) {
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), `No binary data property "${binaryPropertyName}" does not exists on item!`, { itemIndex: index });
    }
    const binaryData = items[index].binary[binaryPropertyName];
    const dataBuffer = await this.helpers.getBinaryDataBuffer(index, binaryPropertyName);
    const fileName = options.fileName === undefined ? binaryData.fileName : options.fileName;
    if (!fileName) {
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'File name is not set. It has either to be set via "Additional Fields" or has to be set on the binary property!', { itemIndex: index });
    }
    if (dataBuffer.length > 3e6) {
        const chunkSize = 4e6;
        const body = {
            AttachmentItem: {
                attachmentType: 'file',
                name: fileName,
                size: dataBuffer.length,
            },
        };
        responseData = await transport_1.microsoftApiRequest.call(this, 'POST', `/messages/${messageId}/attachments/createUploadSession`, body);
        const uploadUrl = responseData.uploadUrl;
        if (uploadUrl === undefined) {
            throw new n8n_workflow_1.NodeApiError(this.getNode(), responseData, {
                message: 'Failed to get upload session',
            });
        }
        for (let bytesUploaded = 0; bytesUploaded < dataBuffer.length; bytesUploaded += chunkSize) {
            const nextChunk = Math.min(bytesUploaded + chunkSize, dataBuffer.length);
            const contentRange = `bytes ${bytesUploaded}-${nextChunk - 1}/${dataBuffer.length}`;
            const data = dataBuffer.subarray(bytesUploaded, nextChunk);
            responseData = await this.helpers.request(uploadUrl, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/octet-stream',
                    'Content-Length': data.length,
                    'Content-Range': contentRange,
                },
                body: data,
            });
        }
    }
    else {
        const body = {
            '@odata.type': '#microsoft.graph.fileAttachment',
            name: fileName,
            contentBytes: binaryData.data,
        };
        responseData = await transport_1.microsoftApiRequest.call(this, 'POST', `/messages/${messageId}/attachments`, body, {});
    }
    const executionData = this.helpers.constructExecutionMetaData(this.helpers.returnJsonArray({ success: true }), { itemData: { item: index } });
    return executionData;
}
exports.execute = execute;
//# sourceMappingURL=add.operation.js.map