"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.JavaScriptSandbox = exports.vmResolver = void 0;
const vm2_1 = require("@n8n/vm2");
const ValidationError_1 = require("./ValidationError");
const ExecutionError_1 = require("./ExecutionError");
const Sandbox_1 = require("./Sandbox");
const { NODE_FUNCTION_ALLOW_BUILTIN: builtIn, NODE_FUNCTION_ALLOW_EXTERNAL: external } = process.env;
exports.vmResolver = (0, vm2_1.makeResolverFromLegacyOptions)({
    external: external
        ? {
            modules: external.split(','),
            transitive: false,
        }
        : false,
    builtin: (_a = builtIn === null || builtIn === void 0 ? void 0 : builtIn.split(',')) !== null && _a !== void 0 ? _a : [],
});
class JavaScriptSandbox extends Sandbox_1.Sandbox {
    constructor(context, jsCode, itemIndex, helpers, options) {
        var _a;
        super({
            object: {
                singular: 'object',
                plural: 'objects',
            },
        }, itemIndex, helpers);
        this.jsCode = jsCode;
        this.vm = new vm2_1.NodeVM({
            console: 'redirect',
            sandbox: context,
            require: (_a = options === null || options === void 0 ? void 0 : options.resolver) !== null && _a !== void 0 ? _a : exports.vmResolver,
            wasm: false,
        });
        this.vm.on('console.log', (...args) => this.emit('output', ...args));
    }
    async runCode() {
        const script = `module.exports = async function() {${this.jsCode}\n}()`;
        try {
            const executionResult = await this.vm.run(script, __dirname);
            return executionResult;
        }
        catch (error) {
            throw new ExecutionError_1.ExecutionError(error);
        }
    }
    async runCodeAllItems(options) {
        const script = `module.exports = async function() {${this.jsCode}\n}()`;
        let executionResult;
        try {
            executionResult = await this.vm.run(script, __dirname);
        }
        catch (error) {
            if (error.message === 'items is not defined' && !/(let|const|var) items =/.test(script)) {
                const quoted = error.message.replace('items', '`items`');
                error.message = quoted + '. Did you mean `$input.all()`?';
            }
            throw new ExecutionError_1.ExecutionError(error);
        }
        if (executionResult === null)
            return [];
        if ((options === null || options === void 0 ? void 0 : options.multiOutput) === true) {
            if (!Array.isArray(executionResult) || executionResult.some((item) => !Array.isArray(item))) {
                throw new ValidationError_1.ValidationError({
                    message: "The code doesn't return an array of arrays",
                    description: 'Please return an array of arrays. One array for the different outputs and one for the different items that get returned.',
                    itemIndex: this.itemIndex,
                });
            }
            return executionResult.map((data) => {
                return this.validateRunCodeAllItems(data);
            });
        }
        return this.validateRunCodeAllItems(executionResult);
    }
    async runCodeEachItem() {
        var _a;
        const script = `module.exports = async function() {${this.jsCode}\n}()`;
        const match = this.jsCode.match(/\$input\.(?<disallowedMethod>first|last|all|itemMatching)/);
        if ((_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.disallowedMethod) {
            const { disallowedMethod } = match.groups;
            const lineNumber = this.jsCode.split('\n').findIndex((line) => {
                return line.includes(disallowedMethod) && !line.startsWith('//') && !line.startsWith('*');
            }) + 1;
            const disallowedMethodFound = lineNumber !== 0;
            if (disallowedMethodFound) {
                throw new ValidationError_1.ValidationError({
                    message: `Can't use .${disallowedMethod}() here`,
                    description: "This is only available in 'Run Once for All Items' mode",
                    itemIndex: this.itemIndex,
                    lineNumber,
                });
            }
        }
        let executionResult;
        try {
            executionResult = await this.vm.run(script, __dirname);
        }
        catch (error) {
            if (error.message === 'item is not defined' && !/(let|const|var) item =/.test(script)) {
                const quoted = error.message.replace('item', '`item`');
                error.message = quoted + '. Did you mean `$input.item.json`?';
            }
            throw new ExecutionError_1.ExecutionError(error, this.itemIndex);
        }
        if (executionResult === null)
            return;
        return this.validateRunCodeEachItem(executionResult);
    }
}
exports.JavaScriptSandbox = JavaScriptSandbox;
//# sourceMappingURL=JavaScriptSandbox.js.map