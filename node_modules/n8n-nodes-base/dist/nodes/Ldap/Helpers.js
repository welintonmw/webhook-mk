"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLdapClient = exports.resolveBinaryAttributes = exports.BINARY_AD_ATTRIBUTES = void 0;
const ldapts_1 = require("ldapts");
const n8n_workflow_1 = require("n8n-workflow");
exports.BINARY_AD_ATTRIBUTES = ['objectGUID', 'objectSid'];
const resolveEntryBinaryAttributes = (entry) => {
    Object.entries(entry)
        .filter(([k]) => exports.BINARY_AD_ATTRIBUTES.includes(k))
        .forEach(([k]) => {
        entry[k] = entry[k].toString('hex');
    });
    return entry;
};
const resolveBinaryAttributes = (entries) => {
    entries.forEach((entry) => resolveEntryBinaryAttributes(entry));
};
exports.resolveBinaryAttributes = resolveBinaryAttributes;
async function createLdapClient(credentials, nodeDebug, nodeType, nodeName) {
    const protocol = credentials.connectionSecurity === 'tls' ? 'ldaps' : 'ldap';
    const url = `${protocol}://${credentials.hostname}:${credentials.port}`;
    const ldapOptions = { url };
    const tlsOptions = {};
    if (credentials.connectionSecurity !== 'none') {
        tlsOptions.rejectUnauthorized = credentials.allowUnauthorizedCerts === false;
        if (credentials.caCertificate) {
            tlsOptions.ca = [credentials.caCertificate];
        }
        if (credentials.connectionSecurity !== 'startTls') {
            ldapOptions.tlsOptions = tlsOptions;
        }
    }
    if (credentials.timeout) {
        ldapOptions.timeout = credentials.timeout * 1000;
    }
    if (nodeDebug) {
        n8n_workflow_1.LoggerProxy.info(`[${nodeType} | ${nodeName}] - LDAP Options: ${JSON.stringify(ldapOptions, null, 2)}`);
    }
    const client = new ldapts_1.Client(ldapOptions);
    if (credentials.connectionSecurity === 'startTls') {
        await client.startTLS(tlsOptions);
    }
    return client;
}
exports.createLdapClient = createLdapClient;
//# sourceMappingURL=Helpers.js.map