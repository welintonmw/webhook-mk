"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.description = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const xlsx_1 = require("xlsx");
const csv_parse_1 = require("csv-parse");
const description_1 = require("../description");
exports.description = [
    description_1.binaryProperty,
    {
        displayName: 'File Format',
        name: 'fileFormat',
        type: 'options',
        options: [
            {
                name: 'Autodetect',
                value: 'autodetect',
            },
            {
                name: 'CSV',
                value: 'csv',
                description: 'Comma-separated values',
            },
            {
                name: 'HTML',
                value: 'html',
                description: 'HTML Table',
            },
            {
                name: 'ODS',
                value: 'ods',
                description: 'OpenDocument Spreadsheet',
            },
            {
                name: 'RTF',
                value: 'rtf',
                description: 'Rich Text Format',
            },
            {
                name: 'XLS',
                value: 'xls',
                description: 'Excel',
            },
            {
                name: 'XLSX',
                value: 'xlsx',
                description: 'Excel',
            },
        ],
        default: 'autodetect',
        description: 'The format of the binary data to read from',
        displayOptions: {
            show: {
                operation: ['fromFile'],
            },
        },
    },
    description_1.fromFileOptions,
];
async function execute(items, fileFormatProperty = 'fileFormat') {
    const returnData = [];
    let fileExtension;
    let fileFormat;
    for (let i = 0; i < items.length; i++) {
        try {
            const options = this.getNodeParameter('options', i, {});
            fileFormat = this.getNodeParameter(fileFormatProperty, i, '');
            const binaryPropertyName = this.getNodeParameter('binaryPropertyName', i);
            const binaryData = this.helpers.assertBinaryData(i, binaryPropertyName);
            fileExtension = binaryData.fileExtension;
            let rows = [];
            if (fileFormat === 'autodetect' &&
                (binaryData.mimeType === 'text/csv' ||
                    (binaryData.mimeType === 'text/plain' && binaryData.fileExtension === 'csv'))) {
                fileFormat = 'csv';
            }
            if (fileFormat === 'csv') {
                const maxRowCount = options.maxRowCount;
                const parser = (0, csv_parse_1.parse)({
                    delimiter: options.delimiter,
                    fromLine: options.fromLine,
                    encoding: options.encoding,
                    bom: options.enableBOM,
                    to: maxRowCount > -1 ? maxRowCount : undefined,
                    columns: options.headerRow !== false,
                    onRecord: (record) => {
                        if (!options.includeEmptyCells) {
                            record = Object.fromEntries(Object.entries(record).filter(([_key, value]) => value !== ''));
                        }
                        rows.push(record);
                    },
                });
                if (binaryData.id) {
                    const stream = await this.helpers.getBinaryStream(binaryData.id);
                    await new Promise(async (resolve, reject) => {
                        parser.on('error', reject);
                        parser.on('readable', () => {
                            stream.unpipe(parser);
                            stream.destroy();
                            resolve();
                        });
                        stream.pipe(parser);
                    });
                }
                else {
                    parser.write(binaryData.data, n8n_workflow_1.BINARY_ENCODING);
                    parser.end();
                }
            }
            else {
                let workbook;
                const xlsxOptions = { raw: options.rawData };
                if (options.readAsString)
                    xlsxOptions.type = 'string';
                if (binaryData.id) {
                    const binaryPath = this.helpers.getBinaryPath(binaryData.id);
                    workbook = (0, xlsx_1.readFile)(binaryPath, xlsxOptions);
                }
                else {
                    const binaryDataBuffer = Buffer.from(binaryData.data, n8n_workflow_1.BINARY_ENCODING);
                    workbook = (0, xlsx_1.read)(options.readAsString ? binaryDataBuffer.toString() : binaryDataBuffer, xlsxOptions);
                }
                if (workbook.SheetNames.length === 0) {
                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Spreadsheet does not have any sheets!', {
                        itemIndex: i,
                    });
                }
                let sheetName = workbook.SheetNames[0];
                if (options.sheetName) {
                    if (!workbook.SheetNames.includes(options.sheetName)) {
                        throw new n8n_workflow_1.NodeOperationError(this.getNode(), `Spreadsheet does not contain sheet called "${options.sheetName}"!`, { itemIndex: i });
                    }
                    sheetName = options.sheetName;
                }
                const sheetToJsonOptions = {};
                if (options.range) {
                    if (isNaN(options.range)) {
                        sheetToJsonOptions.range = options.range;
                    }
                    else {
                        sheetToJsonOptions.range = parseInt(options.range, 10);
                    }
                }
                if (options.includeEmptyCells) {
                    sheetToJsonOptions.defval = '';
                }
                if (options.headerRow === false) {
                    sheetToJsonOptions.header = 1;
                }
                rows = xlsx_1.utils.sheet_to_json(workbook.Sheets[sheetName], sheetToJsonOptions);
                if (rows.length === 0) {
                    continue;
                }
            }
            if (options.headerRow === false) {
                for (const rowData of rows) {
                    returnData.push({
                        json: {
                            row: rowData,
                        },
                        pairedItem: {
                            item: i,
                        },
                    });
                }
            }
            else {
                for (const rowData of rows) {
                    returnData.push({
                        json: rowData,
                        pairedItem: {
                            item: i,
                        },
                    });
                }
            }
        }
        catch (error) {
            let errorDescription = error.description;
            if (fileExtension && fileExtension !== fileFormat) {
                error.message = `The file selected in 'Input Binary Field' is not in ${fileFormat} format`;
                errorDescription = `Try to change the operation or select a ${fileFormat} file in 'Input Binary Field'`;
            }
            if (this.continueOnFail(error)) {
                returnData.push({
                    json: {
                        error: error.message,
                    },
                    pairedItem: {
                        item: i,
                    },
                });
                continue;
            }
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), error, {
                itemIndex: i,
                description: errorDescription,
            });
        }
    }
    return returnData;
}
exports.execute = execute;
//# sourceMappingURL=fromFile.operation.js.map