"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.description = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const GoogleSheets_utils_1 = require("../../helpers/GoogleSheets.utils");
const commonDescription_1 = require("./commonDescription");
exports.description = [
    {
        displayName: 'Data Mode',
        name: 'dataMode',
        type: 'options',
        options: [
            {
                name: 'Auto-Map Input Data to Columns',
                value: 'autoMapInputData',
                description: 'Use when node input properties match destination column names',
            },
            {
                name: 'Map Each Column Below',
                value: 'defineBelow',
                description: 'Set the value for each destination column',
            },
            {
                name: 'Nothing',
                value: 'nothing',
                description: 'Do not send anything',
            },
        ],
        displayOptions: {
            show: {
                resource: ['sheet'],
                operation: ['appendOrUpdate'],
                '@version': [3],
            },
            hide: {
                ...GoogleSheets_utils_1.untilSheetSelected,
            },
        },
        default: 'defineBelow',
        description: 'Whether to insert the input data this node receives in the new row',
    },
    {
        displayName: 'Column to match on',
        name: 'columnToMatchOn',
        type: 'options',
        description: 'Choose from the list, or specify an ID using an <a href="https://docs.n8n.io/code-examples/expressions/">expression</a>',
        typeOptions: {
            loadOptionsDependsOn: ['sheetName.value'],
            loadOptionsMethod: 'getSheetHeaderRowAndSkipEmpty',
        },
        default: '',
        hint: "Used to find the correct row to update. Doesn't get changed.",
        displayOptions: {
            show: {
                resource: ['sheet'],
                operation: ['appendOrUpdate'],
                '@version': [3],
            },
            hide: {
                ...GoogleSheets_utils_1.untilSheetSelected,
            },
        },
    },
    {
        displayName: 'Value of Column to Match On',
        name: 'valueToMatchOn',
        type: 'string',
        default: '',
        displayOptions: {
            show: {
                resource: ['sheet'],
                operation: ['appendOrUpdate'],
                dataMode: ['defineBelow'],
                '@version': [3],
            },
            hide: {
                ...GoogleSheets_utils_1.untilSheetSelected,
            },
        },
    },
    {
        displayName: 'Values to Send',
        name: 'fieldsUi',
        placeholder: 'Add Field',
        type: 'fixedCollection',
        typeOptions: {
            multipleValues: true,
        },
        displayOptions: {
            show: {
                resource: ['sheet'],
                operation: ['appendOrUpdate'],
                dataMode: ['defineBelow'],
                '@version': [3],
            },
            hide: {
                ...GoogleSheets_utils_1.untilSheetSelected,
            },
        },
        default: {},
        options: [
            {
                displayName: 'Field',
                name: 'values',
                values: [
                    {
                        displayName: 'Column',
                        name: 'column',
                        type: 'options',
                        description: 'Choose from the list, or specify an ID using an <a href="https://docs.n8n.io/code-examples/expressions/">expression</a>',
                        typeOptions: {
                            loadOptionsDependsOn: ['sheetName.value', 'columnToMatchOn'],
                            loadOptionsMethod: 'getSheetHeaderRowAndAddColumn',
                        },
                        default: '',
                    },
                    {
                        displayName: 'Column Name',
                        name: 'columnName',
                        type: 'string',
                        default: '',
                        displayOptions: {
                            show: {
                                column: ['newColumn'],
                            },
                        },
                    },
                    {
                        displayName: 'Value',
                        name: 'fieldValue',
                        type: 'string',
                        default: '',
                    },
                ],
            },
        ],
    },
    {
        displayName: 'Columns',
        name: 'columns',
        type: 'resourceMapper',
        noDataExpression: true,
        default: {
            mappingMode: 'defineBelow',
            value: null,
        },
        required: true,
        typeOptions: {
            loadOptionsDependsOn: ['sheetName.value'],
            resourceMapper: {
                resourceMapperMethod: 'getMappingColumns',
                mode: 'upsert',
                fieldWords: {
                    singular: 'column',
                    plural: 'columns',
                },
                addAllFields: true,
                multiKeyMatch: false,
            },
        },
        displayOptions: {
            show: {
                resource: ['sheet'],
                operation: ['appendOrUpdate'],
                '@version': [{ _cnd: { gte: 4 } }],
            },
            hide: {
                ...GoogleSheets_utils_1.untilSheetSelected,
            },
        },
    },
    {
        displayName: 'Options',
        name: 'options',
        type: 'collection',
        placeholder: 'Add Option',
        default: {},
        displayOptions: {
            show: {
                resource: ['sheet'],
                operation: ['appendOrUpdate'],
            },
            hide: {
                ...GoogleSheets_utils_1.untilSheetSelected,
            },
        },
        options: [
            commonDescription_1.cellFormat,
            commonDescription_1.locationDefine,
            commonDescription_1.handlingExtraData,
            {
                ...commonDescription_1.handlingExtraData,
                displayOptions: { show: { '/columns.mappingMode': ['autoMapInputData'] } },
            },
            {
                displayName: 'Use Append',
                name: 'useAppend',
                type: 'boolean',
                default: false,
                description: 'Whether to use append instead of update(default), this is more efficient but in some cases data might be misaligned',
            },
        ],
    },
];
async function execute(sheet, sheetName, sheetId) {
    var _a, _b, _c;
    const items = this.getInputData();
    const nodeVersion = this.getNode().typeVersion;
    const range = `${sheetName}!A:Z`;
    const valueInputMode = this.getNodeParameter('options.cellFormat', 0, (0, GoogleSheets_utils_1.cellFormatDefault)(nodeVersion));
    const options = this.getNodeParameter('options', 0, {});
    const valueRenderMode = (options.valueRenderMode || 'UNFORMATTED_VALUE');
    const locationDefineOption = (_a = options.locationDefine) === null || _a === void 0 ? void 0 : _a.values;
    let headerRow = 0;
    let firstDataRow = 1;
    if (locationDefineOption) {
        if (locationDefineOption.headerRow) {
            headerRow = parseInt(locationDefineOption.headerRow, 10) - 1;
        }
        if (locationDefineOption.firstDataRow) {
            firstDataRow = parseInt(locationDefineOption.firstDataRow, 10) - 1;
        }
    }
    const dataMode = nodeVersion < 4
        ? this.getNodeParameter('dataMode', 0)
        : this.getNodeParameter('columns.mappingMode', 0);
    let columnNames = [];
    const sheetData = (_b = (await sheet.getData(sheetName, 'FORMATTED_VALUE'))) !== null && _b !== void 0 ? _b : [];
    if (!sheetData[headerRow] && dataMode !== 'autoMapInputData') {
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), `Could not retrieve the column names from row ${headerRow + 1}`);
    }
    columnNames = (_c = sheetData[headerRow]) !== null && _c !== void 0 ? _c : [];
    if (nodeVersion >= 4.4) {
        const schema = this.getNodeParameter('columns.schema', 0);
        (0, GoogleSheets_utils_1.checkForSchemaChanges)(this.getNode(), columnNames, schema);
    }
    const newColumns = new Set();
    const columnsToMatchOn = nodeVersion < 4
        ? [this.getNodeParameter('columnToMatchOn', 0)]
        : this.getNodeParameter('columns.matchingColumns', 0);
    const keyIndex = columnNames.indexOf(columnsToMatchOn[0]);
    const columnValues = await sheet.getColumnValues(range, keyIndex, firstDataRow, valueRenderMode, sheetData);
    const updateData = [];
    const appendData = [];
    const errorOnUnexpectedColumn = (key, i) => {
        if (!columnNames.includes(key)) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Unexpected fields in node input', {
                itemIndex: i,
                description: `The input field '${key}' doesn't match any column in the Sheet. You can ignore this by changing the 'Handling extra data' field, which you can find under 'Options'.`,
            });
        }
    };
    const addNewColumn = (key) => {
        if (!columnNames.includes(key)) {
            newColumns.add(key);
        }
    };
    const mappedValues = [];
    for (let i = 0; i < items.length; i++) {
        if (dataMode === 'nothing')
            continue;
        const data = [];
        if (dataMode === 'autoMapInputData') {
            const handlingExtraDataOption = options.handlingExtraData || 'insertInNewColumn';
            if (handlingExtraDataOption === 'ignoreIt') {
                data.push(items[i].json);
            }
            if (handlingExtraDataOption === 'error') {
                Object.keys(items[i].json).forEach((key) => errorOnUnexpectedColumn(key, i));
                data.push(items[i].json);
            }
            if (handlingExtraDataOption === 'insertInNewColumn') {
                Object.keys(items[i].json).forEach(addNewColumn);
                data.push(items[i].json);
            }
        }
        else {
            const valueToMatchOn = nodeVersion < 4
                ? this.getNodeParameter('valueToMatchOn', i)
                : this.getNodeParameter(`columns.value[${columnsToMatchOn[0]}]`, i);
            if (nodeVersion < 4) {
                const valuesToSend = this.getNodeParameter('fieldsUi.values', i, []);
                if (!(valuesToSend === null || valuesToSend === void 0 ? void 0 : valuesToSend.length)) {
                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), "At least one value has to be added under 'Values to Send'");
                }
                const fields = valuesToSend.reduce((acc, entry) => {
                    if (entry.column === 'newColumn') {
                        const columnName = entry.columnName;
                        if (!columnNames.includes(columnName)) {
                            newColumns.add(columnName);
                        }
                        acc[columnName] = entry.fieldValue;
                    }
                    else {
                        acc[entry.column] = entry.fieldValue;
                    }
                    return acc;
                }, {});
                fields[columnsToMatchOn[0]] = valueToMatchOn;
                data.push(fields);
            }
            else {
                const mappingValues = this.getNodeParameter('columns.value', i);
                if (Object.keys(mappingValues).length === 0) {
                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), "At least one value has to be added under 'Values to Send'");
                }
                Object.keys(mappingValues).forEach((key) => {
                    if (mappingValues[key] === undefined || mappingValues[key] === null) {
                        mappingValues[key] = '';
                    }
                });
                data.push(mappingValues);
                mappedValues.push(mappingValues);
            }
        }
        if (newColumns.size) {
            const newColumnNames = columnNames.concat([...newColumns]);
            await sheet.updateRows(sheetName, [newColumnNames], options.cellFormat || (0, GoogleSheets_utils_1.cellFormatDefault)(nodeVersion), headerRow + 1);
            columnNames = newColumnNames;
            sheetData[headerRow] = newColumnNames;
            newColumns.clear();
        }
        const preparedData = await sheet.prepareDataForUpdateOrUpsert(data, columnsToMatchOn[0], range, headerRow, firstDataRow, valueRenderMode, true, [columnNames.concat([...newColumns])], columnValues);
        updateData.push(...preparedData.updateData);
        appendData.push(...preparedData.appendData);
    }
    if (updateData.length) {
        await sheet.batchUpdate(updateData, valueInputMode);
    }
    if (appendData.length) {
        const lastRow = sheetData.length + 1;
        if (options.useAppend) {
            await sheet.appendSheetData(appendData, range, headerRow + 1, valueInputMode, false, [columnNames.concat([...newColumns])], lastRow, options.useAppend);
        }
        else {
            await sheet.appendEmptyRowsOrColumns(sheetId, 1, 0);
            await sheet.appendSheetData(appendData, range, headerRow + 1, valueInputMode, false, [columnNames.concat([...newColumns])], lastRow);
        }
    }
    if (nodeVersion < 4 || dataMode === 'autoMapInputData') {
        return items.map((item, index) => {
            item.pairedItem = { item: index };
            return item;
        });
    }
    else {
        const returnData = [];
        for (const [index, entry] of mappedValues.entries()) {
            returnData.push({
                json: entry,
                pairedItem: { item: index },
            });
        }
        return returnData;
    }
}
exports.execute = execute;
//# sourceMappingURL=appendOrUpdate.operation.js.map