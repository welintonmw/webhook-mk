"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleDateFields = exports.getItemCopy = exports.validateAndResolveMongoCredentials = exports.buildMongoConnectionParams = void 0;
const n8n_workflow_1 = require("n8n-workflow");
function buildParameterizedConnString(credentials) {
    if (credentials.port) {
        return `mongodb://${credentials.user}:${credentials.password}@${credentials.host}:${credentials.port}`;
    }
    else {
        return `mongodb+srv://${credentials.user}:${credentials.password}@${credentials.host}`;
    }
}
function buildMongoConnectionParams(self, credentials) {
    const sanitizedDbName = credentials.database && credentials.database.trim().length > 0
        ? credentials.database.trim()
        : '';
    if (credentials.configurationType === 'connectionString') {
        if (credentials.connectionString &&
            credentials.connectionString.trim().length > 0) {
            return {
                connectionString: credentials.connectionString.trim(),
                database: sanitizedDbName,
            };
        }
        else {
            throw new n8n_workflow_1.NodeOperationError(self.getNode(), 'Cannot override credentials: valid MongoDB connection string not provided ');
        }
    }
    else {
        return {
            connectionString: buildParameterizedConnString(credentials),
            database: sanitizedDbName,
        };
    }
}
exports.buildMongoConnectionParams = buildMongoConnectionParams;
function validateAndResolveMongoCredentials(self, credentials) {
    if (credentials === undefined) {
        throw new n8n_workflow_1.NodeOperationError(self.getNode(), 'No credentials got returned!');
    }
    else {
        return buildMongoConnectionParams(self, credentials);
    }
}
exports.validateAndResolveMongoCredentials = validateAndResolveMongoCredentials;
function getItemCopy(items, properties) {
    let newItem;
    return items.map(item => {
        newItem = {};
        for (const property of properties) {
            if (item.json[property] === undefined) {
                newItem[property] = null;
            }
            else {
                newItem[property] = JSON.parse(JSON.stringify(item.json[property]));
            }
        }
        return newItem;
    });
}
exports.getItemCopy = getItemCopy;
function handleDateFields(insertItems, fields) {
    const dateFields = fields.split(',');
    for (let i = 0; i < insertItems.length; i++) {
        for (const key of Object.keys(insertItems[i])) {
            if (dateFields.includes(key)) {
                insertItems[i][key] = new Date(insertItems[i][key]);
            }
        }
    }
}
exports.handleDateFields = handleDateFields;
//# sourceMappingURL=mongo.node.utils.js.map