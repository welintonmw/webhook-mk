"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoDb = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const mongo_node_options_1 = require("./mongo.node.options");
const mongodb_1 = require("mongodb");
const mongo_node_utils_1 = require("./mongo.node.utils");
class MongoDb {
    constructor() {
        this.description = mongo_node_options_1.nodeDescription;
    }
    async execute() {
        const { database, connectionString } = mongo_node_utils_1.validateAndResolveMongoCredentials(this, await this.getCredentials('mongoDb'));
        const client = await mongodb_1.MongoClient.connect(connectionString, {
            useNewUrlParser: true,
            useUnifiedTopology: true,
        });
        const mdb = client.db(database);
        let returnItems = [];
        const items = this.getInputData();
        const operation = this.getNodeParameter('operation', 0);
        if (operation === 'delete') {
            try {
                const { deletedCount } = await mdb
                    .collection(this.getNodeParameter('collection', 0))
                    .deleteMany(JSON.parse(this.getNodeParameter('query', 0)));
                returnItems = this.helpers.returnJsonArray([{ deletedCount }]);
            }
            catch (error) {
                if (this.continueOnFail()) {
                    returnItems = this.helpers.returnJsonArray({ error: error.message });
                }
                else {
                    throw error;
                }
            }
        }
        else if (operation === 'find') {
            try {
                const queryParameter = JSON.parse(this.getNodeParameter('query', 0));
                if (queryParameter._id && typeof queryParameter._id === 'string') {
                    queryParameter._id = new mongodb_1.ObjectID(queryParameter._id);
                }
                let query = mdb
                    .collection(this.getNodeParameter('collection', 0))
                    .find(queryParameter);
                const options = this.getNodeParameter('options', 0);
                const limit = options.limit;
                const skip = options.skip;
                const sort = options.sort && JSON.parse(options.sort);
                if (skip > 0) {
                    query = query.skip(skip);
                }
                if (limit > 0) {
                    query = query.limit(limit);
                }
                if (sort && Object.keys(sort).length !== 0 && sort.constructor === Object) {
                    query = query.sort(sort);
                }
                const queryResult = await query.toArray();
                returnItems = this.helpers.returnJsonArray(queryResult);
            }
            catch (error) {
                if (this.continueOnFail()) {
                    returnItems = this.helpers.returnJsonArray({ error: error.message });
                }
                else {
                    throw error;
                }
            }
        }
        else if (operation === 'insert') {
            try {
                const fields = this.getNodeParameter('fields', 0)
                    .split(',')
                    .map(f => f.trim())
                    .filter(f => !!f);
                const options = this.getNodeParameter('options', 0);
                const insertItems = mongo_node_utils_1.getItemCopy(items, fields);
                if (options.dateFields) {
                    mongo_node_utils_1.handleDateFields(insertItems, options.dateFields);
                }
                const { insertedIds } = await mdb
                    .collection(this.getNodeParameter('collection', 0))
                    .insertMany(insertItems);
                for (const i of Object.keys(insertedIds)) {
                    returnItems.push({
                        json: Object.assign(Object.assign({}, insertItems[parseInt(i, 10)]), { id: insertedIds[parseInt(i, 10)] }),
                    });
                }
            }
            catch (error) {
                if (this.continueOnFail()) {
                    returnItems = this.helpers.returnJsonArray({ error: error.message });
                }
                else {
                    throw error;
                }
            }
        }
        else if (operation === 'update') {
            const fields = this.getNodeParameter('fields', 0)
                .split(',')
                .map(f => f.trim())
                .filter(f => !!f);
            const options = this.getNodeParameter('options', 0);
            let updateKey = this.getNodeParameter('updateKey', 0);
            updateKey = updateKey.trim();
            const updateOptions = this.getNodeParameter('upsert', 0)
                ? { upsert: true } : undefined;
            if (!fields.includes(updateKey)) {
                fields.push(updateKey);
            }
            const updateItems = mongo_node_utils_1.getItemCopy(items, fields);
            if (options.dateFields) {
                mongo_node_utils_1.handleDateFields(updateItems, options.dateFields);
            }
            for (const item of updateItems) {
                try {
                    if (item[updateKey] === undefined) {
                        continue;
                    }
                    const filter = {};
                    filter[updateKey] = item[updateKey];
                    if (updateKey === '_id') {
                        filter[updateKey] = new mongodb_1.ObjectID(filter[updateKey]);
                        delete item['_id'];
                    }
                    await mdb
                        .collection(this.getNodeParameter('collection', 0))
                        .updateOne(filter, { $set: item }, updateOptions);
                }
                catch (error) {
                    if (this.continueOnFail()) {
                        item.json = { error: error.message };
                        continue;
                    }
                    throw error;
                }
            }
            returnItems = this.helpers.returnJsonArray(updateItems);
        }
        else {
            if (this.continueOnFail()) {
                returnItems = this.helpers.returnJsonArray({ json: { error: `The operation "${operation}" is not supported!` } });
            }
            else {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), `The operation "${operation}" is not supported!`);
            }
        }
        client.close();
        return this.prepareOutputData(returnItems);
    }
}
exports.MongoDb = MongoDb;
//# sourceMappingURL=MongoDb.node.js.map