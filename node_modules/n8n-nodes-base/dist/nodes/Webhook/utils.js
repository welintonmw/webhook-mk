"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkResponseModeConfiguration = exports.isIpWhitelisted = exports.setupOutputConnection = exports.configuredOutputs = exports.getResponseData = exports.getResponseCode = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const getResponseCode = (parameters) => {
    var _a;
    if (parameters.responseCode) {
        return parameters.responseCode;
    }
    const responseCodeOptions = parameters.options;
    if ((_a = responseCodeOptions === null || responseCodeOptions === void 0 ? void 0 : responseCodeOptions.responseCode) === null || _a === void 0 ? void 0 : _a.values) {
        const { responseCode, customCode } = responseCodeOptions.responseCode.values;
        if (customCode) {
            return customCode;
        }
        return responseCode;
    }
    return 200;
};
exports.getResponseCode = getResponseCode;
const getResponseData = (parameters) => {
    const { responseData, responseMode, options } = parameters;
    if (responseData)
        return responseData;
    if (responseMode === 'onReceived') {
        const data = options === null || options === void 0 ? void 0 : options.responseData;
        if (data)
            return data;
    }
    if (options === null || options === void 0 ? void 0 : options.noResponseBody)
        return 'noData';
    return undefined;
};
exports.getResponseData = getResponseData;
const configuredOutputs = (parameters) => {
    const httpMethod = parameters.httpMethod;
    if (!Array.isArray(httpMethod))
        return [
            {
                type: `${"main"}`,
                displayName: httpMethod,
            },
        ];
    const outputs = httpMethod.map((method) => {
        return {
            type: `${"main"}`,
            displayName: method,
        };
    });
    return outputs;
};
exports.configuredOutputs = configuredOutputs;
const setupOutputConnection = (ctx, method, additionalData) => {
    const httpMethod = ctx.getNodeParameter('httpMethod', []);
    let webhookUrl = ctx.getNodeWebhookUrl('default');
    const executionMode = ctx.getMode() === 'manual' ? 'test' : 'production';
    if (executionMode === 'test') {
        webhookUrl = webhookUrl.replace('/webhook/', '/webhook-test/');
    }
    if (!Array.isArray(httpMethod)) {
        return (outputData) => {
            outputData.json.webhookUrl = webhookUrl;
            outputData.json.executionMode = executionMode;
            if (additionalData === null || additionalData === void 0 ? void 0 : additionalData.jwtPayload) {
                outputData.json.jwtPayload = additionalData.jwtPayload;
            }
            return [[outputData]];
        };
    }
    const outputIndex = httpMethod.indexOf(method.toUpperCase());
    const outputs = httpMethod.map(() => []);
    return (outputData) => {
        outputData.json.webhookUrl = webhookUrl;
        outputData.json.executionMode = executionMode;
        if (additionalData === null || additionalData === void 0 ? void 0 : additionalData.jwtPayload) {
            outputData.json.jwtPayload = additionalData.jwtPayload;
        }
        outputs[outputIndex] = [outputData];
        return outputs;
    };
};
exports.setupOutputConnection = setupOutputConnection;
const isIpWhitelisted = (whitelist, ips, ip) => {
    if (whitelist === undefined || whitelist === '') {
        return true;
    }
    if (!Array.isArray(whitelist)) {
        whitelist = whitelist.split(',').map((entry) => entry.trim());
    }
    for (const address of whitelist) {
        if (ip && ip.includes(address)) {
            return true;
        }
        if (ips.some((entry) => entry.includes(address))) {
            return true;
        }
    }
    return false;
};
exports.isIpWhitelisted = isIpWhitelisted;
const checkResponseModeConfiguration = (context) => {
    const responseMode = context.getNodeParameter('responseMode', 'onReceived');
    const connectedNodes = context.getChildNodes(context.getNode().name);
    const isRespondToWebhookConnected = connectedNodes.some((node) => node.type === 'n8n-nodes-base.respondToWebhook');
    if (!isRespondToWebhookConnected && responseMode === 'responseNode') {
        throw new n8n_workflow_1.NodeOperationError(context.getNode(), new Error('No Respond to Webhook node found in the workflow'), {
            description: 'Insert a Respond to Webhook node to your workflow to respond to the webhook or choose another option for the “Respond” parameter',
        });
    }
    if (isRespondToWebhookConnected && responseMode !== 'responseNode') {
        throw new n8n_workflow_1.NodeOperationError(context.getNode(), new Error('Webhook node not correctly configured'), {
            description: 'Set the “Respond” parameter to “Using Respond to Webhook Node” or remove the Respond to Webhook node',
        });
    }
};
exports.checkResponseModeConfiguration = checkResponseModeConfiguration;
//# sourceMappingURL=utils.js.map