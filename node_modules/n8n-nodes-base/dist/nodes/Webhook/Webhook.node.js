"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Webhook = void 0;
const promises_1 = require("stream/promises");
const fs_1 = require("fs");
const promises_2 = require("fs/promises");
const n8n_workflow_1 = require("n8n-workflow");
const uuid_1 = require("uuid");
const basic_auth_1 = __importDefault(require("basic-auth"));
const isbot_1 = __importDefault(require("isbot"));
const tmp_promise_1 = require("tmp-promise");
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const description_1 = require("./description");
const error_1 = require("./error");
const utils_1 = require("./utils");
const utilities_1 = require("../../utils/utilities");
class Webhook extends n8n_workflow_1.Node {
    constructor() {
        super(...arguments);
        this.authPropertyName = 'authentication';
        this.description = {
            displayName: 'Webhook',
            icon: { light: 'file:webhook.svg', dark: 'file:webhook.dark.svg' },
            name: 'webhook',
            group: ['trigger'],
            version: [1, 1.1, 2],
            description: 'Starts the workflow when a webhook is called',
            eventTriggerDescription: 'Waiting for you to call the Test URL',
            activationMessage: 'You can now make calls to your production webhook URL.',
            defaults: {
                name: 'Webhook',
            },
            supportsCORS: true,
            triggerPanel: {
                header: '',
                executionsHelp: {
                    inactive: 'Webhooks have two modes: test and production. <br /> <br /> <b>Use test mode while you build your workflow</b>. Click the \'listen\' button, then make a request to the test URL. The executions will show up in the editor.<br /> <br /> <b>Use production mode to run your workflow automatically</b>. <a data-key="activate">Activate</a> the workflow, then make requests to the production URL. These executions will show up in the executions list, but not in the editor.',
                    active: 'Webhooks have two modes: test and production. <br /> <br /> <b>Use test mode while you build your workflow</b>. Click the \'listen\' button, then make a request to the test URL. The executions will show up in the editor.<br /> <br /> <b>Use production mode to run your workflow automatically</b>. Since the workflow is activated, you can make requests to the production URL. These executions will show up in the <a data-key="executions">executions list</a>, but not in the editor.',
                },
                activationHint: "Once you've finished building your workflow, run it without having to click this button by using the production webhook URL.",
            },
            inputs: [],
            outputs: `={{(${utils_1.configuredOutputs})($parameter)}}`,
            credentials: (0, description_1.credentialsProperty)(this.authPropertyName),
            webhooks: [description_1.defaultWebhookDescription],
            properties: [
                {
                    displayName: 'Allow Multiple HTTP Methods',
                    name: 'multipleMethods',
                    type: 'boolean',
                    default: false,
                    isNodeSetting: true,
                    description: 'Whether to allow the webhook to listen for multiple HTTP methods',
                },
                {
                    ...description_1.httpMethodsProperty,
                    displayOptions: {
                        show: {
                            multipleMethods: [false],
                        },
                    },
                },
                {
                    displayName: 'HTTP Methods',
                    name: 'httpMethod',
                    type: 'multiOptions',
                    options: [
                        {
                            name: 'DELETE',
                            value: 'DELETE',
                        },
                        {
                            name: 'GET',
                            value: 'GET',
                        },
                        {
                            name: 'HEAD',
                            value: 'HEAD',
                        },
                        {
                            name: 'PATCH',
                            value: 'PATCH',
                        },
                        {
                            name: 'POST',
                            value: 'POST',
                        },
                        {
                            name: 'PUT',
                            value: 'PUT',
                        },
                    ],
                    default: ['GET', 'POST'],
                    description: 'The HTTP methods to listen to',
                    displayOptions: {
                        show: {
                            multipleMethods: [true],
                        },
                    },
                },
                {
                    displayName: 'Path',
                    name: 'path',
                    type: 'string',
                    default: '',
                    placeholder: 'webhook',
                    required: true,
                    description: "The path to listen to, dynamic values could be specified by using ':', e.g. 'your-path/:dynamic-value'. If dynamic values are set 'webhookId' would be prepended to path.",
                },
                (0, description_1.authenticationProperty)(this.authPropertyName),
                description_1.responseModeProperty,
                {
                    displayName: 'Insert a \'Respond to Webhook\' node to control when and how you respond. <a href="https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.respondtowebhook/" target="_blank">More details</a>',
                    name: 'webhookNotice',
                    type: 'notice',
                    displayOptions: {
                        show: {
                            responseMode: ['responseNode'],
                        },
                    },
                    default: '',
                },
                {
                    ...description_1.responseCodeProperty,
                    displayOptions: {
                        show: {
                            '@version': [1, 1.1],
                        },
                        hide: {
                            responseMode: ['responseNode'],
                        },
                    },
                },
                description_1.responseDataProperty,
                description_1.responseBinaryPropertyNameProperty,
                {
                    ...description_1.optionsProperty,
                    options: [...description_1.optionsProperty.options, description_1.responseCodeOption].sort((a, b) => {
                        const nameA = a.displayName.toUpperCase();
                        const nameB = b.displayName.toUpperCase();
                        if (nameA < nameB)
                            return -1;
                        if (nameA > nameB)
                            return 1;
                        return 0;
                    }),
                },
            ],
        };
    }
    async webhook(context) {
        var _a, _b;
        const { typeVersion: nodeVersion, type: nodeType } = context.getNode();
        if (nodeVersion >= 2 && nodeType === 'n8n-nodes-base.webhook') {
            (0, utils_1.checkResponseModeConfiguration)(context);
        }
        const options = context.getNodeParameter('options', {});
        const req = context.getRequestObject();
        const resp = context.getResponseObject();
        const requestMethod = context.getRequestObject().method;
        if (!(0, utils_1.isIpWhitelisted)(options.ipWhitelist, req.ips, req.ip)) {
            resp.writeHead(403);
            resp.end('IP is not whitelisted to access the webhook!');
            return { noWebhookResponse: true };
        }
        let validationData;
        try {
            if (options.ignoreBots && (0, isbot_1.default)(req.headers['user-agent']))
                throw new error_1.WebhookAuthorizationError(403);
            validationData = await this.validateAuth(context);
        }
        catch (error) {
            if (error instanceof error_1.WebhookAuthorizationError) {
                resp.writeHead(error.responseCode, { 'WWW-Authenticate': 'Basic realm="Webhook"' });
                resp.end(error.message);
                return { noWebhookResponse: true };
            }
            throw error;
        }
        const prepareOutput = (0, utils_1.setupOutputConnection)(context, requestMethod, {
            jwtPayload: validationData,
        });
        if (options.binaryData) {
            return await this.handleBinaryData(context, prepareOutput);
        }
        if (req.contentType === 'multipart/form-data') {
            return await this.handleFormData(context, prepareOutput);
        }
        if (nodeVersion > 1 && !req.body && !options.rawBody) {
            try {
                return await this.handleBinaryData(context, prepareOutput);
            }
            catch (error) { }
        }
        if (options.rawBody && !req.rawBody) {
            await req.readRawBody();
        }
        const response = {
            json: {
                headers: req.headers,
                params: req.params,
                query: req.query,
                body: req.body,
            },
            binary: options.rawBody
                ? {
                    data: {
                        data: ((_a = req.rawBody) !== null && _a !== void 0 ? _a : '').toString(n8n_workflow_1.BINARY_ENCODING),
                        mimeType: (_b = req.contentType) !== null && _b !== void 0 ? _b : 'application/json',
                    },
                }
                : undefined,
        };
        return {
            webhookResponse: options.responseData,
            workflowData: prepareOutput(response),
        };
    }
    async validateAuth(context) {
        const authentication = context.getNodeParameter(this.authPropertyName);
        if (authentication === 'none')
            return;
        const req = context.getRequestObject();
        const headers = context.getHeaderData();
        if (authentication === 'basicAuth') {
            let expectedAuth;
            try {
                expectedAuth = await context.getCredentials('httpBasicAuth');
            }
            catch { }
            if (expectedAuth === undefined || !expectedAuth.user || !expectedAuth.password) {
                throw new error_1.WebhookAuthorizationError(500, 'No authentication data defined on node!');
            }
            const providedAuth = (0, basic_auth_1.default)(req);
            if (!providedAuth)
                throw new error_1.WebhookAuthorizationError(401);
            if (providedAuth.name !== expectedAuth.user || providedAuth.pass !== expectedAuth.password) {
                throw new error_1.WebhookAuthorizationError(403);
            }
        }
        else if (authentication === 'headerAuth') {
            let expectedAuth;
            try {
                expectedAuth = await context.getCredentials('httpHeaderAuth');
            }
            catch { }
            if (expectedAuth === undefined || !expectedAuth.name || !expectedAuth.value) {
                throw new error_1.WebhookAuthorizationError(500, 'No authentication data defined on node!');
            }
            const headerName = expectedAuth.name.toLowerCase();
            const expectedValue = expectedAuth.value;
            if (!headers.hasOwnProperty(headerName) ||
                headers[headerName] !== expectedValue) {
                throw new error_1.WebhookAuthorizationError(403);
            }
        }
        else if (authentication === 'jwtAuth') {
            let expectedAuth;
            try {
                expectedAuth = (await context.getCredentials('jwtAuth'));
            }
            catch { }
            if (expectedAuth === undefined) {
                throw new error_1.WebhookAuthorizationError(500, 'No authentication data defined on node!');
            }
            const authHeader = req.headers.authorization;
            const token = authHeader && authHeader.split(' ')[1];
            if (!token) {
                throw new error_1.WebhookAuthorizationError(401, 'No token provided');
            }
            let secretOrPublicKey;
            if (expectedAuth.keyType === 'passphrase') {
                secretOrPublicKey = expectedAuth.secret;
            }
            else {
                secretOrPublicKey = (0, utilities_1.formatPrivateKey)(expectedAuth.publicKey, true);
            }
            try {
                return jsonwebtoken_1.default.verify(token, secretOrPublicKey, {
                    algorithms: [expectedAuth.algorithm],
                });
            }
            catch (error) {
                throw new error_1.WebhookAuthorizationError(403, error.message);
            }
        }
    }
    async handleFormData(context, prepareOutput) {
        var _a;
        const req = context.getRequestObject();
        const options = context.getNodeParameter('options', {});
        const { data, files } = req.body;
        const returnItem = {
            json: {
                headers: req.headers,
                params: req.params,
                query: req.query,
                body: data,
            },
        };
        if (files && Object.keys(files).length) {
            returnItem.binary = {};
        }
        let count = 0;
        for (const key of Object.keys(files)) {
            const processFiles = [];
            let multiFile = false;
            if (Array.isArray(files[key])) {
                processFiles.push(...files[key]);
                multiFile = true;
            }
            else {
                processFiles.push(files[key]);
            }
            let fileCount = 0;
            for (const file of processFiles) {
                let binaryPropertyName = key;
                if (binaryPropertyName.endsWith('[]')) {
                    binaryPropertyName = binaryPropertyName.slice(0, -2);
                }
                if (multiFile) {
                    binaryPropertyName += fileCount++;
                }
                if (options.binaryPropertyName) {
                    binaryPropertyName = `${options.binaryPropertyName}${count}`;
                }
                returnItem.binary[binaryPropertyName] = await context.nodeHelpers.copyBinaryFile(file.filepath, (_a = file.originalFilename) !== null && _a !== void 0 ? _a : file.newFilename, file.mimetype);
                count += 1;
            }
        }
        return { workflowData: prepareOutput(returnItem) };
    }
    async handleBinaryData(context, prepareOutput) {
        var _a, _b, _c, _d;
        const req = context.getRequestObject();
        const options = context.getNodeParameter('options', {});
        const binaryFile = await (0, tmp_promise_1.file)({ prefix: 'n8n-webhook-' });
        try {
            await (0, promises_1.pipeline)(req, (0, fs_1.createWriteStream)(binaryFile.path));
            const returnItem = {
                json: {
                    headers: req.headers,
                    params: req.params,
                    query: req.query,
                    body: {},
                },
            };
            const stats = await (0, promises_2.stat)(binaryFile.path);
            if (stats.size) {
                const binaryPropertyName = ((_a = options.binaryPropertyName) !== null && _a !== void 0 ? _a : 'data');
                const fileName = (_c = (_b = req.contentDisposition) === null || _b === void 0 ? void 0 : _b.filename) !== null && _c !== void 0 ? _c : (0, uuid_1.v4)();
                const binaryData = await context.nodeHelpers.copyBinaryFile(binaryFile.path, fileName, (_d = req.contentType) !== null && _d !== void 0 ? _d : 'application/octet-stream');
                returnItem.binary = { [binaryPropertyName]: binaryData };
            }
            return { workflowData: prepareOutput(returnItem) };
        }
        catch (error) {
            throw new n8n_workflow_1.NodeOperationError(context.getNode(), error);
        }
        finally {
            await binaryFile.cleanup();
        }
    }
}
exports.Webhook = Webhook;
//# sourceMappingURL=Webhook.node.js.map