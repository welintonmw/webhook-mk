"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.viewSearch = exports.tableSearch = exports.baseSearch = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const transport_1 = require("../transport");
async function baseSearch(filter, paginationToken) {
    var _a;
    let qs;
    if (paginationToken) {
        qs = {
            offset: paginationToken,
        };
    }
    const response = await transport_1.apiRequest.call(this, 'GET', 'meta/bases', undefined, qs);
    if (filter) {
        const results = [];
        for (const base of response.bases || []) {
            if ((_a = base.name) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes(filter.toLowerCase())) {
                results.push({
                    name: base.name,
                    value: base.id,
                    url: `https://airtable.com/${base.id}`,
                });
            }
        }
        return {
            results,
            paginationToken: response.offset,
        };
    }
    else {
        return {
            results: (response.bases || []).map((base) => ({
                name: base.name,
                value: base.id,
                url: `https://airtable.com/${base.id}`,
            })),
            paginationToken: response.offset,
        };
    }
}
exports.baseSearch = baseSearch;
async function tableSearch(filter, paginationToken) {
    var _a;
    const baseId = this.getNodeParameter('base', undefined, {
        extractValue: true,
    });
    let qs;
    if (paginationToken) {
        qs = {
            offset: paginationToken,
        };
    }
    const response = await transport_1.apiRequest.call(this, 'GET', `meta/bases/${baseId}/tables`, undefined, qs);
    if (filter) {
        const results = [];
        for (const table of response.tables || []) {
            if ((_a = table.name) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes(filter.toLowerCase())) {
                results.push({
                    name: table.name,
                    value: table.id,
                    url: `https://airtable.com/${baseId}/${table.id}`,
                });
            }
        }
        return {
            results,
            paginationToken: response.offset,
        };
    }
    else {
        return {
            results: (response.tables || []).map((table) => ({
                name: table.name,
                value: table.id,
                url: `https://airtable.com/${baseId}/${table.id}`,
            })),
            paginationToken: response.offset,
        };
    }
}
exports.tableSearch = tableSearch;
async function viewSearch(filter) {
    var _a;
    const baseId = this.getNodeParameter('base', undefined, {
        extractValue: true,
    });
    const tableId = encodeURI(this.getNodeParameter('table', undefined, {
        extractValue: true,
    }));
    const response = await transport_1.apiRequest.call(this, 'GET', `meta/bases/${baseId}/tables`);
    const tableData = (response.tables || []).find((table) => {
        return table.id === tableId;
    });
    if (!tableData) {
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Table information could not be found!', {
            level: 'warning',
        });
    }
    if (filter) {
        const results = [];
        for (const view of tableData.views || []) {
            if ((_a = view.name) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes(filter.toLowerCase())) {
                results.push({
                    name: view.name,
                    value: view.id,
                    url: `https://airtable.com/${baseId}/${tableId}/${view.id}`,
                });
            }
        }
        return {
            results,
        };
    }
    else {
        return {
            results: (tableData.views || []).map((view) => ({
                name: view.name,
                value: view.id,
                url: `https://airtable.com/${baseId}/${tableId}/${view.id}`,
            })),
        };
    }
}
exports.viewSearch = viewSearch;
//# sourceMappingURL=listSearch.js.map