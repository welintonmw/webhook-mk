"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClockifyTrigger = void 0;
const moment = require("moment-timezone");
const GenericFunctions_1 = require("./GenericFunctions");
const EntryTypeEnum_1 = require("./EntryTypeEnum");
class ClockifyTrigger {
    constructor() {
        this.description = {
            displayName: 'Clockify Trigger',
            icon: 'file:clockify.svg',
            name: 'clockifyTrigger',
            group: ['trigger'],
            version: 1,
            description: 'Listens to Clockify events',
            defaults: {
                name: 'Clockify Trigger',
                color: '#000000',
            },
            inputs: [],
            outputs: ['main'],
            credentials: [
                {
                    name: 'clockifyApi',
                    required: true,
                },
            ],
            polling: true,
            properties: [
                {
                    displayName: 'Workspace',
                    name: 'workspaceId',
                    type: 'options',
                    typeOptions: {
                        loadOptionsMethod: 'listWorkspaces',
                    },
                    required: true,
                    default: '',
                },
                {
                    displayName: 'Trigger',
                    name: 'watchField',
                    type: 'options',
                    options: [
                        {
                            name: 'New Time Entry',
                            value: EntryTypeEnum_1.EntryTypeEnum.NEW_TIME_ENTRY,
                        },
                    ],
                    required: true,
                    default: EntryTypeEnum_1.EntryTypeEnum.NEW_TIME_ENTRY,
                },
            ],
        };
        this.methods = {
            loadOptions: {
                async listWorkspaces() {
                    const rtv = [];
                    const workspaces = await GenericFunctions_1.clockifyApiRequest.call(this, 'GET', 'workspaces');
                    if (undefined !== workspaces) {
                        workspaces.forEach(value => {
                            rtv.push({
                                name: value.name,
                                value: value.id,
                            });
                        });
                    }
                    return rtv;
                },
            },
        };
    }
    async poll() {
        const webhookData = this.getWorkflowStaticData('node');
        const triggerField = this.getNodeParameter('watchField');
        const workspaceId = this.getNodeParameter('workspaceId');
        if (!webhookData.userId) {
            const userInfo = await GenericFunctions_1.clockifyApiRequest.call(this, 'GET', 'user');
            webhookData.userId = userInfo.id;
        }
        const qs = {};
        let resource;
        let result = null;
        switch (triggerField) {
            case EntryTypeEnum_1.EntryTypeEnum.NEW_TIME_ENTRY:
            default:
                const workflowTimezone = this.getTimezone();
                resource = `workspaces/${workspaceId}/user/${webhookData.userId}/time-entries`;
                qs.start = webhookData.lastTimeChecked;
                qs.end = moment().tz(workflowTimezone).format('YYYY-MM-DDTHH:mm:ss') + 'Z';
                qs.hydrated = true;
                qs['in-progress'] = false;
                break;
        }
        result = await GenericFunctions_1.clockifyApiRequest.call(this, 'GET', resource, {}, qs);
        webhookData.lastTimeChecked = qs.end;
        if (Array.isArray(result) && result.length !== 0) {
            return [this.helpers.returnJsonArray(result)];
        }
        return null;
    }
}
exports.ClockifyTrigger = ClockifyTrigger;
//# sourceMappingURL=ClockifyTrigger.node.js.map