"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortOptionParameters = exports.pipedriveResolveCustomProperties = exports.pipedriveEncodeCustomProperties = exports.pipedriveGetCustomProperties = exports.pipedriveApiRequestAllItems = exports.pipedriveApiRequest = void 0;
const n8n_workflow_1 = require("n8n-workflow");
async function pipedriveApiRequest(method, endpoint, body, query = {}, formData, downloadFile) {
    const authenticationMethod = this.getNodeParameter('authentication', 0);
    const options = {
        headers: {
            Accept: 'application/json',
        },
        method,
        qs: query,
        uri: `https://api.pipedrive.com/v1${endpoint}`,
    };
    if (downloadFile === true) {
        options.encoding = null;
    }
    else {
        options.json = true;
    }
    if (Object.keys(body).length !== 0) {
        options.body = body;
    }
    if (formData !== undefined && Object.keys(formData).length !== 0) {
        options.formData = formData;
    }
    if (query === undefined) {
        query = {};
    }
    let responseData;
    try {
        if (authenticationMethod === 'basicAuth' || authenticationMethod === 'apiToken' || authenticationMethod === 'none') {
            const credentials = await this.getCredentials('pipedriveApi');
            if (credentials === undefined) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'No credentials got returned!');
            }
            query.api_token = credentials.apiToken;
            responseData = await this.helpers.request(options);
        }
        else {
            responseData = await this.helpers.requestOAuth2.call(this, 'pipedriveOAuth2Api', options);
        }
        if (downloadFile === true) {
            return {
                data: responseData,
            };
        }
        if (responseData.success === false) {
            throw new n8n_workflow_1.NodeApiError(this.getNode(), responseData);
        }
        return {
            additionalData: responseData.additional_data,
            data: (responseData.data === null) ? [] : responseData.data,
        };
    }
    catch (error) {
        throw new n8n_workflow_1.NodeApiError(this.getNode(), error);
    }
}
exports.pipedriveApiRequest = pipedriveApiRequest;
async function pipedriveApiRequestAllItems(method, endpoint, body, query) {
    if (query === undefined) {
        query = {};
    }
    query.limit = 100;
    query.start = 0;
    const returnData = [];
    let responseData;
    do {
        responseData = await pipedriveApiRequest.call(this, method, endpoint, body, query);
        if (responseData.data.items) {
            returnData.push.apply(returnData, responseData.data.items);
        }
        else {
            returnData.push.apply(returnData, responseData.data);
        }
        query.start = responseData.additionalData.pagination.next_start;
    } while (responseData.additionalData !== undefined &&
        responseData.additionalData.pagination !== undefined &&
        responseData.additionalData.pagination.more_items_in_collection === true);
    return {
        data: returnData,
    };
}
exports.pipedriveApiRequestAllItems = pipedriveApiRequestAllItems;
async function pipedriveGetCustomProperties(resource) {
    const endpoints = {
        'activity': '/activityFields',
        'deal': '/dealFields',
        'organization': '/organizationFields',
        'person': '/personFields',
        'product': '/productFields',
    };
    if (endpoints[resource] === undefined) {
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), `The resource "${resource}" is not supported for resolving custom values!`);
    }
    const requestMethod = 'GET';
    const body = {};
    const qs = {};
    const responseData = await pipedriveApiRequest.call(this, requestMethod, endpoints[resource], body, qs);
    const customProperties = {};
    for (const customPropertyData of responseData.data) {
        customProperties[customPropertyData.key] = customPropertyData;
    }
    return customProperties;
}
exports.pipedriveGetCustomProperties = pipedriveGetCustomProperties;
function pipedriveEncodeCustomProperties(customProperties, item) {
    let customPropertyData;
    for (const key of Object.keys(item)) {
        customPropertyData = Object.values(customProperties).find(customPropertyData => customPropertyData.name === key);
        if (customPropertyData !== undefined) {
            if (item[key] !== null && item[key] !== undefined && customPropertyData.options !== undefined && Array.isArray(customPropertyData.options)) {
                const propertyOption = customPropertyData.options.find(option => option.label.toString() === item[key].toString());
                if (propertyOption !== undefined) {
                    item[customPropertyData.key] = propertyOption.id;
                    delete item[key];
                }
            }
            else {
                item[customPropertyData.key] = item[key];
                delete item[key];
            }
        }
    }
}
exports.pipedriveEncodeCustomProperties = pipedriveEncodeCustomProperties;
function pipedriveResolveCustomProperties(customProperties, item) {
    let customPropertyData;
    for (const key of Object.keys(item)) {
        if (customProperties[key] !== undefined) {
            customPropertyData = customProperties[key];
            if (item[key] !== null && item[key] !== undefined && customPropertyData.options !== undefined && Array.isArray(customPropertyData.options)) {
                const propertyOption = customPropertyData.options.find(option => option.id.toString() === item[key].toString());
                if (propertyOption !== undefined) {
                    item[customPropertyData.name] = propertyOption.label;
                    delete item[key];
                }
            }
            else {
                item[customPropertyData.name] = item[key];
                delete item[key];
            }
        }
    }
}
exports.pipedriveResolveCustomProperties = pipedriveResolveCustomProperties;
function sortOptionParameters(optionParameters) {
    optionParameters.sort((a, b) => {
        const aName = a.name.toLowerCase();
        const bName = b.name.toLowerCase();
        if (aName < bName) {
            return -1;
        }
        if (aName > bName) {
            return 1;
        }
        return 0;
    });
    return optionParameters;
}
exports.sortOptionParameters = sortOptionParameters;
//# sourceMappingURL=GenericFunctions.js.map