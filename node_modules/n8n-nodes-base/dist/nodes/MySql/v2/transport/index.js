"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPool = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const promise_1 = __importDefault(require("mysql2/promise"));
const utilities_1 = require("../../../../utils/utilities");
async function createSshConnectConfig(credentials) {
    if (credentials.sshAuthenticateWith === 'password') {
        return {
            host: credentials.sshHost,
            port: credentials.sshPort,
            username: credentials.sshUser,
            password: credentials.sshPassword,
        };
    }
    else {
        const options = {
            host: credentials.sshHost,
            username: credentials.sshUser,
            port: credentials.sshPort,
            privateKey: (0, utilities_1.formatPrivateKey)(credentials.privateKey),
        };
        if (credentials.passphrase) {
            options.passphrase = credentials.passphrase;
        }
        return options;
    }
}
async function createPool(credentials, options, sshClient) {
    if (credentials === undefined) {
        throw new n8n_workflow_1.ApplicationError('Credentials not selected, select or add new credentials', {
            level: 'warning',
        });
    }
    const { ssl, caCertificate, clientCertificate, clientPrivateKey, sshTunnel, sshHost, sshUser, sshPassword, sshPort, sshMysqlPort, privateKey, passphrase, sshAuthenticateWith, ...baseCredentials } = credentials;
    if (ssl) {
        baseCredentials.ssl = {};
        if (caCertificate) {
            baseCredentials.ssl.ca = (0, utilities_1.formatPrivateKey)(caCertificate);
        }
        if (clientCertificate || clientPrivateKey) {
            baseCredentials.ssl.cert = (0, utilities_1.formatPrivateKey)(clientCertificate);
            baseCredentials.ssl.key = (0, utilities_1.formatPrivateKey)(clientPrivateKey);
        }
    }
    const connectionOptions = {
        ...baseCredentials,
        multipleStatements: true,
        supportBigNumbers: true,
    };
    if ((options === null || options === void 0 ? void 0 : options.nodeVersion) && options.nodeVersion >= 2.1) {
        connectionOptions.dateStrings = true;
    }
    if (options === null || options === void 0 ? void 0 : options.connectionLimit) {
        connectionOptions.connectionLimit = options.connectionLimit;
    }
    if (options === null || options === void 0 ? void 0 : options.connectTimeout) {
        connectionOptions.connectTimeout = options.connectTimeout;
    }
    if ((options === null || options === void 0 ? void 0 : options.largeNumbersOutput) === 'text') {
        connectionOptions.bigNumberStrings = true;
    }
    if (!sshTunnel) {
        return promise_1.default.createPool(connectionOptions);
    }
    else {
        if (!sshClient) {
            throw new n8n_workflow_1.ApplicationError('SSH Tunnel is enabled but no SSH Client was provided', {
                level: 'warning',
            });
        }
        const tunnelConfig = await createSshConnectConfig(credentials);
        const forwardConfig = {
            srcHost: '127.0.0.1',
            srcPort: sshMysqlPort,
            dstHost: credentials.host,
            dstPort: credentials.port,
        };
        const poolSetup = new Promise((resolve, reject) => {
            sshClient
                .on('ready', () => {
                sshClient.forwardOut(forwardConfig.srcHost, forwardConfig.srcPort, forwardConfig.dstHost, forwardConfig.dstPort, (err, stream) => {
                    if (err)
                        reject(err);
                    const updatedDbServer = {
                        ...connectionOptions,
                        stream,
                    };
                    const connection = promise_1.default.createPool(updatedDbServer);
                    resolve(connection);
                });
            })
                .connect(tunnelConfig);
        });
        return await poolSetup;
    }
}
exports.createPool = createPool;
//# sourceMappingURL=index.js.map