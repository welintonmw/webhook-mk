"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceEmptyStringsByNulls = exports.addSortRules = exports.addWhereClauses = exports.configureQueryRunner = exports.splitQueryToStatements = exports.prepareOutput = exports.wrapData = exports.parseMySqlError = exports.prepareErrorItem = exports.prepareQueryAndReplacements = exports.escapeSqlIdentifier = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const utilities_1 = require("../../../../utils/utilities");
const interfaces_1 = require("./interfaces");
function escapeSqlIdentifier(identifier) {
    var _a;
    const parts = (_a = identifier.match(/(`[^`]*`|[^.`]+)/g)) !== null && _a !== void 0 ? _a : [];
    return parts
        .map((part) => {
        const trimmedPart = part.trim();
        if (trimmedPart.startsWith('`') && trimmedPart.endsWith('`')) {
            return trimmedPart;
        }
        return `\`${trimmedPart}\``;
    })
        .join('.');
}
exports.escapeSqlIdentifier = escapeSqlIdentifier;
const prepareQueryAndReplacements = (rawQuery, replacements) => {
    if (replacements === undefined) {
        return { query: rawQuery, values: [] };
    }
    let query = rawQuery;
    const values = [];
    const regex = /\$(\d+)(?::name)?/g;
    const matches = rawQuery.match(regex) || [];
    for (const match of matches) {
        if (match.includes(':name')) {
            const matchIndex = Number(match.replace('$', '').replace(':name', '')) - 1;
            query = query.replace(match, escapeSqlIdentifier(replacements[matchIndex].toString()));
        }
        else {
            const matchIndex = Number(match.replace('$', '')) - 1;
            query = query.replace(match, '?');
            values.push(replacements[matchIndex]);
        }
    }
    return { query, values };
};
exports.prepareQueryAndReplacements = prepareQueryAndReplacements;
function prepareErrorItem(item, error, index) {
    return {
        json: { message: error.message, item: { ...item }, itemIndex: index, error: { ...error } },
        pairedItem: { item: index },
    };
}
exports.prepareErrorItem = prepareErrorItem;
function parseMySqlError(error, itemIndex = 0, queries) {
    let message = error.message;
    const description = `sql: ${error.sql}, code: ${error.code}`;
    if ((queries === null || queries === void 0 ? void 0 : queries.length) &&
        (message || '').toLowerCase().includes('you have an error in your sql syntax')) {
        let queryIndex = itemIndex;
        const failedStatement = ((message.split("near '")[1] || '').split("' at")[0] || '').split(';')[0];
        if (failedStatement) {
            if (queryIndex === 0 && queries.length > 1) {
                const failedQueryIndex = queries.findIndex((query) => query.includes(failedStatement));
                if (failedQueryIndex !== -1) {
                    queryIndex = failedQueryIndex;
                }
            }
            const lines = queries[queryIndex].split('\n');
            const failedLine = lines.findIndex((line) => line.includes(failedStatement));
            if (failedLine !== -1) {
                message = `You have an error in your SQL syntax on line ${failedLine + 1} near '${failedStatement}'`;
            }
        }
    }
    if ((error === null || error === void 0 ? void 0 : error.message).includes('ECONNREFUSED')) {
        message = 'Connection refused';
    }
    return new n8n_workflow_1.NodeOperationError(this.getNode(), error, {
        message,
        description,
        itemIndex,
    });
}
exports.parseMySqlError = parseMySqlError;
function wrapData(data) {
    if (!Array.isArray(data)) {
        return [{ json: data }];
    }
    return data.map((item) => ({
        json: item,
    }));
}
exports.wrapData = wrapData;
function prepareOutput(response, options, statements, constructExecutionHelper, itemData) {
    const returnData = [];
    if (options.detailedOutput) {
        response.forEach((entry, index) => {
            const item = {
                sql: statements[index],
                data: entry,
            };
            const executionData = constructExecutionHelper(wrapData(item), {
                itemData,
            });
            returnData.push(...executionData);
        });
    }
    else {
        response
            .filter((entry) => Array.isArray(entry))
            .forEach((entry, index) => {
            const executionData = constructExecutionHelper(wrapData(entry), {
                itemData: Array.isArray(itemData) ? itemData[index] : itemData,
            });
            returnData.push(...executionData);
        });
    }
    if (!returnData.length) {
        if ((options === null || options === void 0 ? void 0 : options.nodeVersion) < 2.2) {
            returnData.push({ json: { success: true }, pairedItem: itemData });
        }
        else {
            const isSelectQuery = statements
                .filter((statement) => !statement.startsWith('--'))
                .every((statement) => statement
                .replace(/\/\*.*?\*\//g, '')
                .replace(/\n/g, '')
                .toLowerCase()
                .startsWith('select'));
            if (!isSelectQuery) {
                returnData.push({ json: { success: true }, pairedItem: itemData });
            }
        }
    }
    return returnData;
}
exports.prepareOutput = prepareOutput;
const END_OF_STATEMENT = /;(?=(?:[^'\\]|'[^']*?'|\\[\s\S])*?$)/g;
const splitQueryToStatements = (query, filterOutEmpty = true) => {
    const statements = query
        .replace(/\n/g, '')
        .split(END_OF_STATEMENT)
        .map((statement) => statement.trim());
    return filterOutEmpty ? statements.filter((statement) => statement !== '') : statements;
};
exports.splitQueryToStatements = splitQueryToStatements;
function configureQueryRunner(options, pool) {
    return async (queries) => {
        if (queries.length === 0) {
            return [];
        }
        const returnData = [];
        const mode = options.queryBatching || interfaces_1.BATCH_MODE.SINGLE;
        const connection = await pool.getConnection();
        if (mode === interfaces_1.BATCH_MODE.SINGLE) {
            const formatedQueries = queries.map(({ query, values }) => connection.format(query, values));
            try {
                connection.release();
                let singleQuery = '';
                if (formatedQueries.length > 1) {
                    singleQuery = formatedQueries.map((query) => query.trim().replace(/;$/, '')).join(';');
                }
                else {
                    singleQuery = formatedQueries[0];
                }
                let response = (await pool.query(singleQuery))[0];
                if (!response)
                    return [];
                let statements;
                if ((options === null || options === void 0 ? void 0 : options.nodeVersion) <= 2.3) {
                    statements = singleQuery
                        .replace(/\n/g, '')
                        .split(';')
                        .filter((statement) => statement !== '');
                }
                else {
                    statements = (0, exports.splitQueryToStatements)(singleQuery);
                }
                if (Array.isArray(response)) {
                    if (statements.length === 1)
                        response = [response];
                }
                else {
                    response = [response];
                }
                const pairedItem = (0, utilities_1.generatePairedItemData)(queries.length);
                returnData.push(...prepareOutput(response, options, statements, this.helpers.constructExecutionMetaData, pairedItem));
            }
            catch (err) {
                const error = parseMySqlError.call(this, err, 0, formatedQueries);
                if (!this.continueOnFail(err))
                    throw error;
                returnData.push({ json: { message: error.message, error: { ...error } } });
            }
        }
        else {
            if (mode === interfaces_1.BATCH_MODE.INDEPENDENTLY) {
                let formatedQuery = '';
                for (const [index, queryWithValues] of queries.entries()) {
                    try {
                        const { query, values } = queryWithValues;
                        formatedQuery = connection.format(query, values);
                        let statements;
                        if ((options === null || options === void 0 ? void 0 : options.nodeVersion) <= 2.3) {
                            statements = formatedQuery.split(';').map((q) => q.trim());
                        }
                        else {
                            statements = (0, exports.splitQueryToStatements)(formatedQuery, false);
                        }
                        const responses = [];
                        for (const statement of statements) {
                            if (statement === '')
                                continue;
                            const response = (await connection.query(statement))[0];
                            responses.push(response);
                        }
                        returnData.push(...prepareOutput(responses, options, statements, this.helpers.constructExecutionMetaData, { item: index }));
                    }
                    catch (err) {
                        const error = parseMySqlError.call(this, err, index, [formatedQuery]);
                        if (!this.continueOnFail(err)) {
                            connection.release();
                            throw error;
                        }
                        returnData.push(prepareErrorItem(queries[index], error, index));
                    }
                }
            }
            if (mode === interfaces_1.BATCH_MODE.TRANSACTION) {
                await connection.beginTransaction();
                let formatedQuery = '';
                for (const [index, queryWithValues] of queries.entries()) {
                    try {
                        const { query, values } = queryWithValues;
                        formatedQuery = connection.format(query, values);
                        let statements;
                        if ((options === null || options === void 0 ? void 0 : options.nodeVersion) <= 2.3) {
                            statements = formatedQuery.split(';').map((q) => q.trim());
                        }
                        else {
                            statements = (0, exports.splitQueryToStatements)(formatedQuery, false);
                        }
                        const responses = [];
                        for (const statement of statements) {
                            if (statement === '')
                                continue;
                            const response = (await connection.query(statement))[0];
                            responses.push(response);
                        }
                        returnData.push(...prepareOutput(responses, options, statements, this.helpers.constructExecutionMetaData, { item: index }));
                    }
                    catch (err) {
                        const error = parseMySqlError.call(this, err, index, [formatedQuery]);
                        if (connection) {
                            await connection.rollback();
                            connection.release();
                        }
                        if (!this.continueOnFail(err))
                            throw error;
                        returnData.push(prepareErrorItem(queries[index], error, index));
                        return returnData;
                    }
                }
                await connection.commit();
            }
            connection.release();
        }
        return returnData;
    };
}
exports.configureQueryRunner = configureQueryRunner;
function addWhereClauses(node, itemIndex, query, clauses, replacements, combineConditions) {
    if (clauses.length === 0)
        return [query, replacements];
    let combineWith = 'AND';
    if (combineConditions === 'OR') {
        combineWith = 'OR';
    }
    let whereQuery = ' WHERE';
    const values = [];
    clauses.forEach((clause, index) => {
        if (clause.condition === 'equal') {
            clause.condition = '=';
        }
        if (['>', '<', '>=', '<='].includes(clause.condition)) {
            const value = Number(clause.value);
            if (Number.isNaN(value)) {
                throw new n8n_workflow_1.NodeOperationError(node, `Operator in entry ${index + 1} of 'Select Rows' works with numbers, but value ${clause.value} is not a number`, {
                    itemIndex,
                });
            }
            clause.value = value;
        }
        let valueReplacement = ' ';
        if (clause.condition !== 'IS NULL' && clause.condition !== 'IS NOT NULL') {
            valueReplacement = ' ?';
            values.push(clause.value);
        }
        const operator = index === clauses.length - 1 ? '' : ` ${combineWith}`;
        whereQuery += ` ${escapeSqlIdentifier(clause.column)} ${clause.condition}${valueReplacement}${operator}`;
    });
    return [`${query}${whereQuery}`, replacements.concat(...values)];
}
exports.addWhereClauses = addWhereClauses;
function addSortRules(query, rules, replacements) {
    if (rules.length === 0)
        return [query, replacements];
    let orderByQuery = ' ORDER BY';
    const values = [];
    rules.forEach((rule, index) => {
        const endWith = index === rules.length - 1 ? '' : ',';
        orderByQuery += ` ${escapeSqlIdentifier(rule.column)} ${rule.direction}${endWith}`;
    });
    return [`${query}${orderByQuery}`, replacements.concat(...values)];
}
exports.addSortRules = addSortRules;
function replaceEmptyStringsByNulls(items, replace) {
    if (!replace)
        return [...items];
    const returnData = items.map((item) => {
        const newItem = { ...item };
        const keys = Object.keys(newItem.json);
        for (const key of keys) {
            if (newItem.json[key] === '') {
                newItem.json[key] = null;
            }
        }
        return newItem;
    });
    return returnData;
}
exports.replaceEmptyStringsByNulls = replaceEmptyStringsByNulls;
//# sourceMappingURL=utils.js.map