"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mqtt = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const mqtt = __importStar(require("mqtt"));
const utilities_1 = require("../../utils/utilities");
class Mqtt {
    constructor() {
        this.description = {
            displayName: 'MQTT',
            name: 'mqtt',
            icon: 'file:mqtt.svg',
            group: ['input'],
            version: 1,
            description: 'Push messages to MQTT',
            defaults: {
                name: 'MQTT',
            },
            inputs: ['main'],
            outputs: ['main'],
            credentials: [
                {
                    name: 'mqtt',
                    required: true,
                    testedBy: 'mqttConnectionTest',
                },
            ],
            properties: [
                {
                    displayName: 'Topic',
                    name: 'topic',
                    type: 'string',
                    required: true,
                    default: '',
                    description: 'The topic to publish to',
                },
                {
                    displayName: 'Send Input Data',
                    name: 'sendInputData',
                    type: 'boolean',
                    default: true,
                    description: 'Whether to send the data the node receives as JSON',
                },
                {
                    displayName: 'Message',
                    name: 'message',
                    type: 'string',
                    required: true,
                    displayOptions: {
                        show: {
                            sendInputData: [false],
                        },
                    },
                    default: '',
                    description: 'The message to publish',
                },
                {
                    displayName: 'Options',
                    name: 'options',
                    type: 'collection',
                    placeholder: 'Add Option',
                    default: {},
                    options: [
                        {
                            displayName: 'QoS',
                            name: 'qos',
                            type: 'options',
                            options: [
                                {
                                    name: 'Received at Most Once',
                                    value: 0,
                                },
                                {
                                    name: 'Received at Least Once',
                                    value: 1,
                                },
                                {
                                    name: 'Exactly Once',
                                    value: 2,
                                },
                            ],
                            default: 0,
                            description: 'QoS subscription level',
                        },
                        {
                            displayName: 'Retain',
                            name: 'retain',
                            type: 'boolean',
                            default: false,
                            description: 'Normally if a publisher publishes a message to a topic, and no one is subscribed to that topic the message is simply discarded by the broker. However the publisher can tell the broker to keep the last message on that topic by setting the retain flag to true.',
                        },
                    ],
                },
            ],
        };
        this.methods = {
            credentialTest: {
                async mqttConnectionTest(credential) {
                    const credentials = credential.data;
                    try {
                        const protocol = credentials.protocol || 'mqtt';
                        const host = credentials.host;
                        const brokerUrl = `${protocol}://${host}`;
                        const port = credentials.port || 1883;
                        const clientId = credentials.clientId || `mqttjs_${(0, n8n_workflow_1.randomString)(8).toLowerCase()}`;
                        const clean = credentials.clean;
                        const ssl = credentials.ssl;
                        const ca = (0, utilities_1.formatPrivateKey)(credentials.ca);
                        const cert = (0, utilities_1.formatPrivateKey)(credentials.cert);
                        const key = (0, utilities_1.formatPrivateKey)(credentials.key);
                        const rejectUnauthorized = credentials.rejectUnauthorized;
                        let client;
                        if (!ssl) {
                            const clientOptions = {
                                port,
                                clean,
                                clientId,
                            };
                            if (credentials.username && credentials.password) {
                                clientOptions.username = credentials.username;
                                clientOptions.password = credentials.password;
                            }
                            client = mqtt.connect(brokerUrl, clientOptions);
                        }
                        else {
                            const clientOptions = {
                                port,
                                clean,
                                clientId,
                                ca,
                                cert,
                                key,
                                rejectUnauthorized,
                            };
                            if (credentials.username && credentials.password) {
                                clientOptions.username = credentials.username;
                                clientOptions.password = credentials.password;
                            }
                            client = mqtt.connect(brokerUrl, clientOptions);
                        }
                        await new Promise((resolve, reject) => {
                            client.on('connect', (test) => {
                                resolve(test);
                                client.end();
                            });
                            client.on('error', (error) => {
                                client.end();
                                reject(error);
                            });
                        });
                    }
                    catch (error) {
                        return {
                            status: 'Error',
                            message: error.message,
                        };
                    }
                    return {
                        status: 'OK',
                        message: 'Connection successful!',
                    };
                },
            },
        };
    }
    async execute() {
        const items = this.getInputData();
        const length = items.length;
        const credentials = await this.getCredentials('mqtt');
        const protocol = credentials.protocol || 'mqtt';
        const host = credentials.host;
        const brokerUrl = `${protocol}://${host}`;
        const port = credentials.port || 1883;
        const clientId = credentials.clientId || `mqttjs_${(0, n8n_workflow_1.randomString)(8).toLowerCase()}`;
        const clean = credentials.clean;
        const ssl = credentials.ssl;
        const ca = credentials.ca;
        const cert = credentials.cert;
        const key = credentials.key;
        const rejectUnauthorized = credentials.rejectUnauthorized;
        let client;
        if (!ssl) {
            const clientOptions = {
                port,
                clean,
                clientId,
            };
            if (credentials.username && credentials.password) {
                clientOptions.username = credentials.username;
                clientOptions.password = credentials.password;
            }
            client = mqtt.connect(brokerUrl, clientOptions);
        }
        else {
            const clientOptions = {
                port,
                clean,
                clientId,
                ca,
                cert,
                key,
                rejectUnauthorized,
            };
            if (credentials.username && credentials.password) {
                clientOptions.username = credentials.username;
                clientOptions.password = credentials.password;
            }
            client = mqtt.connect(brokerUrl, clientOptions);
        }
        const sendInputData = this.getNodeParameter('sendInputData', 0);
        const data = await new Promise((resolve, reject) => {
            client.on('connect', () => {
                for (let i = 0; i < length; i++) {
                    let message;
                    const topic = this.getNodeParameter('topic', i);
                    const options = this.getNodeParameter('options', i);
                    try {
                        if (sendInputData) {
                            message = JSON.stringify(items[i].json);
                        }
                        else {
                            message = this.getNodeParameter('message', i);
                        }
                        client.publish(topic, message, options);
                    }
                    catch (e) {
                        reject(e);
                    }
                }
                client.end(false, {}, () => {
                    resolve([items]);
                });
                client.on('error', (e) => {
                    reject(e);
                });
            });
        });
        return data;
    }
}
exports.Mqtt = Mqtt;
//# sourceMappingURL=Mqtt.node.js.map