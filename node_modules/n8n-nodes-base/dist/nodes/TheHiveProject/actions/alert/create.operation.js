"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.description = void 0;
const set_1 = __importDefault(require("lodash/set"));
const form_data_1 = __importDefault(require("form-data"));
const transport_1 = require("../../transport");
const utils_1 = require("../../helpers/utils");
const descriptions_1 = require("../../descriptions");
const utilities_1 = require("../../../../utils/utilities");
const properties = [
    {
        displayName: 'Fields',
        name: 'alertFields',
        type: 'resourceMapper',
        default: {
            mappingMode: 'defineBelow',
            value: null,
        },
        noDataExpression: true,
        required: true,
        typeOptions: {
            resourceMapper: {
                resourceMapperMethod: 'getAlertFields',
                mode: 'add',
                valuesLabel: 'Fields',
            },
        },
    },
    {
        displayName: 'Observables',
        name: 'observableUi',
        type: 'fixedCollection',
        placeholder: 'Add Observable',
        default: {},
        typeOptions: {
            multipleValues: true,
        },
        options: [
            {
                displayName: 'Values',
                name: 'values',
                values: [
                    descriptions_1.observableTypeOptions,
                    {
                        displayName: 'Data',
                        name: 'data',
                        type: 'string',
                        displayOptions: {
                            hide: {
                                dataType: ['file'],
                            },
                        },
                        default: '',
                    },
                    {
                        displayName: 'Input Binary Field',
                        name: 'binaryProperty',
                        type: 'string',
                        hint: 'The name of the input binary field containing the file to be written',
                        displayOptions: {
                            show: {
                                dataType: ['file'],
                            },
                        },
                        default: 'data',
                    },
                    {
                        displayName: 'Message',
                        name: 'message',
                        type: 'string',
                        default: '',
                    },
                    {
                        displayName: 'Tags',
                        name: 'tags',
                        type: 'string',
                        default: '',
                    },
                ],
            },
        ],
    },
];
const displayOptions = {
    show: {
        resource: ['alert'],
        operation: ['create'],
    },
};
exports.description = (0, utilities_1.updateDisplayOptions)(displayOptions, properties);
async function execute(i, item) {
    let responseData = [];
    let inputData = {};
    const dataMode = this.getNodeParameter('alertFields.mappingMode', i);
    if (dataMode === 'autoMapInputData') {
        const schema = this.getNodeParameter('alertFields.schema', i);
        inputData = (0, utils_1.prepareInputItem)(item.json, schema, i);
    }
    if (dataMode === 'defineBelow') {
        const alertFields = this.getNodeParameter('alertFields.value', i, []);
        inputData = alertFields;
    }
    inputData = (0, utils_1.fixFieldType)(inputData);
    const body = {};
    for (const field of Object.keys(inputData)) {
        (0, set_1.default)(body, field, inputData[field]);
    }
    let multiPartRequest = false;
    const formData = new form_data_1.default();
    const observableUi = this.getNodeParameter('observableUi', i);
    if (observableUi) {
        const values = observableUi.values;
        if (values) {
            const observables = [];
            for (const value of values) {
                const observable = {};
                observable.dataType = value.dataType;
                observable.message = value.message;
                observable.tags = (0, utils_1.splitAndTrim)(value.tags);
                if (value.dataType === 'file') {
                    multiPartRequest = true;
                    const attachmentIndex = `attachment${i}`;
                    observable.attachment = attachmentIndex;
                    const binaryPropertyName = value.binaryProperty;
                    const binaryData = this.helpers.assertBinaryData(i, binaryPropertyName);
                    const dataBuffer = await this.helpers.getBinaryDataBuffer(i, binaryPropertyName);
                    formData.append(attachmentIndex, dataBuffer, {
                        filename: binaryData.fileName,
                        contentType: binaryData.mimeType,
                    });
                }
                else {
                    observable.data = value.data;
                }
                observables.push(observable);
            }
            body.observables = observables;
        }
    }
    if (multiPartRequest) {
        formData.append('_json', JSON.stringify(body));
        responseData = await transport_1.theHiveApiRequest.call(this, 'POST', '/v1/alert', undefined, undefined, undefined, {
            Headers: {
                'Content-Type': 'multipart/form-data',
            },
            formData,
        });
    }
    else {
        responseData = await transport_1.theHiveApiRequest.call(this, 'POST', '/v1/alert', body);
    }
    const executionData = this.helpers.constructExecutionMetaData((0, utilities_1.wrapData)(responseData), {
        itemData: { item: i },
    });
    return executionData;
}
exports.execute = execute;
//# sourceMappingURL=create.operation.js.map