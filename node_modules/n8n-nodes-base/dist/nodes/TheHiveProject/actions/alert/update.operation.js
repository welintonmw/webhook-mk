"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.description = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const set_1 = __importDefault(require("lodash/set"));
const transport_1 = require("../../transport");
const utils_1 = require("../../helpers/utils");
const utilities_1 = require("../../../../utils/utilities");
const properties = [
    {
        displayName: 'Fields',
        name: 'alertUpdateFields',
        type: 'resourceMapper',
        default: {
            mappingMode: 'defineBelow',
            value: null,
        },
        noDataExpression: true,
        required: true,
        typeOptions: {
            resourceMapper: {
                resourceMapperMethod: 'getAlertUpdateFields',
                mode: 'update',
                valuesLabel: 'Fields',
                addAllFields: true,
                multiKeyMatch: true,
            },
        },
    },
];
const displayOptions = {
    show: {
        resource: ['alert'],
        operation: ['update'],
    },
};
exports.description = (0, utilities_1.updateDisplayOptions)(displayOptions, properties);
async function execute(i, item) {
    let body = {};
    let updated = 1;
    const dataMode = this.getNodeParameter('alertUpdateFields.mappingMode', i);
    if (dataMode === 'autoMapInputData') {
        const schema = this.getNodeParameter('alertUpdateFields.schema', i);
        body = (0, utils_1.prepareInputItem)(item.json, schema, i);
    }
    if (dataMode === 'defineBelow') {
        const alertUpdateFields = this.getNodeParameter('alertUpdateFields.value', i, []);
        body = alertUpdateFields;
    }
    body = (0, utils_1.fixFieldType)(body);
    const fieldsToMatchOn = this.getNodeParameter('alertUpdateFields.matchingColumns', i);
    const updateBody = {};
    const matchFields = {};
    const { id } = body;
    for (const field of Object.keys(body)) {
        if (field === 'customFields') {
            const customFields = {};
            for (const customField of Object.keys(body.customFields || {})) {
                const combinedPath = `customFields.${customField}`;
                if (fieldsToMatchOn.includes(combinedPath)) {
                    matchFields[combinedPath] = body.customFields[customField];
                }
                else {
                    customFields[customField] = body.customFields[customField];
                }
            }
            (0, set_1.default)(updateBody, 'customFields', customFields);
            continue;
        }
        if (fieldsToMatchOn.includes(field)) {
            matchFields[field] = body[field];
        }
        else {
            (0, set_1.default)(updateBody, field, body[field]);
        }
    }
    if (fieldsToMatchOn.includes('id')) {
        await transport_1.theHiveApiRequest.call(this, 'PATCH', `/v1/alert/${id}`, updateBody);
    }
    else {
        const filter = {
            _name: 'filter',
            _and: fieldsToMatchOn.map((field) => ({
                _eq: {
                    _field: field,
                    _value: matchFields[field],
                },
            })),
        };
        const queryBody = {
            query: [
                {
                    _name: 'listAlert',
                },
                filter,
            ],
        };
        const matches = (await transport_1.theHiveApiRequest.call(this, 'POST', '/v1/query', queryBody));
        if (!matches.length) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'No matching alerts found');
        }
        const ids = matches.map((match) => match._id);
        updated = ids.length;
        updateBody.ids = ids;
        await transport_1.theHiveApiRequest.call(this, 'PATCH', '/v1/alert/_bulk', updateBody);
    }
    const executionData = this.helpers.constructExecutionMetaData((0, utilities_1.wrapData)({ success: true, updatedAlerts: updated }), {
        itemData: { item: i },
    });
    return executionData;
}
exports.execute = execute;
//# sourceMappingURL=update.operation.js.map