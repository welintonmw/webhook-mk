"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Redis = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const lodash_1 = require("lodash");
const redis = require("redis");
const util = require("util");
class Redis {
    constructor() {
        this.description = {
            displayName: 'Redis',
            name: 'redis',
            icon: 'file:redis.svg',
            group: ['input'],
            version: 1,
            description: 'Get, send and update data in Redis',
            defaults: {
                name: 'Redis',
                color: '#0033AA',
            },
            inputs: ['main'],
            outputs: ['main'],
            credentials: [
                {
                    name: 'redis',
                    required: true,
                },
            ],
            properties: [
                {
                    displayName: 'Operation',
                    name: 'operation',
                    type: 'options',
                    options: [
                        {
                            name: 'Delete',
                            value: 'delete',
                            description: 'Delete a key from Redis.',
                        },
                        {
                            name: 'Get',
                            value: 'get',
                            description: 'Get the value of a key from Redis.',
                        },
                        {
                            name: 'Info',
                            value: 'info',
                            description: 'Returns generic information about the Redis instance.',
                        },
                        {
                            name: 'Increment',
                            value: 'incr',
                            description: 'Atomically increments a key by 1. Creates the key if it does not exist.',
                        },
                        {
                            name: 'Keys',
                            value: 'keys',
                            description: 'Returns all the keys matching a pattern.',
                        },
                        {
                            name: 'Set',
                            value: 'set',
                            description: 'Set the value of a key in redis.',
                        },
                    ],
                    default: 'info',
                    description: 'The operation to perform.',
                },
                {
                    displayName: 'Name',
                    name: 'propertyName',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: [
                                'get',
                            ],
                        },
                    },
                    default: 'propertyName',
                    required: true,
                    description: 'Name of the property to write received data to.<br />Supports dot-notation.<br />Example: "data.person[0].name"',
                },
                {
                    displayName: 'Key',
                    name: 'key',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: [
                                'delete',
                            ],
                        },
                    },
                    default: '',
                    required: true,
                    description: 'Name of the key to delete from Redis.',
                },
                {
                    displayName: 'Key',
                    name: 'key',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: [
                                'get',
                            ],
                        },
                    },
                    default: '',
                    required: true,
                    description: 'Name of the key to get from Redis.',
                },
                {
                    displayName: 'Key Type',
                    name: 'keyType',
                    type: 'options',
                    displayOptions: {
                        show: {
                            operation: [
                                'get',
                            ],
                        },
                    },
                    options: [
                        {
                            name: 'Automatic',
                            value: 'automatic',
                            description: 'Requests the type before requesting the data (slower).',
                        },
                        {
                            name: 'Hash',
                            value: 'hash',
                            description: 'Data in key is of type "hash".',
                        },
                        {
                            name: 'String',
                            value: 'string',
                            description: 'Data in key is of type "string".',
                        },
                        {
                            name: 'List',
                            value: 'list',
                            description: 'Data in key is of type "lists".',
                        },
                        {
                            name: 'Sets',
                            value: 'sets',
                            description: 'Data in key is of type "sets".',
                        },
                    ],
                    default: 'automatic',
                    description: 'The type of the key to get.',
                },
                {
                    displayName: 'Options',
                    name: 'options',
                    type: 'collection',
                    displayOptions: {
                        show: {
                            operation: [
                                'get',
                            ],
                        },
                    },
                    placeholder: 'Add Option',
                    default: {},
                    options: [
                        {
                            displayName: 'Dot Notation',
                            name: 'dotNotation',
                            type: 'boolean',
                            default: true,
                            description: `By default does dot-notation get used in property names.<br />
						This means that "a.b" will set the property "b" underneath "a" so { "a": { "b": value} }.<br />
						If that is not intended this can be deactivated, it will then set { "a.b": value } instead.
						`,
                        },
                    ],
                },
                {
                    displayName: 'Key',
                    name: 'key',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: [
                                'incr',
                            ],
                        },
                    },
                    default: '',
                    required: true,
                    description: 'Name of the key to increment.',
                },
                {
                    displayName: 'Expire',
                    name: 'expire',
                    type: 'boolean',
                    displayOptions: {
                        show: {
                            operation: [
                                'incr',
                            ],
                        },
                    },
                    default: false,
                    description: 'Set a timeout on key?',
                },
                {
                    displayName: 'TTL',
                    name: 'ttl',
                    type: 'number',
                    typeOptions: {
                        minValue: 1,
                    },
                    displayOptions: {
                        show: {
                            operation: [
                                'incr',
                            ],
                            expire: [
                                true,
                            ],
                        },
                    },
                    default: 60,
                    description: 'Number of seconds before key expiration.',
                },
                {
                    displayName: 'Key Pattern',
                    name: 'keyPattern',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: [
                                'keys',
                            ],
                        },
                    },
                    default: '',
                    required: true,
                    description: 'The key pattern for the keys to return.',
                },
                {
                    displayName: 'Key',
                    name: 'key',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: [
                                'set',
                            ],
                        },
                    },
                    default: '',
                    required: true,
                    description: 'Name of the key to set in Redis.',
                },
                {
                    displayName: 'Value',
                    name: 'value',
                    type: 'string',
                    displayOptions: {
                        show: {
                            operation: [
                                'set',
                            ],
                        },
                    },
                    default: '',
                    description: 'The value to write in Redis.',
                },
                {
                    displayName: 'Key Type',
                    name: 'keyType',
                    type: 'options',
                    displayOptions: {
                        show: {
                            operation: [
                                'set',
                            ],
                        },
                    },
                    options: [
                        {
                            name: 'Automatic',
                            value: 'automatic',
                            description: 'Tries to figure out the type automatically depending on the data.',
                        },
                        {
                            name: 'Hash',
                            value: 'hash',
                            description: 'Data in key is of type "hash".',
                        },
                        {
                            name: 'String',
                            value: 'string',
                            description: 'Data in key is of type "string".',
                        },
                        {
                            name: 'List',
                            value: 'list',
                            description: 'Data in key is of type "lists".',
                        },
                        {
                            name: 'Sets',
                            value: 'sets',
                            description: 'Data in key is of type "sets".',
                        },
                    ],
                    default: 'automatic',
                    description: 'The type of the key to set.',
                },
                {
                    displayName: 'Expire',
                    name: 'expire',
                    type: 'boolean',
                    displayOptions: {
                        show: {
                            operation: [
                                'set',
                            ],
                        },
                    },
                    default: false,
                    description: 'Set a timeout on key ?',
                },
                {
                    displayName: 'TTL',
                    name: 'ttl',
                    type: 'number',
                    typeOptions: {
                        minValue: 1,
                    },
                    displayOptions: {
                        show: {
                            operation: [
                                'set',
                            ],
                            expire: [
                                true,
                            ],
                        },
                    },
                    default: 60,
                    description: 'Number of seconds before key expiration.',
                },
            ],
        };
    }
    execute() {
        function getParsedValue(value) {
            if (value.match(/^[\d\.]+$/) === null) {
                return value;
            }
            else {
                return parseFloat(value);
            }
        }
        function convertInfoToObject(stringData) {
            const returnData = {};
            let key, value;
            for (const line of stringData.split('\n')) {
                if (['#', ''].includes(line.charAt(0))) {
                    continue;
                }
                [key, value] = line.split(':');
                if (key === undefined || value === undefined) {
                    continue;
                }
                value = value.trim();
                if (value.includes('=')) {
                    returnData[key] = {};
                    let key2, value2;
                    for (const keyValuePair of value.split(',')) {
                        [key2, value2] = keyValuePair.split('=');
                        returnData[key][key2] = getParsedValue(value2);
                    }
                }
                else {
                    returnData[key] = getParsedValue(value);
                }
            }
            return returnData;
        }
        async function getValue(client, keyName, type) {
            if (type === undefined || type === 'automatic') {
                const clientType = util.promisify(client.type).bind(client);
                type = await clientType(keyName);
            }
            if (type === 'string') {
                const clientGet = util.promisify(client.get).bind(client);
                return await clientGet(keyName);
            }
            else if (type === 'hash') {
                const clientHGetAll = util.promisify(client.hgetall).bind(client);
                return await clientHGetAll(keyName);
            }
            else if (type === 'list') {
                const clientLRange = util.promisify(client.lrange).bind(client);
                return await clientLRange(keyName, 0, -1);
            }
            else if (type === 'sets') {
                const clientSMembers = util.promisify(client.smembers).bind(client);
                return await clientSMembers(keyName);
            }
        }
        const setValue = async (client, keyName, value, expire, ttl, type) => {
            if (type === undefined || type === 'automatic') {
                if (typeof value === 'string') {
                    type = 'string';
                }
                else if (Array.isArray(value)) {
                    type = 'list';
                }
                else if (typeof value === 'object') {
                    type = 'hash';
                }
                else {
                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Could not identify the type to set. Please set it manually!');
                }
            }
            if (type === 'string') {
                const clientSet = util.promisify(client.set).bind(client);
                await clientSet(keyName, value.toString());
            }
            else if (type === 'hash') {
                const clientHset = util.promisify(client.hset).bind(client);
                for (const key of Object.keys(value)) {
                    await clientHset(keyName, key, value[key].toString());
                }
            }
            else if (type === 'list') {
                const clientLset = util.promisify(client.lset).bind(client);
                for (let index = 0; index < value.length; index++) {
                    await clientLset(keyName, index, value[index].toString());
                }
            }
            if (expire === true) {
                const clientExpire = util.promisify(client.expire).bind(client);
                await clientExpire(keyName, ttl);
            }
            return;
        };
        return new Promise(async (resolve, reject) => {
            const credentials = await this.getCredentials('redis');
            if (credentials === undefined) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'No credentials got returned!');
            }
            const redisOptions = {
                host: credentials.host,
                port: credentials.port,
            };
            if (credentials.password) {
                redisOptions.password = credentials.password;
            }
            const client = redis.createClient(redisOptions);
            const operation = this.getNodeParameter('operation', 0);
            client.on('error', (err) => {
                client.quit();
                reject(err);
            });
            client.on('ready', async (err) => {
                try {
                    if (operation === 'info') {
                        const clientInfo = util.promisify(client.info).bind(client);
                        const result = await clientInfo();
                        resolve(this.prepareOutputData([{ json: convertInfoToObject(result) }]));
                        client.quit();
                    }
                    else if (['delete', 'get', 'keys', 'set', 'incr'].includes(operation)) {
                        const items = this.getInputData();
                        const returnItems = [];
                        let item;
                        for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                            item = { json: {} };
                            if (operation === 'delete') {
                                const keyDelete = this.getNodeParameter('key', itemIndex);
                                const clientDel = util.promisify(client.del).bind(client);
                                await clientDel(keyDelete);
                                returnItems.push(items[itemIndex]);
                            }
                            else if (operation === 'get') {
                                const propertyName = this.getNodeParameter('propertyName', itemIndex);
                                const keyGet = this.getNodeParameter('key', itemIndex);
                                const keyType = this.getNodeParameter('keyType', itemIndex);
                                const value = await getValue(client, keyGet, keyType) || null;
                                const options = this.getNodeParameter('options', itemIndex, {});
                                if (options.dotNotation === false) {
                                    item.json[propertyName] = value;
                                }
                                else {
                                    lodash_1.set(item.json, propertyName, value);
                                }
                                returnItems.push(item);
                            }
                            else if (operation === 'keys') {
                                const keyPattern = this.getNodeParameter('keyPattern', itemIndex);
                                const clientKeys = util.promisify(client.keys).bind(client);
                                const keys = await clientKeys(keyPattern);
                                const promises = {};
                                for (const keyName of keys) {
                                    promises[keyName] = await getValue(client, keyName);
                                }
                                for (const keyName of keys) {
                                    item.json[keyName] = await promises[keyName];
                                }
                                returnItems.push(item);
                            }
                            else if (operation === 'set') {
                                const keySet = this.getNodeParameter('key', itemIndex);
                                const value = this.getNodeParameter('value', itemIndex);
                                const keyType = this.getNodeParameter('keyType', itemIndex);
                                const expire = this.getNodeParameter('expire', itemIndex, false);
                                const ttl = this.getNodeParameter('ttl', itemIndex, -1);
                                await setValue(client, keySet, value, expire, ttl, keyType);
                                returnItems.push(items[itemIndex]);
                            }
                            else if (operation === 'incr') {
                                const keyIncr = this.getNodeParameter('key', itemIndex);
                                const expire = this.getNodeParameter('expire', itemIndex, false);
                                const ttl = this.getNodeParameter('ttl', itemIndex, -1);
                                const clientIncr = util.promisify(client.incr).bind(client);
                                const incrementVal = await clientIncr(keyIncr);
                                if (expire === true && ttl > 0) {
                                    const clientExpire = util.promisify(client.expire).bind(client);
                                    await clientExpire(keyIncr, ttl);
                                }
                                returnItems.push({ json: { [keyIncr]: incrementVal } });
                            }
                        }
                        client.quit();
                        resolve(this.prepareOutputData(returnItems));
                    }
                }
                catch (error) {
                    reject(error);
                }
            });
        });
    }
}
exports.Redis = Redis;
//# sourceMappingURL=Redis.node.js.map