"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rabbitmqConnectExchange = exports.rabbitmqConnectQueue = exports.rabbitmqConnect = void 0;
const amqplib = require('amqplib');
async function rabbitmqConnect(options) {
    const credentials = await this.getCredentials('rabbitmq');
    const credentialKeys = [
        'hostname',
        'port',
        'username',
        'password',
        'vhost',
    ];
    const credentialData = {};
    credentialKeys.forEach(key => {
        credentialData[key] = credentials[key] === '' ? undefined : credentials[key];
    });
    const optsData = {};
    if (credentials.ssl === true) {
        credentialData.protocol = 'amqps';
        optsData.ca = credentials.ca === '' ? undefined : [Buffer.from(credentials.ca)];
        if (credentials.passwordless === true) {
            optsData.cert = credentials.cert === '' ? undefined : Buffer.from(credentials.cert);
            optsData.key = credentials.key === '' ? undefined : Buffer.from(credentials.key);
            optsData.passphrase = credentials.passphrase === '' ? undefined : credentials.passphrase;
            optsData.credentials = amqplib.credentials.external();
        }
    }
    return new Promise(async (resolve, reject) => {
        try {
            const connection = await amqplib.connect(credentialData, optsData);
            connection.on('error', (error) => {
                reject(error);
            });
            const channel = await connection.createChannel().catch(console.warn);
            if (options.arguments && options.arguments.argument.length) {
                const additionalArguments = {};
                options.arguments.argument.forEach((argument) => {
                    additionalArguments[argument.key] = argument.value;
                });
                options.arguments = additionalArguments;
            }
            resolve(channel);
        }
        catch (error) {
            reject(error);
        }
    });
}
exports.rabbitmqConnect = rabbitmqConnect;
async function rabbitmqConnectQueue(queue, options) {
    const channel = await rabbitmqConnect.call(this, options);
    return new Promise(async (resolve, reject) => {
        try {
            await channel.assertQueue(queue, options);
            resolve(channel);
        }
        catch (error) {
            reject(error);
        }
    });
}
exports.rabbitmqConnectQueue = rabbitmqConnectQueue;
async function rabbitmqConnectExchange(exchange, type, options) {
    const channel = await rabbitmqConnect.call(this, options);
    return new Promise(async (resolve, reject) => {
        try {
            await channel.assertExchange(exchange, type, options);
            resolve(channel);
        }
        catch (error) {
            reject(error);
        }
    });
}
exports.rabbitmqConnectExchange = rabbitmqConnectExchange;
//# sourceMappingURL=GenericFunctions.js.map