"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.adjustMetadata = exports.setFields = exports.toSnakeCase = exports.setMetadata = exports.getAutomaticSecret = exports.woocommerceApiRequestAllItems = exports.woocommerceApiRequest = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const crypto_1 = require("crypto");
const change_case_1 = require("change-case");
const lodash_1 = require("lodash");
async function woocommerceApiRequest(method, resource, body = {}, qs = {}, uri, option = {}) {
    const credentials = await this.getCredentials('wooCommerceApi');
    if (credentials === undefined) {
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'No credentials got returned!');
    }
    let options = {
        auth: {
            user: credentials.consumerKey,
            password: credentials.consumerSecret,
        },
        method,
        qs,
        body,
        uri: uri || `${credentials.url}/wp-json/wc/v3${resource}`,
        json: true,
    };
    if (credentials.includeCredentialsInQuery === true) {
        delete options.auth;
        Object.assign(qs, { consumer_key: credentials.consumerKey, consumer_secret: credentials.consumerSecret });
    }
    if (!Object.keys(body).length) {
        delete options.form;
    }
    options = Object.assign({}, options, option);
    try {
        return await this.helpers.request(options);
    }
    catch (error) {
        throw new n8n_workflow_1.NodeApiError(this.getNode(), error);
    }
}
exports.woocommerceApiRequest = woocommerceApiRequest;
async function woocommerceApiRequestAllItems(method, endpoint, body = {}, query = {}) {
    const returnData = [];
    let responseData;
    let uri;
    query.per_page = 100;
    do {
        responseData = await woocommerceApiRequest.call(this, method, endpoint, body, query, uri, { resolveWithFullResponse: true });
        uri = responseData.headers['link'].split(';')[0].replace('<', '').replace('>', '');
        returnData.push.apply(returnData, responseData.body);
    } while (responseData.headers['link'] !== undefined &&
        responseData.headers['link'].includes('rel="next"'));
    return returnData;
}
exports.woocommerceApiRequestAllItems = woocommerceApiRequestAllItems;
function getAutomaticSecret(credentials) {
    const data = `${credentials.consumerKey},${credentials.consumerSecret}`;
    return crypto_1.createHash('md5').update(data).digest('hex');
}
exports.getAutomaticSecret = getAutomaticSecret;
function setMetadata(data) {
    for (let i = 0; i < data.length; i++) {
        if (data[i].metadataUi && data[i].metadataUi.metadataValues) {
            data[i].meta_data = data[i].metadataUi.metadataValues;
            delete data[i].metadataUi;
        }
        else {
            delete data[i].metadataUi;
        }
    }
}
exports.setMetadata = setMetadata;
function toSnakeCase(data) {
    if (!Array.isArray(data)) {
        data = [data];
    }
    let remove = false;
    for (let i = 0; i < data.length; i++) {
        for (const key of Object.keys(data[i])) {
            if (data[i][change_case_1.snakeCase(key)] === undefined) {
                remove = true;
            }
            data[i][change_case_1.snakeCase(key)] = data[i][key];
            if (remove) {
                delete data[i][key];
                remove = false;
            }
        }
    }
}
exports.toSnakeCase = toSnakeCase;
function setFields(fieldsToSet, body) {
    for (const fields in fieldsToSet) {
        if (fields === 'tags') {
            body['tags'] = fieldsToSet[fields].map(tag => ({ id: parseInt(tag, 10) }));
        }
        else {
            body[change_case_1.snakeCase(fields.toString())] = fieldsToSet[fields];
        }
    }
}
exports.setFields = setFields;
function adjustMetadata(fields) {
    if (!fields.meta_data)
        return fields;
    return Object.assign(Object.assign({}, lodash_1.omit(fields, ['meta_data'])), { meta_data: fields.meta_data.meta_data_fields });
}
exports.adjustMetadata = adjustMetadata;
//# sourceMappingURL=GenericFunctions.js.map