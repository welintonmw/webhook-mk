"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRawEmail = exports.EmailReadImap = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const imap_simple_1 = require("imap-simple");
const mailparser_1 = require("mailparser");
const lodash = require("lodash");
const n8n_workflow_2 = require("n8n-workflow");
class EmailReadImap {
    constructor() {
        this.description = {
            displayName: 'EmailReadImap',
            name: 'emailReadImap',
            icon: 'fa:inbox',
            group: ['trigger'],
            version: 1,
            description: 'Triggers the workflow when a new email is received',
            defaults: {
                name: 'IMAP Email',
                color: '#44AA22',
            },
            inputs: [],
            outputs: ['main'],
            credentials: [
                {
                    name: 'imap',
                    required: true,
                },
            ],
            properties: [
                {
                    displayName: 'Mailbox Name',
                    name: 'mailbox',
                    type: 'string',
                    default: 'INBOX',
                },
                {
                    displayName: 'Action',
                    name: 'postProcessAction',
                    type: 'options',
                    options: [
                        {
                            name: 'Mark as read',
                            value: 'read',
                        },
                        {
                            name: 'Nothing',
                            value: 'nothing',
                        },
                    ],
                    default: 'read',
                    description: 'What to do after the email has been received. If "nothing" gets selected it will be processed multiple times.',
                },
                {
                    displayName: 'Download Attachments',
                    name: 'downloadAttachments',
                    type: 'boolean',
                    default: false,
                    displayOptions: {
                        show: {
                            format: [
                                'simple',
                            ],
                        },
                    },
                    description: 'If attachments of emails should be downloaded.<br />Only set if needed as it increases processing.',
                },
                {
                    displayName: 'Format',
                    name: 'format',
                    type: 'options',
                    options: [
                        {
                            name: 'RAW',
                            value: 'raw',
                            description: 'Returns the full email message data with body content in the raw field as a base64url encoded string; the payload field is not used.',
                        },
                        {
                            name: 'Resolved',
                            value: 'resolved',
                            description: 'Returns the full email with all data resolved and attachments saved as binary data.',
                        },
                        {
                            name: 'Simple',
                            value: 'simple',
                            description: 'Returns the full email; do not use if you wish to gather inline attachments.',
                        },
                    ],
                    default: 'simple',
                    description: 'The format to return the message in',
                },
                {
                    displayName: 'Property Prefix Name',
                    name: 'dataPropertyAttachmentsPrefixName',
                    type: 'string',
                    default: 'attachment_',
                    displayOptions: {
                        show: {
                            format: [
                                'resolved',
                            ],
                        },
                    },
                    description: 'Prefix for name of the binary property to which to write the attachments. An index starting with 0 will be added.<br />So if name is "attachment_" the first attachment is saved to "attachment_0"',
                },
                {
                    displayName: 'Property Prefix Name',
                    name: 'dataPropertyAttachmentsPrefixName',
                    type: 'string',
                    default: 'attachment_',
                    displayOptions: {
                        show: {
                            format: [
                                'simple',
                            ],
                            downloadAttachments: [
                                true,
                            ],
                        },
                    },
                    description: 'Prefix for name of the binary property to which to write the attachments. An index starting with 0 will be added.<br />So if name is "attachment_" the first attachment is saved to "attachment_0"',
                },
                {
                    displayName: 'Options',
                    name: 'options',
                    type: 'collection',
                    placeholder: 'Add Option',
                    default: {},
                    options: [
                        {
                            displayName: 'Custom email rules',
                            name: 'customEmailConfig',
                            type: 'string',
                            default: '["UNSEEN"]',
                            description: 'Custom email fetching rules. See <a href="https://github.com/mscdex/node-imap">node-imap</a>\'s search function for more details',
                        },
                        {
                            displayName: 'Ignore SSL Issues',
                            name: 'allowUnauthorizedCerts',
                            type: 'boolean',
                            default: false,
                            description: 'Do connect even if SSL certificate validation is not possible.',
                        },
                        {
                            displayName: 'Force reconnect',
                            name: 'forceReconnect',
                            type: 'number',
                            default: 60,
                            description: 'Sets an interval (in minutes) to force a reconnection.',
                        },
                    ],
                },
            ],
        };
    }
    async trigger() {
        const credentials = await this.getCredentials('imap');
        if (credentials === undefined) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'No credentials got returned!');
        }
        const mailbox = this.getNodeParameter('mailbox');
        const postProcessAction = this.getNodeParameter('postProcessAction');
        const options = this.getNodeParameter('options', {});
        const staticData = this.getWorkflowStaticData('node');
        n8n_workflow_2.LoggerProxy.debug('Loaded static data for node "EmailReadImap"', { staticData });
        const getText = async (parts, message, subtype) => {
            if (!message.attributes.struct) {
                return '';
            }
            const textParts = parts.filter((part) => {
                return part.type.toUpperCase() === 'TEXT' && part.subtype.toUpperCase() === subtype.toUpperCase();
            });
            if (textParts.length === 0) {
                return '';
            }
            try {
                return await connection.getPartData(message, textParts[0]);
            }
            catch (_a) {
                return '';
            }
        };
        const getAttachment = async (connection, parts, message) => {
            if (!message.attributes.struct) {
                return [];
            }
            const attachmentParts = parts.filter((part) => {
                return part.disposition && part.disposition.type.toUpperCase() === 'ATTACHMENT';
            });
            const attachmentPromises = [];
            let attachmentPromise;
            for (const attachmentPart of attachmentParts) {
                attachmentPromise = connection.getPartData(message, attachmentPart)
                    .then((partData) => {
                    return this.helpers.prepareBinaryData(partData, attachmentPart.disposition.params.filename);
                });
                attachmentPromises.push(attachmentPromise);
            }
            return Promise.all(attachmentPromises);
        };
        const getNewEmails = async (connection, searchCriteria) => {
            const format = this.getNodeParameter('format', 0);
            let fetchOptions = {};
            if (format === 'simple' || format === 'raw') {
                fetchOptions = {
                    bodies: ['TEXT', 'HEADER'],
                    markSeen: postProcessAction === 'read',
                    struct: true,
                };
            }
            else if (format === 'resolved') {
                fetchOptions = {
                    bodies: [''],
                    markSeen: postProcessAction === 'read',
                    struct: true,
                };
            }
            const results = await connection.search(searchCriteria, fetchOptions);
            const newEmails = [];
            let newEmail, messageHeader, messageBody;
            let attachments;
            let propertyName;
            const topLevelProperties = [
                'cc',
                'date',
                'from',
                'subject',
                'to',
            ];
            if (format === 'resolved') {
                const dataPropertyAttachmentsPrefixName = this.getNodeParameter('dataPropertyAttachmentsPrefixName');
                for (const message of results) {
                    if (staticData.lastMessageUid !== undefined && message.attributes.uid <= staticData.lastMessageUid) {
                        continue;
                    }
                    if (staticData.lastMessageUid === undefined || staticData.lastMessageUid < message.attributes.uid) {
                        staticData.lastMessageUid = message.attributes.uid;
                    }
                    const part = lodash.find(message.parts, { which: '' });
                    if (part === undefined) {
                        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Email part could not be parsed.');
                    }
                    const parsedEmail = await parseRawEmail.call(this, part.body, dataPropertyAttachmentsPrefixName);
                    newEmails.push(parsedEmail);
                }
            }
            else if (format === 'simple') {
                const downloadAttachments = this.getNodeParameter('downloadAttachments');
                let dataPropertyAttachmentsPrefixName = '';
                if (downloadAttachments === true) {
                    dataPropertyAttachmentsPrefixName = this.getNodeParameter('dataPropertyAttachmentsPrefixName');
                }
                for (const message of results) {
                    if (staticData.lastMessageUid !== undefined && message.attributes.uid <= staticData.lastMessageUid) {
                        continue;
                    }
                    if (staticData.lastMessageUid === undefined || staticData.lastMessageUid < message.attributes.uid) {
                        staticData.lastMessageUid = message.attributes.uid;
                    }
                    const parts = imap_simple_1.getParts(message.attributes.struct);
                    newEmail = {
                        json: {
                            textHtml: await getText(parts, message, 'html'),
                            textPlain: await getText(parts, message, 'plain'),
                            metadata: {},
                        },
                    };
                    messageHeader = message.parts.filter((part) => {
                        return part.which === 'HEADER';
                    });
                    messageBody = messageHeader[0].body;
                    for (propertyName of Object.keys(messageBody)) {
                        if (messageBody[propertyName].length) {
                            if (topLevelProperties.includes(propertyName)) {
                                newEmail.json[propertyName] = messageBody[propertyName][0];
                            }
                            else {
                                newEmail.json.metadata[propertyName] = messageBody[propertyName][0];
                            }
                        }
                    }
                    if (downloadAttachments === true) {
                        attachments = await getAttachment(connection, parts, message);
                        if (attachments.length) {
                            newEmail.binary = {};
                            for (let i = 0; i < attachments.length; i++) {
                                newEmail.binary[`${dataPropertyAttachmentsPrefixName}${i}`] = attachments[i];
                            }
                        }
                    }
                    newEmails.push(newEmail);
                }
            }
            else if (format === 'raw') {
                for (const message of results) {
                    if (staticData.lastMessageUid !== undefined && message.attributes.uid <= staticData.lastMessageUid) {
                        continue;
                    }
                    if (staticData.lastMessageUid === undefined || staticData.lastMessageUid < message.attributes.uid) {
                        staticData.lastMessageUid = message.attributes.uid;
                    }
                    const part = lodash.find(message.parts, { which: 'TEXT' });
                    if (part === undefined) {
                        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Email part could not be parsed.');
                    }
                    newEmail = {
                        json: {
                            raw: part.body,
                        },
                    };
                    newEmails.push(newEmail);
                }
            }
            return newEmails;
        };
        const establishConnection = () => {
            const config = {
                imap: {
                    user: credentials.user,
                    password: credentials.password,
                    host: credentials.host,
                    port: credentials.port,
                    tls: credentials.secure,
                    authTimeout: 20000,
                },
                onmail: async () => {
                    if (connection) {
                        let searchCriteria = [
                            'UNSEEN',
                        ];
                        if (options.customEmailConfig !== undefined) {
                            try {
                                searchCriteria = JSON.parse(options.customEmailConfig);
                            }
                            catch (error) {
                                throw new n8n_workflow_1.NodeOperationError(this.getNode(), `Custom email config is not valid JSON.`);
                            }
                        }
                        if (staticData.lastMessageUid !== undefined) {
                            searchCriteria.push(['UID', `${staticData.lastMessageUid}:*`]);
                            n8n_workflow_2.LoggerProxy.debug('Querying for new messages on node "EmailReadImap"', { searchCriteria });
                        }
                        const returnData = await getNewEmails(connection, searchCriteria);
                        if (returnData.length) {
                            this.emit([returnData]);
                        }
                    }
                },
            };
            if (options.allowUnauthorizedCerts === true) {
                config.imap.tlsOptions = {
                    rejectUnauthorized: false,
                };
            }
            return imap_simple_1.connect(config).then(async (conn) => {
                conn.on('error', async (err) => {
                    if (err.code.toUpperCase() === 'ECONNRESET') {
                        n8n_workflow_2.LoggerProxy.verbose('IMAP connection was reset - reconnecting.');
                        connection = await establishConnection();
                        await connection.openBox(mailbox);
                    }
                    throw err;
                });
                return conn;
            });
        };
        let connection = await establishConnection();
        await connection.openBox(mailbox);
        let reconnectionInterval;
        if (options.forceReconnect !== undefined) {
            reconnectionInterval = setInterval(async () => {
                n8n_workflow_2.LoggerProxy.verbose('Forcing reconnection of IMAP node.');
                await connection.end();
                connection = await establishConnection();
                await connection.openBox(mailbox);
            }, options.forceReconnect * 1000 * 60);
        }
        async function closeFunction() {
            if (reconnectionInterval) {
                clearInterval(reconnectionInterval);
            }
            await connection.end();
        }
        return {
            closeFunction,
        };
    }
}
exports.EmailReadImap = EmailReadImap;
async function parseRawEmail(messageEncoded, dataPropertyNameDownload) {
    const responseData = await mailparser_1.simpleParser(messageEncoded);
    const headers = {};
    for (const header of responseData.headerLines) {
        headers[header.key] = header.line;
    }
    responseData.headers = headers;
    responseData.headerLines = undefined;
    const binaryData = {};
    if (responseData.attachments) {
        for (let i = 0; i < responseData.attachments.length; i++) {
            const attachment = responseData.attachments[i];
            binaryData[`${dataPropertyNameDownload}${i}`] = await this.helpers.prepareBinaryData(attachment.content, attachment.filename, attachment.contentType);
        }
        responseData.attachments = undefined;
    }
    return {
        json: responseData,
        binary: Object.keys(binaryData).length ? binaryData : undefined,
    };
}
exports.parseRawEmail = parseRawEmail;
//# sourceMappingURL=EmailReadImap.node.js.map