"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmailReadImapV2 = exports.parseRawEmail = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const imap_1 = require("@n8n/imap");
const mailparser_1 = require("mailparser");
const rfc2047_1 = __importDefault(require("rfc2047"));
const isEmpty_1 = __importDefault(require("lodash/isEmpty"));
const find_1 = __importDefault(require("lodash/find"));
const Imap_credentials_1 = require("../../../credentials/Imap.credentials");
async function parseRawEmail(messageEncoded, dataPropertyNameDownload) {
    const responseData = await (0, mailparser_1.simpleParser)(messageEncoded);
    const headers = {};
    const additionalData = {};
    for (const header of responseData.headerLines) {
        headers[header.key] = header.line;
    }
    additionalData.headers = headers;
    additionalData.headerLines = undefined;
    const binaryData = {};
    if (responseData.attachments) {
        for (let i = 0; i < responseData.attachments.length; i++) {
            const attachment = responseData.attachments[i];
            binaryData[`${dataPropertyNameDownload}${i}`] = await this.helpers.prepareBinaryData(attachment.content, attachment.filename, attachment.contentType);
        }
        additionalData.attachments = undefined;
    }
    return {
        json: { ...responseData, ...additionalData },
        binary: Object.keys(binaryData).length ? binaryData : undefined,
    };
}
exports.parseRawEmail = parseRawEmail;
const versionDescription = {
    displayName: 'Email Trigger (IMAP)',
    name: 'emailReadImap',
    icon: 'fa:inbox',
    group: ['trigger'],
    version: 2,
    description: 'Triggers the workflow when a new email is received',
    eventTriggerDescription: 'Waiting for you to receive an email',
    defaults: {
        name: 'Email Trigger (IMAP)',
        color: '#44AA22',
    },
    triggerPanel: {
        header: '',
        executionsHelp: {
            inactive: "<b>While building your workflow</b>, click the 'listen' button, then send an email to make an event happen. This will trigger an execution, which will show up in this editor.<br /> <br /><b>Once you're happy with your workflow</b>, <a data-key='activate'>activate</a> it. Then every time an email is received, the workflow will execute. These executions will show up in the <a data-key='executions'>executions list</a>, but not in the editor.",
            active: "<b>While building your workflow</b>, click the 'listen' button, then send an email to make an event happen. This will trigger an execution, which will show up in this editor.<br /> <br /><b>Your workflow will also execute automatically</b>, since it's activated. Every time an email is received, this node will trigger an execution. These executions will show up in the <a data-key='executions'>executions list</a>, but not in the editor.",
        },
        activationHint: "Once you’ve finished building your workflow, <a data-key='activate'>activate</a> it to have it also listen continuously (you just won’t see those executions here).",
    },
    inputs: [],
    outputs: ['main'],
    credentials: [
        {
            name: 'imap',
            required: true,
            testedBy: 'imapConnectionTest',
        },
    ],
    properties: [
        {
            displayName: 'Mailbox Name',
            name: 'mailbox',
            type: 'string',
            default: 'INBOX',
        },
        {
            displayName: 'Action',
            name: 'postProcessAction',
            type: 'options',
            options: [
                {
                    name: 'Mark as Read',
                    value: 'read',
                },
                {
                    name: 'Nothing',
                    value: 'nothing',
                },
            ],
            default: 'read',
            description: 'What to do after the email has been received. If "nothing" gets selected it will be processed multiple times.',
        },
        {
            displayName: 'Download Attachments',
            name: 'downloadAttachments',
            type: 'boolean',
            default: false,
            displayOptions: {
                show: {
                    format: ['simple'],
                },
            },
            description: 'Whether attachments of emails should be downloaded. Only set if needed as it increases processing.',
        },
        {
            displayName: 'Format',
            name: 'format',
            type: 'options',
            options: [
                {
                    name: 'RAW',
                    value: 'raw',
                    description: 'Returns the full email message data with body content in the raw field as a base64url encoded string; the payload field is not used',
                },
                {
                    name: 'Resolved',
                    value: 'resolved',
                    description: 'Returns the full email with all data resolved and attachments saved as binary data',
                },
                {
                    name: 'Simple',
                    value: 'simple',
                    description: 'Returns the full email; do not use if you wish to gather inline attachments',
                },
            ],
            default: 'simple',
            description: 'The format to return the message in',
        },
        {
            displayName: 'Property Prefix Name',
            name: 'dataPropertyAttachmentsPrefixName',
            type: 'string',
            default: 'attachment_',
            displayOptions: {
                show: {
                    format: ['resolved'],
                },
            },
            description: 'Prefix for name of the binary property to which to write the attachments. An index starting with 0 will be added. So if name is "attachment_" the first attachment is saved to "attachment_0"',
        },
        {
            displayName: 'Property Prefix Name',
            name: 'dataPropertyAttachmentsPrefixName',
            type: 'string',
            default: 'attachment_',
            displayOptions: {
                show: {
                    format: ['simple'],
                    downloadAttachments: [true],
                },
            },
            description: 'Prefix for name of the binary property to which to write the attachments. An index starting with 0 will be added. So if name is "attachment_" the first attachment is saved to "attachment_0"',
        },
        {
            displayName: 'Options',
            name: 'options',
            type: 'collection',
            placeholder: 'Add Option',
            default: {},
            options: [
                {
                    displayName: 'Custom Email Rules',
                    name: 'customEmailConfig',
                    type: 'string',
                    default: '["UNSEEN"]',
                    description: 'Custom email fetching rules. See <a href="https://github.com/mscdex/node-imap">node-imap</a>\'s search function for more details.',
                },
                {
                    displayName: 'Force Reconnect Every Minutes',
                    name: 'forceReconnect',
                    type: 'number',
                    default: 60,
                    description: 'Sets an interval (in minutes) to force a reconnection',
                },
            ],
        },
    ],
};
class EmailReadImapV2 {
    constructor(baseDescription) {
        this.methods = {
            credentialTest: {
                async imapConnectionTest(credential) {
                    if ((0, Imap_credentials_1.isCredentialsDataImap)(credential.data)) {
                        const credentials = credential.data;
                        try {
                            const config = {
                                imap: {
                                    user: credentials.user,
                                    password: credentials.password,
                                    host: credentials.host.trim(),
                                    port: credentials.port,
                                    tls: credentials.secure,
                                    authTimeout: 20000,
                                },
                            };
                            const tlsOptions = {};
                            if (credentials.allowUnauthorizedCerts) {
                                tlsOptions.rejectUnauthorized = false;
                            }
                            if (credentials.secure) {
                                tlsOptions.servername = credentials.host.trim();
                            }
                            if (!(0, isEmpty_1.default)(tlsOptions)) {
                                config.imap.tlsOptions = tlsOptions;
                            }
                            const connection = await (0, imap_1.connect)(config);
                            await connection.getBoxes();
                            connection.end();
                        }
                        catch (error) {
                            return {
                                status: 'Error',
                                message: error.message,
                            };
                        }
                        return {
                            status: 'OK',
                            message: 'Connection successful!',
                        };
                    }
                    else {
                        return {
                            status: 'Error',
                            message: 'Credentials are no IMAP credentials.',
                        };
                    }
                },
            },
        };
        this.description = {
            ...baseDescription,
            ...versionDescription,
        };
    }
    async trigger() {
        const credentialsObject = await this.getCredentials('imap');
        const credentials = (0, Imap_credentials_1.isCredentialsDataImap)(credentialsObject) ? credentialsObject : undefined;
        if (!credentials) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Credentials are not valid for imap node.');
        }
        const mailbox = this.getNodeParameter('mailbox');
        const postProcessAction = this.getNodeParameter('postProcessAction');
        const options = this.getNodeParameter('options', {});
        const staticData = this.getWorkflowStaticData('node');
        this.logger.debug('Loaded static data for node "EmailReadImap"', { staticData });
        let connection;
        let closeFunctionWasCalled = false;
        let isCurrentlyReconnecting = false;
        const getText = async (parts, message, subtype) => {
            if (!message.attributes.struct) {
                return '';
            }
            const textParts = parts.filter((part) => {
                return (part.type.toUpperCase() === 'TEXT' && part.subtype.toUpperCase() === subtype.toUpperCase());
            });
            const part = textParts[0];
            if (!part) {
                return '';
            }
            try {
                const partData = await connection.getPartData(message, part);
                return partData.toString();
            }
            catch {
                return '';
            }
        };
        const getAttachment = async (imapConnection, parts, message) => {
            if (!message.attributes.struct) {
                return [];
            }
            const attachmentParts = parts.filter((part) => { var _a, _b; return ((_b = (_a = part.disposition) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.toUpperCase()) === 'ATTACHMENT'; });
            const decodeFilename = (filename) => {
                const regex = /=\?([\w-]+)\?Q\?.*\?=/i;
                if (regex.test(filename)) {
                    return rfc2047_1.default.decode(filename);
                }
                return filename;
            };
            const attachmentPromises = [];
            let attachmentPromise;
            for (const attachmentPart of attachmentParts) {
                attachmentPromise = imapConnection
                    .getPartData(message, attachmentPart)
                    .then(async (partData) => {
                    var _a, _b;
                    const fileName = decodeFilename((_b = (_a = attachmentPart.disposition) === null || _a === void 0 ? void 0 : _a.params) === null || _b === void 0 ? void 0 : _b.filename);
                    return await this.helpers.prepareBinaryData(partData.buffer, fileName);
                });
                attachmentPromises.push(attachmentPromise);
            }
            return await Promise.all(attachmentPromises);
        };
        const getNewEmails = async (imapConnection, searchCriteria) => {
            const format = this.getNodeParameter('format', 0);
            let fetchOptions = {};
            if (format === 'simple' || format === 'raw') {
                fetchOptions = {
                    bodies: ['TEXT', 'HEADER'],
                    markSeen: false,
                    struct: true,
                };
            }
            else if (format === 'resolved') {
                fetchOptions = {
                    bodies: [''],
                    markSeen: false,
                    struct: true,
                };
            }
            const results = await imapConnection.search(searchCriteria, fetchOptions);
            const newEmails = [];
            let newEmail;
            let attachments;
            let propertyName;
            const topLevelProperties = ['cc', 'date', 'from', 'subject', 'to'];
            if (format === 'resolved') {
                const dataPropertyAttachmentsPrefixName = this.getNodeParameter('dataPropertyAttachmentsPrefixName');
                for (const message of results) {
                    if (staticData.lastMessageUid !== undefined &&
                        message.attributes.uid <= staticData.lastMessageUid) {
                        continue;
                    }
                    if (staticData.lastMessageUid === undefined ||
                        staticData.lastMessageUid < message.attributes.uid) {
                        staticData.lastMessageUid = message.attributes.uid;
                    }
                    const part = (0, find_1.default)(message.parts, { which: '' });
                    if (part === undefined) {
                        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Email part could not be parsed.');
                    }
                    const parsedEmail = await parseRawEmail.call(this, part.body, dataPropertyAttachmentsPrefixName);
                    newEmails.push(parsedEmail);
                }
            }
            else if (format === 'simple') {
                const downloadAttachments = this.getNodeParameter('downloadAttachments');
                let dataPropertyAttachmentsPrefixName = '';
                if (downloadAttachments) {
                    dataPropertyAttachmentsPrefixName = this.getNodeParameter('dataPropertyAttachmentsPrefixName');
                }
                for (const message of results) {
                    if (staticData.lastMessageUid !== undefined &&
                        message.attributes.uid <= staticData.lastMessageUid) {
                        continue;
                    }
                    if (staticData.lastMessageUid === undefined ||
                        staticData.lastMessageUid < message.attributes.uid) {
                        staticData.lastMessageUid = message.attributes.uid;
                    }
                    const parts = (0, imap_1.getParts)(message.attributes.struct);
                    newEmail = {
                        json: {
                            textHtml: await getText(parts, message, 'html'),
                            textPlain: await getText(parts, message, 'plain'),
                            metadata: {},
                        },
                    };
                    const messageHeader = message.parts.filter((part) => part.which === 'HEADER');
                    const messageBody = messageHeader[0].body;
                    for (propertyName of Object.keys(messageBody)) {
                        if (messageBody[propertyName].length) {
                            if (topLevelProperties.includes(propertyName)) {
                                newEmail.json[propertyName] = messageBody[propertyName][0];
                            }
                            else {
                                newEmail.json.metadata[propertyName] =
                                    messageBody[propertyName][0];
                            }
                        }
                    }
                    if (downloadAttachments) {
                        attachments = await getAttachment(imapConnection, parts, message);
                        if (attachments.length) {
                            newEmail.binary = {};
                            for (let i = 0; i < attachments.length; i++) {
                                newEmail.binary[`${dataPropertyAttachmentsPrefixName}${i}`] = attachments[i];
                            }
                        }
                    }
                    newEmails.push(newEmail);
                }
            }
            else if (format === 'raw') {
                for (const message of results) {
                    if (staticData.lastMessageUid !== undefined &&
                        message.attributes.uid <= staticData.lastMessageUid) {
                        continue;
                    }
                    if (staticData.lastMessageUid === undefined ||
                        staticData.lastMessageUid < message.attributes.uid) {
                        staticData.lastMessageUid = message.attributes.uid;
                    }
                    const part = (0, find_1.default)(message.parts, { which: 'TEXT' });
                    if (part === undefined) {
                        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Email part could not be parsed.');
                    }
                    newEmail = {
                        json: {
                            raw: part.body,
                        },
                    };
                    newEmails.push(newEmail);
                }
            }
            if (postProcessAction === 'read') {
                const uidList = results.map((e) => e.attributes.uid);
                if (uidList.length > 0) {
                    await imapConnection.addFlags(uidList, '\\SEEN');
                }
            }
            return newEmails;
        };
        const returnedPromise = await this.helpers.createDeferredPromise();
        const establishConnection = async () => {
            let searchCriteria = ['UNSEEN'];
            if (options.customEmailConfig !== undefined) {
                try {
                    searchCriteria = JSON.parse(options.customEmailConfig);
                }
                catch (error) {
                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Custom email config is not valid JSON.');
                }
            }
            const config = {
                imap: {
                    user: credentials.user,
                    password: credentials.password,
                    host: credentials.host.trim(),
                    port: credentials.port,
                    tls: credentials.secure,
                    authTimeout: 20000,
                },
                onMail: async () => {
                    if (connection) {
                        if (staticData.lastMessageUid !== undefined) {
                            searchCriteria.push(['UID', `${staticData.lastMessageUid}:*`]);
                            this.logger.debug('Querying for new messages on node "EmailReadImap"', {
                                searchCriteria,
                            });
                        }
                        try {
                            const returnData = await getNewEmails(connection, searchCriteria);
                            if (returnData.length) {
                                this.emit([returnData]);
                            }
                        }
                        catch (error) {
                            this.logger.error('Email Read Imap node encountered an error fetching new emails', {
                                error: error,
                            });
                            await returnedPromise.promise().then(() => {
                                this.emitError(error);
                            });
                        }
                    }
                },
                onUpdate: async (seqNo, info) => {
                    this.logger.verbose(`Email Read Imap:update ${seqNo}`, info);
                },
            };
            const tlsOptions = {};
            if (credentials.allowUnauthorizedCerts) {
                tlsOptions.rejectUnauthorized = false;
            }
            if (credentials.secure) {
                tlsOptions.servername = credentials.host.trim();
            }
            if (!(0, isEmpty_1.default)(tlsOptions)) {
                config.imap.tlsOptions = tlsOptions;
            }
            return await (0, imap_1.connect)(config).then(async (conn) => {
                conn.on('close', async (_hadError) => {
                    if (isCurrentlyReconnecting) {
                        this.logger.debug('Email Read Imap: Connected closed for forced reconnecting');
                    }
                    else if (closeFunctionWasCalled) {
                        this.logger.debug('Email Read Imap: Shutting down workflow - connected closed');
                    }
                    else {
                        this.logger.error('Email Read Imap: Connected closed unexpectedly');
                        this.emitError(new Error('Imap connection closed unexpectedly'));
                    }
                });
                conn.on('error', async (error) => {
                    const errorCode = error.code.toUpperCase();
                    this.logger.verbose(`IMAP connection experienced an error: (${errorCode})`, {
                        error: error,
                    });
                    await closeFunction();
                    this.emitError(error);
                });
                return conn;
            });
        };
        connection = await establishConnection();
        await connection.openBox(mailbox);
        let reconnectionInterval;
        const handleReconnect = async () => {
            this.logger.verbose('Forcing reconnect to IMAP server');
            try {
                isCurrentlyReconnecting = true;
                if (connection.closeBox)
                    await connection.closeBox(false);
                connection.end();
                connection = await establishConnection();
                await connection.openBox(mailbox);
            }
            catch (error) {
                this.logger.error(error);
            }
            finally {
                isCurrentlyReconnecting = false;
            }
        };
        if (options.forceReconnect !== undefined) {
            reconnectionInterval = setInterval(handleReconnect, options.forceReconnect * 1000 * 60);
        }
        async function closeFunction() {
            closeFunctionWasCalled = true;
            if (reconnectionInterval) {
                clearInterval(reconnectionInterval);
            }
            if (connection.closeBox)
                await connection.closeBox(false);
            connection.end();
        }
        returnedPromise.resolve();
        return {
            closeFunction,
        };
    }
}
exports.EmailReadImapV2 = EmailReadImapV2;
//# sourceMappingURL=EmailReadImapV2.node.js.map