"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConditions = exports.getFormattedChildren = exports.simplifyObjects = exports.simplifyProperties = exports.mapFilters = exports.mapSorting = exports.mapProperties = exports.formatBlocks = exports.formatText = exports.formatTitle = exports.getBlockTypes = exports.notionApiRequestAllItems = exports.notionApiRequest = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const change_case_1 = require("change-case");
const moment = require("moment-timezone");
const uuid_1 = require("uuid");
async function notionApiRequest(method, resource, body = {}, qs = {}, uri, option = {}) {
    try {
        let options = {
            headers: {
                'Notion-Version': '2021-05-13',
            },
            method,
            qs,
            body,
            uri: uri || `https://api.notion.com/v1${resource}`,
            json: true,
        };
        options = Object.assign({}, options, option);
        const credentials = await this.getCredentials('notionApi');
        options.headers['Authorization'] = `Bearer ${credentials.apiKey}`;
        return this.helpers.request(options);
    }
    catch (error) {
        throw new n8n_workflow_1.NodeApiError(this.getNode(), error);
    }
}
exports.notionApiRequest = notionApiRequest;
async function notionApiRequestAllItems(propertyName, method, endpoint, body = {}, query = {}) {
    const resource = this.getNodeParameter('resource', 0);
    const returnData = [];
    let responseData;
    do {
        responseData = await notionApiRequest.call(this, method, endpoint, body, query);
        const { next_cursor } = responseData;
        if (resource === 'block' || resource === 'user') {
            query['start_cursor'] = next_cursor;
        }
        else {
            body['start_cursor'] = next_cursor;
        }
        returnData.push.apply(returnData, responseData[propertyName]);
        if (query.limit && query.limit <= returnData.length) {
            return returnData;
        }
    } while (responseData.has_more !== false);
    return returnData;
}
exports.notionApiRequestAllItems = notionApiRequestAllItems;
function getBlockTypes() {
    return [
        {
            name: 'Paragraph',
            value: 'paragraph',
        },
        {
            name: 'Heading 1',
            value: 'heading_1',
        },
        {
            name: 'Heading 2',
            value: 'heading_2',
        },
        {
            name: 'Heading 3',
            value: 'heading_3',
        },
        {
            name: 'Toggle',
            value: 'toggle',
        },
        {
            name: 'To-Do',
            value: 'to_do',
        },
        {
            name: 'Bulleted List Item',
            value: 'bulleted_list_item',
        },
        {
            name: 'Numbered List Item',
            value: 'numbered_list_item',
        },
    ];
}
exports.getBlockTypes = getBlockTypes;
function textContent(content) {
    return {
        text: {
            content,
        },
    };
}
function formatTitle(content) {
    return {
        title: [
            textContent(content),
        ],
    };
}
exports.formatTitle = formatTitle;
function formatText(content) {
    return {
        text: [
            textContent(content),
        ],
    };
}
exports.formatText = formatText;
function getLink(text) {
    if (text.isLink === true && text.textLink !== '') {
        return {
            link: {
                url: text.textLink,
            },
        };
    }
    return {};
}
function getTexts(texts) {
    const results = [];
    for (const text of texts) {
        if (text.textType === 'text') {
            results.push({
                type: 'text',
                text: Object.assign({ content: text.text }, getLink(text)),
                annotations: text.annotationUi,
            });
        }
        else if (text.textType === 'mention') {
            if (text.mentionType === 'date') {
                results.push({
                    type: 'mention',
                    mention: {
                        type: text.mentionType,
                        [text.mentionType]: (text.range === true)
                            ? { start: text.dateStart, end: text.dateEnd }
                            : { start: text.date, end: null },
                    },
                    annotations: text.annotationUi,
                });
            }
            else {
                results.push({
                    type: 'mention',
                    mention: {
                        type: text.mentionType,
                        [text.mentionType]: { id: text[text.mentionType] },
                    },
                    annotations: text.annotationUi,
                });
            }
        }
        else if (text.textType === 'equation') {
            results.push({
                type: 'equation',
                equation: {
                    expression: text.expression,
                },
                annotations: text.annotationUi,
            });
        }
    }
    return results;
}
function formatBlocks(blocks) {
    const results = [];
    for (const block of blocks) {
        results.push({
            object: 'block',
            type: block.type,
            [block.type]: Object.assign(Object.assign({}, (block.type === 'to_do') ? { checked: block.checked } : { checked: false }), { text: (block.richText === false) ? formatText(block.textContent).text : getTexts(block.text.text || []) }),
        });
    }
    return results;
}
exports.formatBlocks = formatBlocks;
function getPropertyKeyValue(value, type, timezone) {
    let result = {};
    switch (type) {
        case 'rich_text':
            if (value.richText === false) {
                result = { rich_text: [{ text: { content: value.textContent } }] };
            }
            else {
                result = { rich_text: getTexts(value.text.text) };
            }
            break;
        case 'title':
            result = { title: [{ text: { content: value.title } }] };
            break;
        case 'number':
            result = { type: 'number', number: value.numberValue };
            break;
        case 'url':
            result = { type: 'url', url: value.urlValue };
            break;
        case 'checkbox':
            result = { type: 'checkbox', checkbox: value.checkboxValue };
            break;
        case 'relation':
            result = {
                type: 'relation', relation: (value.relationValue).reduce((acc, cur) => {
                    return acc.concat(cur.split(',').map((relation) => ({ id: relation })));
                }, []),
            };
            break;
        case 'multi_select':
            const multiSelectValue = value.multiSelectValue;
            result = {
                type: 'multi_select',
                multi_select: (Array.isArray(multiSelectValue) ? multiSelectValue : multiSelectValue.split(',').map((v) => v.trim()))
                    .filter((value) => value !== null)
                    .map((option) => ((!uuid_1.validate(option)) ? { name: option } : { id: option })),
            };
            break;
        case 'email':
            result = {
                type: 'email', email: value.emailValue,
            };
            break;
        case 'people':
            result = {
                type: 'people', people: value.peopleValue.map((option) => ({ id: option })),
            };
            break;
        case 'phone_number':
            result = {
                type: 'phone_number', phone_number: value.phoneValue,
            };
            break;
        case 'select':
            result = {
                type: 'select', select: { id: value.selectValue },
            };
            break;
        case 'date':
            const format = getDateFormat(value.includeTime);
            const timezoneValue = (value.timezone === 'default') ? timezone : value.timezone;
            if (value.range === true) {
                result = {
                    type: 'date',
                    date: {
                        start: moment.tz(value.dateStart, timezoneValue).format(format),
                        end: moment.tz(value.dateEnd, timezoneValue).format(format),
                    },
                };
            }
            else {
                result = {
                    type: 'date',
                    date: {
                        start: moment.tz(value.date, timezoneValue).format(format),
                        end: null,
                    },
                };
            }
            break;
        default:
    }
    return result;
}
function getDateFormat(includeTime) {
    if (includeTime === false) {
        return 'yyyy-MM-DD';
    }
    return '';
}
function getNameAndType(key) {
    const [name, type] = key.split('|');
    return {
        name,
        type,
    };
}
function mapProperties(properties, timezone) {
    return properties.reduce((obj, value) => Object.assign(obj, {
        [`${value.key.split('|')[0]}`]: getPropertyKeyValue(value, value.key.split('|')[1], timezone),
    }), {});
}
exports.mapProperties = mapProperties;
function mapSorting(data) {
    return data.map((sort) => {
        return {
            direction: sort.direction,
            [(sort.timestamp) ? 'timestamp' : 'property']: sort.key.split('|')[0],
        };
    });
}
exports.mapSorting = mapSorting;
function mapFilters(filters, timezone) {
    return filters.reduce((obj, value) => {
        let key = getNameAndType(value.key).type;
        let valuePropertyName = key === 'last_edited_time'
            ? value[change_case_1.camelCase(key)]
            : value[`${change_case_1.camelCase(key)}Value`];
        if (['is_empty', 'is_not_empty'].includes(value.condition)) {
            valuePropertyName = true;
        }
        else if (['past_week', 'past_month', 'past_year', 'next_week', 'next_month', 'next_year'].includes(value.condition)) {
            valuePropertyName = {};
        }
        if (key === 'rich_text') {
            key = 'text';
        }
        else if (key === 'phone_number') {
            key = 'phone';
        }
        else if (key === 'date' && !['is_empty', 'is_not_empty'].includes(value.condition)) {
            valuePropertyName = (valuePropertyName !== undefined && !Object.keys(valuePropertyName).length) ? {} : moment.tz(value.date, timezone).utc().format();
        }
        return Object.assign(obj, {
            ['property']: getNameAndType(value.key).name,
            [key]: { [`${value.condition}`]: valuePropertyName },
        });
    }, {});
}
exports.mapFilters = mapFilters;
function simplifyProperties(properties) {
    const results = {};
    for (const key of Object.keys(properties)) {
        const type = properties[key].type;
        if (['text'].includes(properties[key].type)) {
            const texts = properties[key].text.map((e) => e.plain_text || {}).join('');
            results[`${key}`] = texts;
        }
        else if (['rich_text'].includes(properties[key].type)) {
            const texts = properties[key].rich_text.map((e) => e.plain_text || {}).join('');
            results[`${key}`] = texts;
        }
        else if (['url', 'created_time', 'checkbox', 'number', 'last_edited_time', 'email', 'phone_number', 'date'].includes(properties[key].type)) {
            results[`${key}`] = properties[key][type];
        }
        else if (['title'].includes(properties[key].type)) {
            if (Array.isArray(properties[key][type]) && properties[key][type].length !== 0) {
                results[`${key}`] = properties[key][type][0].plain_text;
            }
            else {
                results[`${key}`] = '';
            }
        }
        else if (['created_by', 'last_edited_by', 'select'].includes(properties[key].type)) {
            results[`${key}`] = properties[key][type].name;
        }
        else if (['people'].includes(properties[key].type)) {
            if (Array.isArray(properties[key][type])) {
                results[`${key}`] = properties[key][type].map((person) => person.person.email || {});
            }
            else {
                results[`${key}`] = properties[key][type];
            }
        }
        else if (['multi_select'].includes(properties[key].type)) {
            if (Array.isArray(properties[key][type])) {
                results[`${key}`] = properties[key][type].map((e) => e.name || {});
            }
            else {
                results[`${key}`] = properties[key][type].options.map((e) => e.name || {});
            }
        }
        else if (['relation'].includes(properties[key].type)) {
            if (Array.isArray(properties[key][type])) {
                results[`${key}`] = properties[key][type].map((e) => e.id || {});
            }
            else {
                results[`${key}`] = properties[key][type].database_id;
            }
        }
        else if (['formula'].includes(properties[key].type)) {
            results[`${key}`] = properties[key][type][properties[key][type].type];
        }
        else if (['rollup'].includes(properties[key].type)) {
        }
    }
    return results;
}
exports.simplifyProperties = simplifyProperties;
function simplifyObjects(objects) {
    if (!Array.isArray(objects)) {
        objects = [objects];
    }
    const results = [];
    for (const { object, id, properties, parent, title } of objects) {
        if (object === 'page' && (parent.type === 'page_id' || parent.type === 'workspace')) {
            results.push({
                id,
                title: properties.title.title[0].plain_text,
            });
        }
        else if (object === 'page' && parent.type === 'database_id') {
            results.push(Object.assign({ id }, simplifyProperties(properties)));
        }
        else if (object === 'database') {
            results.push({
                id,
                title: title[0].plain_text,
            });
        }
    }
    return results;
}
exports.simplifyObjects = simplifyObjects;
function getFormattedChildren(children) {
    const results = [];
    for (const child of children) {
        const type = child.type;
        results.push({ [`${type}`]: child, object: 'block', type });
    }
    return results;
}
exports.getFormattedChildren = getFormattedChildren;
function getConditions() {
    const elements = [];
    const types = {
        title: 'rich_text',
        rich_text: 'rich_text',
        number: 'number',
        checkbox: 'checkbox',
        select: 'select',
        multi_select: 'multi_select',
        date: 'date',
        people: 'people',
        files: 'files',
        url: 'rich_text',
        email: 'rich_text',
        phone_number: 'rich_text',
        relation: 'relation',
        created_by: 'people',
        created_time: 'date',
        last_edited_by: 'people',
        last_edited_time: 'date',
    };
    const typeConditions = {
        rich_text: [
            'equals',
            'does_not_equal',
            'contains',
            'does_not_contain',
            'starts_with',
            'ends_with',
            'is_empty',
            'is_not_empty',
        ],
        number: [
            'equals',
            'does_not_equal',
            'grater_than',
            'less_than',
            'greater_than_or_equal_to',
            'less_than_or_equal_to',
            'is_empty',
            'is_not_empty',
        ],
        checkbox: [
            'equals',
            'does_not_equal',
        ],
        select: [
            'equals',
            'does_not_equal',
            'is_empty',
            'is_not_empty',
        ],
        multi_select: [
            'contains',
            'does_not_equal',
            'is_empty',
            'is_not_empty',
        ],
        date: [
            'equals',
            'before',
            'after',
            'on_or_before',
            'is_empty',
            'is_not_empty',
            'on_or_after',
            'past_week',
            'past_month',
            'past_year',
            'next_week',
            'next_month',
            'next_year',
        ],
        people: [
            'contains',
            'does_not_contain',
            'is_empty',
            'is_not_empty',
        ],
        files: [
            'is_empty',
            'is_not_empty',
        ],
        relation: [
            'contains',
            'does_not_contain',
            'is_empty',
            'is_not_empty',
        ],
        formula: [
            'contains',
            'does_not_contain',
            'is_empty',
            'is_not_empty',
        ],
    };
    for (const type of Object.keys(types)) {
        elements.push({
            displayName: 'Condition',
            name: 'condition',
            type: 'options',
            displayOptions: {
                show: {
                    type: [
                        type,
                    ],
                },
            },
            options: typeConditions[types[type]].map((type) => ({ name: change_case_1.capitalCase(type), value: type })),
            default: '',
            description: 'The value of the property to filter by.',
        });
    }
    return elements;
}
exports.getConditions = getConditions;
//# sourceMappingURL=GenericFunctions.js.map