"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadForms = exports.downloadAttachments = exports.formatSubmission = exports.parseStringList = exports.koBoToolboxRawRequest = exports.koBoToolboxApiRequest = void 0;
const set_1 = __importDefault(require("lodash/set"));
const concat_1 = __importDefault(require("lodash/concat"));
const split_1 = __importDefault(require("lodash/split"));
const every_1 = __importDefault(require("lodash/every"));
const toString_1 = __importDefault(require("lodash/toString"));
const toNumber_1 = __importDefault(require("lodash/toNumber"));
const isString_1 = __importDefault(require("lodash/isString"));
const compact_1 = __importDefault(require("lodash/compact"));
const first_1 = __importDefault(require("lodash/first"));
const last_1 = __importDefault(require("lodash/last"));
const clone_1 = __importDefault(require("lodash/clone"));
const some_1 = __importDefault(require("lodash/some"));
const isArray_1 = __importDefault(require("lodash/isArray"));
const trim_1 = __importDefault(require("lodash/trim"));
const escapeRegExp_1 = __importDefault(require("lodash/escapeRegExp"));
async function koBoToolboxApiRequest(option = {}) {
    const credentials = await this.getCredentials('koBoToolboxApi');
    const returnAll = !!option.returnAll;
    if (returnAll) {
        (0, set_1.default)(option, 'qs.limit', 3000);
        delete option.returnAll;
    }
    const options = {
        url: '',
        headers: {
            Accept: 'application/json',
        },
        json: true,
    };
    if (Object.keys(option)) {
        Object.assign(options, option);
    }
    if (options.url && !/^http(s)?:/.test(options.url)) {
        options.url = credentials.URL + options.url;
    }
    let results = null;
    let keepLooking = true;
    while (keepLooking) {
        const response = await this.helpers.httpRequestWithAuthentication.call(this, 'koBoToolboxApi', options);
        results = response.results ? (0, concat_1.default)(results || [], response.results) : response;
        if (returnAll && response.next) {
            options.url = response.next;
        }
        else {
            keepLooking = false;
        }
    }
    return results;
}
exports.koBoToolboxApiRequest = koBoToolboxApiRequest;
async function koBoToolboxRawRequest(option) {
    const credentials = await this.getCredentials('koBoToolboxApi');
    if (option.url && !/^http(s)?:/.test(option.url)) {
        option.url = credentials.URL + option.url;
    }
    return await this.helpers.httpRequestWithAuthentication.call(this, 'koBoToolboxApi', option);
}
exports.koBoToolboxRawRequest = koBoToolboxRawRequest;
function parseGeoPoint(geoPoint) {
    const coordinates = (0, split_1.default)(geoPoint, ' ');
    if (coordinates.length >= 2 &&
        (0, every_1.default)(coordinates, (coord) => coord && /^-?\d+(?:\.\d+)?$/.test((0, toString_1.default)(coord)))) {
        return [(0, toNumber_1.default)(coordinates[1]), (0, toNumber_1.default)(coordinates[0])];
    }
    return null;
}
function parseStringList(value) {
    return (0, split_1.default)((0, toString_1.default)(value), /[\s,]+/);
}
exports.parseStringList = parseStringList;
const matchWildcard = (value, pattern) => {
    const regex = new RegExp(`^${(0, escapeRegExp_1.default)(pattern).replace('\\*', '.*')}$`);
    return regex.test(value);
};
const formatValue = (value, format) => {
    if ((0, isString_1.default)(value)) {
        value = (0, toString_1.default)(value);
        const geoPoint = parseGeoPoint(value);
        if (geoPoint) {
            return {
                type: 'Point',
                coordinates: geoPoint,
            };
        }
        const points = value.split(';');
        if (points.length >= 2 && /^[-\d\.\s;]+$/.test(value)) {
            const coordinates = (0, compact_1.default)(points.map(parseGeoPoint));
            if (coordinates.length === points.length) {
                if ((0, first_1.default)(points) === (0, last_1.default)(points)) {
                    return {
                        type: 'Polygon',
                        coordinates: [coordinates],
                    };
                }
                return { type: 'LineString', coordinates };
            }
        }
        if ('number' === format) {
            return (0, toNumber_1.default)(value);
        }
        if ('multiSelect' === format) {
            return (0, split_1.default)((0, toString_1.default)(value), ' ');
        }
    }
    return value;
};
function formatSubmission(submission, selectMasks = [], numberMasks = []) {
    const response = {};
    for (const key of Object.keys(submission)) {
        let value = (0, clone_1.default)(submission[key]);
        const sanitizedKey = key
            .split('/')
            .map((k) => (0, trim_1.default)(k, ' _'))
            .join('.');
        const leafKey = sanitizedKey.split('.').pop() || '';
        let format = 'string';
        if ((0, some_1.default)(numberMasks, (mask) => matchWildcard(leafKey, mask))) {
            format = 'number';
        }
        if ((0, some_1.default)(selectMasks, (mask) => matchWildcard(leafKey, mask))) {
            format = 'multiSelect';
        }
        value = formatValue(value, format);
        (0, set_1.default)(response, sanitizedKey, value);
    }
    if ((0, isArray_1.default)(response.geolocation) &&
        response.geolocation.length === 2 &&
        response.geolocation[0] &&
        response.geolocation[1]) {
        response.geolocation = {
            type: 'Point',
            coordinates: [response.geolocation[1], response.geolocation[0]],
        };
    }
    return response;
}
exports.formatSubmission = formatSubmission;
async function downloadAttachments(submission, options) {
    const binaryItem = {
        json: {
            ...submission,
        },
        binary: {},
    };
    const credentials = await this.getCredentials('koBoToolboxApi');
    const attachmentList = (submission._attachments || submission.attachments);
    if (attachmentList === null || attachmentList === void 0 ? void 0 : attachmentList.length) {
        for (const [index, attachment] of attachmentList.entries()) {
            const fileName = attachment.filename;
            const sanitizedFileName = (0, toString_1.default)(fileName).replace(/_[^_]+(?=\.\w+)/, '');
            let relatedQuestion = null;
            if ('question' === options.binaryNamingScheme) {
                for (const question of Object.keys(submission)) {
                    const sanitizedQuestionValue = (0, toString_1.default)(submission[question]).replace(/\s/g, '_');
                    if (sanitizedFileName === sanitizedQuestionValue) {
                        relatedQuestion = question;
                        break;
                    }
                }
            }
            let response = null;
            const attachmentUrl = attachment[options.version] || attachment.download_url;
            let final = false, redir = 0;
            const axiosOptions = {
                url: attachmentUrl,
                method: 'GET',
                headers: {
                    Authorization: `Token ${credentials.token}`,
                },
                ignoreHttpStatusErrors: true,
                returnFullResponse: true,
                disableFollowRedirect: true,
                encoding: 'arraybuffer',
            };
            while (!final && redir < 5) {
                response = await this.helpers.httpRequest(axiosOptions);
                if (response === null || response === void 0 ? void 0 : response.headers.location) {
                    axiosOptions.url = response.headers.location;
                    redir++;
                }
                else {
                    final = true;
                }
            }
            if (response === null || response === void 0 ? void 0 : response.body) {
                let binaryName;
                if ('question' === options.binaryNamingScheme && relatedQuestion) {
                    binaryName = relatedQuestion;
                }
                else {
                    binaryName = `${options.dataPropertyAttachmentsPrefixName || 'attachment_'}${index}`;
                }
                binaryItem.binary[binaryName] = await this.helpers.prepareBinaryData(response.body, fileName);
            }
        }
    }
    else {
        delete binaryItem.binary;
    }
    return binaryItem;
}
exports.downloadAttachments = downloadAttachments;
async function loadForms() {
    const responseData = await koBoToolboxApiRequest.call(this, {
        url: '/api/v2/assets/',
        qs: {
            q: 'asset_type:survey',
            ordering: 'name',
        },
        scroll: true,
    });
    return (responseData === null || responseData === void 0 ? void 0 : responseData.map((survey) => ({ name: survey.name, value: survey.uid }))) || [];
}
exports.loadForms = loadForms;
//# sourceMappingURL=GenericFunctions.js.map