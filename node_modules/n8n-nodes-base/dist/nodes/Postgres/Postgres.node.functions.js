"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pgUpdate = exports.pgInsert = exports.pgQuery = exports.generateReturning = exports.getItemCopy = exports.getItemsCopy = void 0;
function getItemsCopy(items, properties) {
    let newItem;
    return items.map(item => {
        newItem = {};
        for (const property of properties) {
            newItem[property] = item.json[property];
        }
        return newItem;
    });
}
exports.getItemsCopy = getItemsCopy;
function getItemCopy(item, properties) {
    const newItem = {};
    for (const property of properties) {
        newItem[property] = item.json[property];
    }
    return newItem;
}
exports.getItemCopy = getItemCopy;
function generateReturning(pgp, returning) {
    return ' RETURNING ' + returning.split(',').map(returnedField => pgp.as.name(returnedField.trim())).join(', ');
}
exports.generateReturning = generateReturning;
async function pgQuery(getNodeParam, pgp, db, items, continueOnFail, overrideMode) {
    var _a;
    const additionalFields = getNodeParam('additionalFields', 0);
    let valuesArray = [];
    if (additionalFields.queryParams) {
        const propertiesString = additionalFields.queryParams;
        const properties = propertiesString.split(',').map(column => column.trim());
        const paramsItems = getItemsCopy(items, properties);
        valuesArray = paramsItems.map((row) => properties.map(col => row[col]));
    }
    const allQueries = [];
    for (let i = 0; i < items.length; i++) {
        const query = getNodeParam('query', i);
        const values = valuesArray[i];
        const queryFormat = { query, values };
        allQueries.push(queryFormat);
    }
    const mode = overrideMode ? overrideMode : ((_a = additionalFields.mode) !== null && _a !== void 0 ? _a : 'multiple');
    if (mode === 'multiple') {
        return (await db.multi(pgp.helpers.concat(allQueries))).flat(1);
    }
    else if (mode === 'transaction') {
        return db.tx(async (t) => {
            const result = [];
            for (let i = 0; i < allQueries.length; i++) {
                try {
                    Array.prototype.push.apply(result, await t.any(allQueries[i].query, allQueries[i].values));
                }
                catch (err) {
                    if (continueOnFail === false)
                        throw err;
                    result.push(Object.assign(Object.assign({}, items[i].json), { code: err.code, message: err.message }));
                    return result;
                }
            }
            return result;
        });
    }
    else if (mode === 'independently') {
        return db.task(async (t) => {
            const result = [];
            for (let i = 0; i < allQueries.length; i++) {
                try {
                    Array.prototype.push.apply(result, await t.any(allQueries[i].query, allQueries[i].values));
                }
                catch (err) {
                    if (continueOnFail === false)
                        throw err;
                    result.push(Object.assign(Object.assign({}, items[i].json), { code: err.code, message: err.message }));
                }
            }
            return result;
        });
    }
    throw new Error('multiple, independently or transaction are valid options');
}
exports.pgQuery = pgQuery;
async function pgInsert(getNodeParam, pgp, db, items, continueOnFail, overrideMode) {
    var _a;
    const table = getNodeParam('table', 0);
    const schema = getNodeParam('schema', 0);
    const columnString = getNodeParam('columns', 0);
    const columns = columnString.split(',')
        .map(column => column.trim().split(':'))
        .map(([name, cast]) => ({ name, cast }));
    const columnNames = columns.map(column => column.name);
    const cs = new pgp.helpers.ColumnSet(columns, { table: { table, schema } });
    const additionalFields = getNodeParam('additionalFields', 0);
    const mode = overrideMode ? overrideMode : ((_a = additionalFields.mode) !== null && _a !== void 0 ? _a : 'multiple');
    const returning = generateReturning(pgp, getNodeParam('returnFields', 0));
    if (mode === 'multiple') {
        const query = pgp.helpers.insert(getItemsCopy(items, columnNames), cs) + returning;
        return db.any(query);
    }
    else if (mode === 'transaction') {
        return db.tx(async (t) => {
            const result = [];
            for (let i = 0; i < items.length; i++) {
                const itemCopy = getItemCopy(items[i], columnNames);
                try {
                    result.push(await t.one(pgp.helpers.insert(itemCopy, cs) + returning));
                }
                catch (err) {
                    if (continueOnFail === false)
                        throw err;
                    result.push(Object.assign(Object.assign({}, itemCopy), { code: err.code, message: err.message }));
                    return result;
                }
            }
            return result;
        });
    }
    else if (mode === 'independently') {
        return db.task(async (t) => {
            const result = [];
            for (let i = 0; i < items.length; i++) {
                const itemCopy = getItemCopy(items[i], columnNames);
                try {
                    const insertResult = await t.oneOrNone(pgp.helpers.insert(itemCopy, cs) + returning);
                    if (insertResult !== null) {
                        result.push(insertResult);
                    }
                }
                catch (err) {
                    if (continueOnFail === false) {
                        throw err;
                    }
                    result.push(Object.assign(Object.assign({}, itemCopy), { code: err.code, message: err.message }));
                }
            }
            return result;
        });
    }
    throw new Error('multiple, independently or transaction are valid options');
}
exports.pgInsert = pgInsert;
async function pgUpdate(getNodeParam, pgp, db, items, continueOnFail = false) {
    var _a;
    const table = getNodeParam('table', 0);
    const schema = getNodeParam('schema', 0);
    const updateKey = getNodeParam('updateKey', 0);
    const columnString = getNodeParam('columns', 0);
    const columns = columnString.split(',')
        .map(column => column.trim().split(':'))
        .map(([name, cast]) => ({ name, cast }));
    const updateKeys = updateKey.split(',').map(key => {
        const [name, cast] = key.trim().split(':');
        const updateColumn = { name, cast };
        const targetCol = columns.find((column) => column.name === name);
        if (!targetCol) {
            columns.unshift(updateColumn);
        }
        else if (!targetCol.cast) {
            targetCol.cast = updateColumn.cast || targetCol.cast;
        }
        return updateColumn;
    });
    const additionalFields = getNodeParam('additionalFields', 0);
    const mode = (_a = additionalFields.mode) !== null && _a !== void 0 ? _a : 'multiple';
    const cs = new pgp.helpers.ColumnSet(columns, { table: { table, schema } });
    const columnNames = columns.map(column => column.name);
    const updateItems = getItemsCopy(items, columnNames);
    const returning = generateReturning(pgp, getNodeParam('returnFields', 0));
    if (mode === 'multiple') {
        const query = pgp.helpers.update(updateItems, cs)
            + ' WHERE ' + updateKeys.map(updateKey => {
            const key = pgp.as.name(updateKey.name);
            return 'v.' + key + ' = t.' + key;
        }).join(' AND ')
            + returning;
        return await db.any(query);
    }
    else {
        const where = ' WHERE ' + updateKeys.map(updateKey => pgp.as.name(updateKey.name) + ' = ${' + updateKey.name + '}').join(' AND ');
        if (mode === 'transaction') {
            return db.tx(async (t) => {
                const result = [];
                for (let i = 0; i < items.length; i++) {
                    const itemCopy = getItemCopy(items[i], columnNames);
                    try {
                        Array.prototype.push.apply(result, await t.any(pgp.helpers.update(itemCopy, cs) + pgp.as.format(where, itemCopy) + returning));
                    }
                    catch (err) {
                        if (continueOnFail === false)
                            throw err;
                        result.push(Object.assign(Object.assign({}, itemCopy), { code: err.code, message: err.message }));
                        return result;
                    }
                }
                return result;
            });
        }
        else if (mode === 'independently') {
            return db.task(async (t) => {
                const result = [];
                for (let i = 0; i < items.length; i++) {
                    const itemCopy = getItemCopy(items[i], columnNames);
                    try {
                        Array.prototype.push.apply(result, await t.any(pgp.helpers.update(itemCopy, cs) + pgp.as.format(where, itemCopy) + returning));
                    }
                    catch (err) {
                        if (continueOnFail === false)
                            throw err;
                        result.push(Object.assign(Object.assign({}, itemCopy), { code: err.code, message: err.message }));
                    }
                }
                return result;
            });
        }
    }
    throw new Error('multiple, independently or transaction are valid options');
}
exports.pgUpdate = pgUpdate;
//# sourceMappingURL=Postgres.node.functions.js.map