"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.searchTables = exports.searchSchema = exports.initDB = exports.pgTriggerFunction = exports.prepareNames = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const pg_promise_1 = __importDefault(require("pg-promise"));
function prepareNames(id, mode, additionalFields) {
    let suffix = id.replace(/-/g, '_');
    if (mode === 'manual') {
        suffix = `${suffix}_manual`;
    }
    let functionName = additionalFields.functionName || `n8n_trigger_function_${suffix}()`;
    if (!(functionName.includes('(') && functionName.includes(')'))) {
        functionName = `${functionName}()`;
    }
    const triggerName = additionalFields.triggerName || `n8n_trigger_${suffix}`;
    const channelName = additionalFields.channelName || `n8n_channel_${suffix}`;
    if (channelName.includes('-')) {
        throw new n8n_workflow_1.ApplicationError('Channel name cannot contain hyphens (-)', { level: 'warning' });
    }
    return { functionName, triggerName, channelName };
}
exports.prepareNames = prepareNames;
async function pgTriggerFunction(db, additionalFields, functionName, triggerName, channelName) {
    var _a, _b;
    const schema = this.getNodeParameter('schema', 'public', { extractValue: true });
    const tableName = this.getNodeParameter('tableName', undefined, {
        extractValue: true,
    });
    const target = `${schema}."${tableName}"`;
    const firesOn = this.getNodeParameter('firesOn', 0);
    const functionReplace = "CREATE OR REPLACE FUNCTION $1:raw RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ begin perform pg_notify('$2:raw', row_to_json($3:raw)::text); return null; end; $BODY$;";
    const dropIfExist = 'DROP TRIGGER IF EXISTS $1:raw ON $2:raw';
    const functionExists = "CREATE FUNCTION $1:raw RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ begin perform pg_notify('$2:raw', row_to_json($3:raw)::text); return null; end; $BODY$";
    const trigger = 'CREATE TRIGGER $4:raw AFTER $3:raw ON $1:raw FOR EACH ROW EXECUTE FUNCTION $2:raw';
    const whichData = firesOn === 'DELETE' ? 'old' : 'new';
    if (channelName.includes('-')) {
        throw new n8n_workflow_1.ApplicationError('Channel name cannot contain hyphens (-)', { level: 'warning' });
    }
    const replaceIfExists = (_a = additionalFields.replaceIfExists) !== null && _a !== void 0 ? _a : false;
    try {
        if (replaceIfExists || !((_b = additionalFields.triggerName) !== null && _b !== void 0 ? _b : additionalFields.functionName)) {
            await db.any(functionReplace, [functionName, channelName, whichData]);
            await db.any(dropIfExist, [triggerName, target, whichData]);
        }
        else {
            await db.any(functionExists, [functionName, channelName, whichData]);
        }
        await db.any(trigger, [target, functionName, firesOn, triggerName]);
    }
    catch (error) {
        if (error.message.includes('near "-"')) {
            throw new n8n_workflow_1.ApplicationError('Names cannot contain hyphens (-)', { level: 'warning' });
        }
        throw error;
    }
}
exports.pgTriggerFunction = pgTriggerFunction;
async function initDB() {
    const credentials = await this.getCredentials('postgres');
    const options = this.getNodeParameter('options', {});
    const pgp = (0, pg_promise_1.default)({
        noWarnings: true,
    });
    const config = {
        host: credentials.host,
        port: credentials.port,
        database: credentials.database,
        user: credentials.user,
        password: credentials.password,
        keepAlive: true,
    };
    if (options.connectionTimeout) {
        config.connectionTimeoutMillis = options.connectionTimeout * 1000;
    }
    if (options.delayClosingIdleConnection) {
        config.keepAliveInitialDelayMillis = options.delayClosingIdleConnection * 1000;
    }
    if (credentials.allowUnauthorizedCerts === true) {
        config.ssl = {
            rejectUnauthorized: false,
        };
    }
    else {
        config.ssl = !['disable', undefined].includes(credentials.ssl);
        config.sslmode = credentials.ssl || 'disable';
    }
    const db = pgp(config);
    return { db, pgp };
}
exports.initDB = initDB;
async function searchSchema() {
    const { db } = await initDB.call(this);
    const schemaList = await db.any('SELECT schema_name FROM information_schema.schemata');
    const results = schemaList.map((s) => ({
        name: s.schema_name,
        value: s.schema_name,
    }));
    await db.$pool.end();
    return { results };
}
exports.searchSchema = searchSchema;
async function searchTables() {
    const schema = this.getNodeParameter('schema', 0);
    const { db } = await initDB.call(this);
    let tableList = [];
    try {
        tableList = await db.any('SELECT table_name FROM information_schema.tables WHERE table_schema = $1', [schema.value]);
    }
    catch (error) {
        throw new n8n_workflow_1.ApplicationError(error);
    }
    const results = tableList.map((s) => ({
        name: s.table_name,
        value: s.table_name,
    }));
    await db.$pool.end();
    return { results };
}
exports.searchTables = searchTables;
//# sourceMappingURL=PostgresTrigger.functions.js.map