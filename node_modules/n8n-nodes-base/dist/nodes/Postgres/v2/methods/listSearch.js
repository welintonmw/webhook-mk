"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tableSearch = exports.schemaSearch = void 0;
const transport_1 = require("../transport");
async function schemaSearch() {
    const credentials = (await this.getCredentials('postgres'));
    const options = { nodeVersion: this.getNode().typeVersion };
    const { db, sshClient } = await (0, transport_1.configurePostgres)(credentials, options);
    try {
        const response = await db.any('SELECT schema_name FROM information_schema.schemata');
        return {
            results: response.map((schema) => ({
                name: schema.schema_name,
                value: schema.schema_name,
            })),
        };
    }
    catch (error) {
        throw error;
    }
    finally {
        if (sshClient) {
            sshClient.end();
        }
        if (!db.$pool.ending)
            await db.$pool.end();
    }
}
exports.schemaSearch = schemaSearch;
async function tableSearch() {
    const credentials = (await this.getCredentials('postgres'));
    const options = { nodeVersion: this.getNode().typeVersion };
    const { db, sshClient } = await (0, transport_1.configurePostgres)(credentials, options);
    const schema = this.getNodeParameter('schema', 0, {
        extractValue: true,
    });
    try {
        const response = await db.any('SELECT table_name FROM information_schema.tables WHERE table_schema=$1', [schema]);
        return {
            results: response.map((table) => ({
                name: table.table_name,
                value: table.table_name,
            })),
        };
    }
    catch (error) {
        throw error;
    }
    finally {
        if (sshClient) {
            sshClient.end();
        }
        if (!db.$pool.ending)
            await db.$pool.end();
    }
}
exports.tableSearch = tableSearch;
//# sourceMappingURL=listSearch.js.map