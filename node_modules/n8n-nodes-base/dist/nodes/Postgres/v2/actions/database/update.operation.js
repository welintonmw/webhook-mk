"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.description = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const utils_1 = require("../../helpers/utils");
const common_descriptions_1 = require("../common.descriptions");
const utilities_1 = require("../../../../../utils/utilities");
const properties = [
    {
        displayName: 'Data Mode',
        name: 'dataMode',
        type: 'options',
        options: [
            {
                name: 'Auto-Map Input Data to Columns',
                value: 'autoMapInputData',
                description: 'Use when node input properties names exactly match the table column names',
            },
            {
                name: 'Map Each Column Manually',
                value: 'defineBelow',
                description: 'Set the value for each destination column manually',
            },
        ],
        default: 'autoMapInputData',
        description: 'Whether to map node input properties and the table data automatically or manually',
        displayOptions: {
            show: {
                '@version': [2, 2.1],
            },
        },
    },
    {
        displayName: `
		In this mode, make sure incoming data fields are named the same as the columns in your table. If needed, use an 'Edit Fields' node before this node to change the field names.
		`,
        name: 'notice',
        type: 'notice',
        default: '',
        displayOptions: {
            show: {
                dataMode: ['autoMapInputData'],
                '@version': [2],
            },
        },
    },
    {
        displayName: 'Column to Match On',
        name: 'columnToMatchOn',
        type: 'options',
        required: true,
        description: 'The column to compare when finding the rows to update. Choose from the list, or specify an ID using an <a href="https://docs.n8n.io/code-examples/expressions/" target="_blank">expression</a>.',
        typeOptions: {
            loadOptionsMethod: 'getColumns',
            loadOptionsDependsOn: ['schema.value', 'table.value'],
        },
        default: '',
        hint: 'The column that identifies the row(s) to modify',
        displayOptions: {
            show: {
                '@version': [2, 2.1],
            },
        },
    },
    {
        displayName: 'Value of Column to Match On',
        name: 'valueToMatchOn',
        type: 'string',
        default: '',
        description: 'Rows with a value in the specified "Column to Match On" that corresponds to the value in this field will be updated',
        displayOptions: {
            show: {
                dataMode: ['defineBelow'],
                '@version': [2, 2.1],
            },
        },
    },
    {
        displayName: 'Values to Send',
        name: 'valuesToSend',
        placeholder: 'Add Value',
        type: 'fixedCollection',
        typeOptions: {
            multipleValueButtonText: 'Add Value',
            multipleValues: true,
        },
        displayOptions: {
            show: {
                dataMode: ['defineBelow'],
                '@version': [2, 2.1],
            },
        },
        default: {},
        options: [
            {
                displayName: 'Values',
                name: 'values',
                values: [
                    {
                        displayName: 'Column',
                        name: 'column',
                        type: 'options',
                        description: 'Choose from the list, or specify an ID using an <a href="https://docs.n8n.io/code-examples/expressions/" target="_blank">expression</a>',
                        typeOptions: {
                            loadOptionsMethod: 'getColumnsWithoutColumnToMatchOn',
                            loadOptionsDependsOn: ['schema.value', 'table.value'],
                        },
                        default: [],
                    },
                    {
                        displayName: 'Value',
                        name: 'value',
                        type: 'string',
                        default: '',
                    },
                ],
            },
        ],
    },
    {
        displayName: 'Columns',
        name: 'columns',
        type: 'resourceMapper',
        noDataExpression: true,
        default: {
            mappingMode: 'defineBelow',
            value: null,
        },
        required: true,
        typeOptions: {
            loadOptionsDependsOn: ['table.value', 'operation'],
            resourceMapper: {
                resourceMapperMethod: 'getMappingColumns',
                mode: 'update',
                fieldWords: {
                    singular: 'column',
                    plural: 'columns',
                },
                addAllFields: true,
                multiKeyMatch: true,
            },
        },
        displayOptions: {
            show: {
                '@version': [{ _cnd: { gte: 2.2 } }],
            },
        },
    },
    common_descriptions_1.optionsCollection,
];
const displayOptions = {
    show: {
        resource: ['database'],
        operation: ['update'],
    },
    hide: {
        table: [''],
    },
};
exports.description = (0, utilities_1.updateDisplayOptions)(displayOptions, properties);
async function execute(runQueries, items, nodeOptions, db) {
    items = (0, utils_1.replaceEmptyStringsByNulls)(items, nodeOptions.replaceEmptyStrings);
    const nodeVersion = nodeOptions.nodeVersion;
    let schema = this.getNodeParameter('schema', 0, undefined, {
        extractValue: true,
    });
    let table = this.getNodeParameter('table', 0, undefined, {
        extractValue: true,
    });
    const updateTableSchema = (0, utils_1.configureTableSchemaUpdater)(schema, table);
    let tableSchema = await (0, utils_1.getTableSchema)(db, schema, table);
    const queries = [];
    for (let i = 0; i < items.length; i++) {
        schema = this.getNodeParameter('schema', i, undefined, {
            extractValue: true,
        });
        table = this.getNodeParameter('table', i, undefined, {
            extractValue: true,
        });
        const columnsToMatchOn = nodeVersion < 2.2
            ? [this.getNodeParameter('columnToMatchOn', i)]
            : this.getNodeParameter('columns.matchingColumns', i);
        const dataMode = nodeVersion < 2.2
            ? this.getNodeParameter('dataMode', i)
            : this.getNodeParameter('columns.mappingMode', i);
        let item = {};
        let valueToMatchOn = '';
        if (nodeVersion < 2.2) {
            valueToMatchOn = this.getNodeParameter('valueToMatchOn', i);
        }
        if (dataMode === 'autoMapInputData') {
            item = items[i].json;
            if (nodeVersion < 2.2) {
                valueToMatchOn = item[columnsToMatchOn[0]];
            }
        }
        if (dataMode === 'defineBelow') {
            const valuesToSend = nodeVersion < 2.2
                ? this.getNodeParameter('valuesToSend', i, []).values
                : this.getNodeParameter('columns.values', i, [])
                    .values;
            if (nodeVersion < 2.2) {
                item = (0, utils_1.prepareItem)(valuesToSend);
                item[columnsToMatchOn[0]] = this.getNodeParameter('valueToMatchOn', i);
            }
            else {
                item = this.getNodeParameter('columns.value', i);
            }
        }
        const matchValues = [];
        if (nodeVersion < 2.2) {
            if (!item[columnsToMatchOn[0]] && dataMode === 'autoMapInputData') {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), "Column to match on not found in input item. Add a column to match on or set the 'Data Mode' to 'Define Below' to define the value to match on.");
            }
            matchValues.push(valueToMatchOn);
            matchValues.push(columnsToMatchOn[0]);
        }
        else {
            columnsToMatchOn.forEach((column) => {
                matchValues.push(column);
                matchValues.push(item[column]);
            });
            const rowExists = await (0, utils_1.doesRowExist)(db, schema, table, matchValues);
            if (!rowExists) {
                const descriptionValues = [];
                matchValues.forEach((_, index) => {
                    if (index % 2 === 0) {
                        descriptionValues.push(`${matchValues[index]}=${matchValues[index + 1]}`);
                    }
                });
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), "The row you are trying to update doesn't exist", {
                    description: `No rows matching the provided values (${descriptionValues.join(', ')}) were found in the table "${table}".`,
                    itemIndex: i,
                });
            }
        }
        tableSchema = await updateTableSchema(db, tableSchema, schema, table);
        if (nodeVersion >= 2.4) {
            (0, utils_1.convertArraysToPostgresFormat)(item, tableSchema, this.getNode(), i);
        }
        item = (0, utils_1.checkItemAgainstSchema)(this.getNode(), item, tableSchema, i);
        let values = [schema, table];
        let valuesLength = values.length + 1;
        let condition = '';
        if (nodeVersion < 2.2) {
            condition = `$${valuesLength}:name = $${valuesLength + 1}`;
            valuesLength = valuesLength + 2;
            values.push(columnsToMatchOn[0], valueToMatchOn);
        }
        else {
            const conditions = [];
            for (const column of columnsToMatchOn) {
                conditions.push(`$${valuesLength}:name = $${valuesLength + 1}`);
                valuesLength = valuesLength + 2;
                values.push(column, item[column]);
            }
            condition = conditions.join(' AND ');
        }
        const updateColumns = Object.keys(item).filter((column) => !columnsToMatchOn.includes(column));
        if (!Object.keys(updateColumns).length) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), "Add values to update to the input item or set the 'Data Mode' to 'Define Below' to define the values to update.");
        }
        const updates = [];
        for (const column of updateColumns) {
            updates.push(`$${valuesLength}:name = $${valuesLength + 1}`);
            valuesLength = valuesLength + 2;
            values.push(column, item[column]);
        }
        let query = `UPDATE $1:name.$2:name SET ${updates.join(', ')} WHERE ${condition}`;
        const outputColumns = this.getNodeParameter('options.outputColumns', i, ['*']);
        [query, values] = (0, utils_1.addReturning)(query, outputColumns, values);
        queries.push({ query, values });
    }
    const results = await runQueries(queries, items, nodeOptions);
    return results;
}
exports.execute = execute;
//# sourceMappingURL=update.operation.js.map