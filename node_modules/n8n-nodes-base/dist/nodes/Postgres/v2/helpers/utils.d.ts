import type { IDataObject, IExecuteFunctions, INode, INodeExecutionData, INodePropertyOptions } from 'n8n-workflow';
import { NodeOperationError } from 'n8n-workflow';
import type { ColumnInfo, EnumInfo, PgpClient, PgpDatabase, QueryValues, QueryWithValues, SortRule, WhereClause } from './interfaces';
export declare function wrapData(data: IDataObject | IDataObject[]): INodeExecutionData[];
export declare function prepareErrorItem(items: INodeExecutionData[], error: IDataObject | NodeOperationError | Error, index: number): INodeExecutionData;
export declare function parsePostgresError(node: INode, error: any, queries: QueryWithValues[], itemIndex?: number): NodeOperationError;
export declare function addWhereClauses(node: INode, itemIndex: number, query: string, clauses: WhereClause[], replacements: QueryValues, combineConditions: string): [string, QueryValues];
export declare function addSortRules(query: string, rules: SortRule[], replacements: QueryValues): [string, QueryValues];
export declare function addReturning(query: string, outputColumns: string[], replacements: QueryValues): [string, QueryValues];
export declare function configureQueryRunner(this: IExecuteFunctions, node: INode, continueOnFail: boolean, pgp: PgpClient, db: PgpDatabase): (queries: QueryWithValues[], items: INodeExecutionData[], options: IDataObject) => Promise<INodeExecutionData[] | {
    json: {
        message: string;
        error: {
            type: string | undefined;
            node: INode;
            messages: string[];
            description: string | null | undefined;
            cause?: Error | undefined;
            errorResponse?: import("n8n-workflow").JsonObject | undefined;
            timestamp: number;
            context: IDataObject;
            lineNumber: number | undefined;
            functionality: import("n8n-workflow").Functionality;
            level: import("n8n-workflow/dist/errors/application.error").Level;
            tags: {
                [key: string]: import("@sentry/types").Primitive;
            };
            extra?: import("@sentry/types").Extras | undefined;
            packageName?: string | undefined;
            name: string;
            message: string;
            stack?: string | undefined;
        };
    };
}[]>;
export declare function replaceEmptyStringsByNulls(items: INodeExecutionData[], replace?: boolean): INodeExecutionData[];
export declare function prepareItem(values: IDataObject[]): IDataObject;
export declare function columnFeatureSupport(db: PgpDatabase): Promise<{
    identity_generation: boolean;
    is_generated: boolean;
}>;
export declare function getTableSchema(db: PgpDatabase, schema: string, table: string, options?: {
    getColumnsForResourceMapper?: boolean;
}): Promise<ColumnInfo[]>;
export declare function uniqueColumns(db: PgpDatabase, table: string, schema?: string): Promise<IDataObject[]>;
export declare function getEnums(db: PgpDatabase): Promise<EnumInfo[]>;
export declare function getEnumValues(enumInfo: EnumInfo[], enumName: string): INodePropertyOptions[];
export declare function doesRowExist(db: PgpDatabase, schema: string, table: string, values: string[]): Promise<boolean>;
export declare function checkItemAgainstSchema(node: INode, item: IDataObject, columnsInfo: ColumnInfo[], index: number): IDataObject;
export declare const configureTableSchemaUpdater: (initialSchema: string, initialTable: string) => (db: PgpDatabase, tableSchema: ColumnInfo[], schema: string, table: string) => Promise<ColumnInfo[]>;
export declare const convertArraysToPostgresFormat: (data: IDataObject, schema: ColumnInfo[], node: INode, itemIndex?: number) => void;
