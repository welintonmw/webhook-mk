"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Compression = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const fflate = require("fflate");
const util_1 = require("util");
const gunzip = util_1.promisify(fflate.gunzip);
const gzip = util_1.promisify(fflate.gzip);
const unzip = util_1.promisify(fflate.unzip);
const zip = util_1.promisify(fflate.zip);
const mime = require("mime-types");
const ALREADY_COMPRESSED = [
    '7z',
    'aifc',
    'bz2',
    'doc',
    'docx',
    'gif',
    'gz',
    'heic',
    'heif',
    'jpg',
    'jpeg',
    'mov',
    'mp3',
    'mp4',
    'pdf',
    'png',
    'ppt',
    'pptx',
    'rar',
    'webm',
    'webp',
    'xls',
    'xlsx',
    'zip',
];
class Compression {
    constructor() {
        this.description = {
            displayName: 'Compression',
            name: 'compression',
            icon: 'fa:file-archive',
            group: ['transform'],
            subtitle: '={{$parameter["operation"]}}',
            version: 1,
            description: 'Compress and uncompress files',
            defaults: {
                name: 'Compression',
                color: '#408000',
            },
            inputs: ['main'],
            outputs: ['main'],
            properties: [
                {
                    displayName: 'Operation',
                    name: 'operation',
                    type: 'options',
                    options: [
                        {
                            name: 'Compress',
                            value: 'compress',
                        },
                        {
                            name: 'Decompress',
                            value: 'decompress',
                        },
                    ],
                    default: 'decompress',
                },
                {
                    displayName: 'Binary Property',
                    name: 'binaryPropertyName',
                    type: 'string',
                    default: 'data',
                    required: true,
                    displayOptions: {
                        show: {
                            operation: [
                                'compress',
                                'decompress',
                            ],
                        },
                    },
                    placeholder: '',
                    description: 'Name of the binary property which contains the data for the file(s) to be compress/decompress. Multiple can be used separated by a comma (,)',
                },
                {
                    displayName: 'Output Format',
                    name: 'outputFormat',
                    type: 'options',
                    default: '',
                    options: [
                        {
                            name: 'gzip',
                            value: 'gzip',
                        },
                        {
                            name: 'zip',
                            value: 'zip',
                        },
                    ],
                    displayOptions: {
                        show: {
                            operation: [
                                'compress',
                            ],
                        },
                    },
                    description: 'Format of the output file',
                },
                {
                    displayName: 'File Name',
                    name: 'fileName',
                    type: 'string',
                    default: '',
                    placeholder: 'data.zip',
                    required: true,
                    displayOptions: {
                        show: {
                            operation: [
                                'compress',
                            ],
                            outputFormat: [
                                'zip',
                            ],
                        },
                    },
                    description: 'Name of the file to be compressed',
                },
                {
                    displayName: 'Binary Property Output',
                    name: 'binaryPropertyOutput',
                    type: 'string',
                    default: 'data',
                    required: false,
                    displayOptions: {
                        show: {
                            outputFormat: [
                                'zip',
                            ],
                            operation: [
                                'compress',
                            ],
                        },
                    },
                    placeholder: '',
                    description: 'Name of the binary property to which to write the data of the compressed files.',
                },
                {
                    displayName: 'Output Prefix',
                    name: 'outputPrefix',
                    type: 'string',
                    default: 'data',
                    required: true,
                    displayOptions: {
                        show: {
                            operation: [
                                'compress',
                            ],
                            outputFormat: [
                                'gzip',
                            ],
                        },
                    },
                    description: 'Prefix use for all gzip compresed files',
                },
                {
                    displayName: 'Output Prefix',
                    name: 'outputPrefix',
                    type: 'string',
                    default: 'file_',
                    required: true,
                    displayOptions: {
                        show: {
                            operation: [
                                'decompress',
                            ],
                        },
                    },
                    description: 'Prefix use for all decompressed files',
                },
            ],
        };
    }
    async execute() {
        var _a, _b;
        const items = this.getInputData();
        const length = items.length;
        const returnData = [];
        const operation = this.getNodeParameter('operation', 0);
        for (let i = 0; i < length; i++) {
            try {
                if (operation === 'decompress') {
                    const binaryPropertyNames = this.getNodeParameter('binaryPropertyName', 0).split(',').map(key => key.trim());
                    const outputPrefix = this.getNodeParameter('outputPrefix', 0);
                    const binaryObject = {};
                    let zipIndex = 0;
                    for (const [index, binaryPropertyName] of binaryPropertyNames.entries()) {
                        if (items[i].binary === undefined) {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'No binary data exists on item!');
                        }
                        if (items[i].binary[binaryPropertyName] === undefined) {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), `No binary data property "${binaryPropertyName}" does not exists on item!`);
                        }
                        const binaryData = items[i].binary[binaryPropertyName];
                        const binaryDataBuffer = await this.helpers.getBinaryDataBuffer(i, binaryPropertyName);
                        if (binaryData.fileExtension === 'zip') {
                            const files = await unzip(binaryDataBuffer);
                            for (const key of Object.keys(files)) {
                                if (key.includes('__MACOSX')) {
                                    continue;
                                }
                                const data = await this.helpers.prepareBinaryData(Buffer.from(files[key].buffer), key);
                                binaryObject[`${outputPrefix}${zipIndex++}`] = data;
                            }
                        }
                        else if (binaryData.fileExtension === 'gz') {
                            const file = await gunzip(binaryDataBuffer);
                            const fileName = (_a = binaryData.fileName) === null || _a === void 0 ? void 0 : _a.split('.')[0];
                            const propertyName = `${outputPrefix}${index}`;
                            binaryObject[propertyName] = await this.helpers.prepareBinaryData(Buffer.from(file.buffer), fileName);
                            const fileExtension = mime.extension(binaryObject[propertyName].mimeType);
                            binaryObject[propertyName].fileName = `${fileName}.${fileExtension}`;
                            binaryObject[propertyName].fileExtension = fileExtension;
                        }
                    }
                    returnData.push({
                        json: items[i].json,
                        binary: binaryObject,
                    });
                }
                if (operation === 'compress') {
                    const binaryPropertyNames = this.getNodeParameter('binaryPropertyName', 0).split(',').map(key => key.trim());
                    const outputFormat = this.getNodeParameter('outputFormat', 0);
                    const zipData = {};
                    const binaryObject = {};
                    for (const [index, binaryPropertyName] of binaryPropertyNames.entries()) {
                        if (items[i].binary === undefined) {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'No binary data exists on item!');
                        }
                        if (items[i].binary[binaryPropertyName] === undefined) {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), `No binary data property "${binaryPropertyName}" does not exists on item!`);
                        }
                        const binaryData = items[i].binary[binaryPropertyName];
                        const binaryDataBuffer = await this.helpers.getBinaryDataBuffer(i, binaryPropertyName);
                        if (outputFormat === 'zip') {
                            zipData[binaryData.fileName] = [
                                binaryDataBuffer, {
                                    level: ALREADY_COMPRESSED.includes(binaryData.fileExtension) ? 0 : 6,
                                },
                            ];
                        }
                        else if (outputFormat === 'gzip') {
                            const outputPrefix = this.getNodeParameter('outputPrefix', 0);
                            const data = await gzip(binaryDataBuffer);
                            const fileName = (_b = binaryData.fileName) === null || _b === void 0 ? void 0 : _b.split('.')[0];
                            binaryObject[`${outputPrefix}${index}`] = await this.helpers.prepareBinaryData(Buffer.from(data), `${fileName}.gzip`);
                        }
                    }
                    if (outputFormat === 'zip') {
                        const fileName = this.getNodeParameter('fileName', 0);
                        const binaryPropertyOutput = this.getNodeParameter('binaryPropertyOutput', 0);
                        const buffer = await zip(zipData);
                        const data = await this.helpers.prepareBinaryData(Buffer.from(buffer), fileName);
                        returnData.push({
                            json: items[i].json,
                            binary: {
                                [binaryPropertyOutput]: data,
                            },
                        });
                    }
                    if (outputFormat === 'gzip') {
                        returnData.push({
                            json: items[i].json,
                            binary: binaryObject,
                        });
                    }
                }
            }
            catch (error) {
                if (this.continueOnFail()) {
                    returnData.push({ json: { error: error.message } });
                    continue;
                }
                throw error;
            }
        }
        return this.prepareOutputData(returnData);
    }
}
exports.Compression = Compression;
//# sourceMappingURL=Compression.node.js.map