"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DebugHelper = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const minifaker_1 = require("minifaker");
const randomData_1 = require("./randomData");
const functions_1 = require("./functions");
class DebugHelper {
    constructor() {
        this.description = {
            displayName: 'DebugHelper',
            name: 'debugHelper',
            icon: { light: 'file:DebugHelper.svg', dark: 'file:DebugHelper.dark.svg' },
            group: ['output'],
            subtitle: '={{$parameter["category"]}}',
            description: 'Causes problems intentionally and generates useful data for debugging',
            version: 1,
            defaults: {
                name: 'DebugHelper',
            },
            inputs: ['main'],
            outputs: ['main'],
            credentials: [],
            properties: [
                {
                    displayName: 'Category',
                    name: 'category',
                    type: 'options',
                    noDataExpression: true,
                    options: [
                        {
                            name: 'Do Nothing',
                            value: 'doNothing',
                            description: 'Does nothing',
                        },
                        {
                            name: 'Throw Error',
                            value: 'throwError',
                            description: 'Throws an error with the specified type and message',
                        },
                        {
                            name: 'Out Of Memory',
                            value: 'oom',
                            description: 'Generates a large amount of memory to cause an out of memory error',
                        },
                        {
                            name: 'Generate Random Data',
                            value: 'randomData',
                            description: 'Generates random data sets',
                        },
                    ],
                    default: 'throwError',
                },
                {
                    displayName: 'Error Type',
                    name: 'throwErrorType',
                    type: 'options',
                    noDataExpression: true,
                    options: [
                        {
                            name: 'NodeApiError',
                            value: 'NodeApiError',
                        },
                        {
                            name: 'NodeOperationError',
                            value: 'NodeOperationError',
                        },
                        {
                            name: 'Error',
                            value: 'Error',
                        },
                    ],
                    default: 'NodeApiError',
                    displayOptions: {
                        show: {
                            category: ['throwError'],
                        },
                    },
                },
                {
                    displayName: 'Error Message',
                    name: 'throwErrorMessage',
                    type: 'string',
                    default: 'Node has thrown an error',
                    description: 'The message to send as part of the error',
                    displayOptions: {
                        show: {
                            category: ['throwError'],
                        },
                    },
                },
                {
                    displayName: 'Memory Size to Generate',
                    name: 'memorySizeValue',
                    type: 'number',
                    default: 10,
                    description: 'The approximate amount of memory to generate. Be generous...',
                    displayOptions: {
                        show: {
                            category: ['oom'],
                        },
                    },
                },
                {
                    displayName: 'Data Type',
                    name: 'randomDataType',
                    type: 'options',
                    noDataExpression: true,
                    options: [
                        {
                            name: 'Address',
                            value: 'address',
                        },
                        {
                            name: 'Coordinates',
                            value: 'latLong',
                        },
                        {
                            name: 'Credit Card',
                            value: 'creditCard',
                        },
                        {
                            name: 'Email',
                            value: 'email',
                        },
                        {
                            name: 'IPv4',
                            value: 'ipv4',
                        },
                        {
                            name: 'IPv6',
                            value: 'ipv6',
                        },
                        {
                            name: 'MAC',
                            value: 'macAddress',
                        },
                        {
                            name: 'NanoIds',
                            value: 'nanoid',
                        },
                        {
                            name: 'URL',
                            value: 'url',
                        },
                        {
                            name: 'User Data',
                            value: 'user',
                        },
                        {
                            name: 'UUID',
                            value: 'uuid',
                        },
                        {
                            name: 'Version',
                            value: 'semver',
                        },
                    ],
                    default: 'user',
                    displayOptions: {
                        show: {
                            category: ['randomData'],
                        },
                    },
                },
                {
                    displayName: 'NanoId Alphabet',
                    name: 'nanoidAlphabet',
                    type: 'string',
                    default: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',
                    description: 'The alphabet to use for generating the nanoIds',
                    displayOptions: {
                        show: {
                            category: ['randomData'],
                            randomDataType: ['nanoid'],
                        },
                    },
                },
                {
                    displayName: 'NanoId Length',
                    name: 'nanoidLength',
                    type: 'string',
                    default: '16',
                    description: 'The length of each nanoIds',
                    displayOptions: {
                        show: {
                            category: ['randomData'],
                            randomDataType: ['nanoid'],
                        },
                    },
                },
                {
                    displayName: 'Seed',
                    name: 'randomDataSeed',
                    type: 'string',
                    default: '',
                    placeholder: 'Leave empty for random seed',
                    description: 'If set, seed to use for generating the data (same seed will generate the same data)',
                    displayOptions: {
                        show: {
                            category: ['randomData'],
                        },
                    },
                },
                {
                    displayName: 'Number of Items to Generate',
                    name: 'randomDataCount',
                    type: 'number',
                    default: 10,
                    description: 'The number of random data items to generate into an array',
                    displayOptions: {
                        show: {
                            category: ['randomData'],
                        },
                    },
                },
                {
                    displayName: 'Output as Single Array',
                    name: 'randomDataSingleArray',
                    type: 'boolean',
                    default: false,
                    description: 'Whether to output a single array instead of multiple items',
                    displayOptions: {
                        show: {
                            category: ['randomData'],
                        },
                    },
                },
            ],
        };
    }
    async execute() {
        const items = this.getInputData();
        const returnData = [];
        const category = this.getNodeParameter('category', 0);
        for (let i = 0; i < items.length; i++) {
            try {
                switch (category) {
                    case 'doNothing':
                        break;
                    case 'throwError':
                        const throwErrorType = this.getNodeParameter('throwErrorType', 0);
                        const throwErrorMessage = this.getNodeParameter('throwErrorMessage', 0);
                        switch (throwErrorType) {
                            case 'NodeApiError':
                                throw new n8n_workflow_1.NodeApiError(this.getNode(), { message: throwErrorMessage }, { message: throwErrorMessage });
                            case 'NodeOperationError':
                                throw new n8n_workflow_1.NodeOperationError(this.getNode(), throwErrorMessage, {
                                    message: throwErrorMessage,
                                });
                            case 'Error':
                                throw new n8n_workflow_1.ApplicationError(throwErrorMessage);
                            default:
                                break;
                        }
                    case 'oom':
                        const memorySizeValue = this.getNodeParameter('memorySizeValue', 0);
                        (0, functions_1.runGarbageCollector)();
                        const memUsed = (0, functions_1.generateGarbageMemory)(memorySizeValue);
                        items[i].json = memUsed;
                        returnData.push(items[i]);
                        break;
                    case 'randomData':
                        const randomDataType = this.getNodeParameter('randomDataType', 0);
                        const randomDataCount = this.getNodeParameter('randomDataCount', 0);
                        const randomDataSeed = this.getNodeParameter('randomDataSeed', 0);
                        const randomDataSingleArray = this.getNodeParameter('randomDataSingleArray', 0);
                        const newItem = {
                            json: {},
                            pairedItem: { item: i },
                        };
                        if (randomDataSeed !== '') {
                            (0, minifaker_1.setSeed)(randomDataSeed);
                        }
                        let randomFn = randomData_1.generateRandomUser;
                        switch (randomDataType) {
                            case 'user':
                                randomFn = randomData_1.generateRandomUser;
                                break;
                            case 'email':
                                randomFn = randomData_1.generateRandomEmail;
                                break;
                            case 'address':
                                randomFn = randomData_1.generateRandomAddress;
                                break;
                            case 'creditCard':
                                randomFn = randomData_1.generateCreditCard;
                                break;
                            case 'uuid':
                                randomFn = randomData_1.generateUUID;
                                break;
                            case 'macAddress':
                                randomFn = randomData_1.generateMAC;
                                break;
                            case 'ipv4':
                                randomFn = randomData_1.generateIPv4;
                                break;
                            case 'ipv6':
                                randomFn = randomData_1.generateIPv6;
                                break;
                            case 'latLong':
                                randomFn = randomData_1.generateLocation;
                                break;
                            case 'semver':
                                randomFn = randomData_1.generateVersion;
                                break;
                            case 'url':
                                randomFn = randomData_1.generateURL;
                                break;
                            case 'nanoid':
                                const nanoidAlphabet = this.getNodeParameter('nanoidAlphabet', 0);
                                const nanoidLength = this.getNodeParameter('nanoidLength', 0);
                                randomFn = () => (0, randomData_1.generateNanoid)(nanoidAlphabet, nanoidLength);
                                break;
                        }
                        const generatedItems = (0, minifaker_1.array)(randomDataCount, randomFn);
                        if (randomDataSingleArray) {
                            newItem.json = { generatedItems };
                            returnData.push(newItem);
                        }
                        else {
                            for (const generatedItem of generatedItems) {
                                returnData.push({
                                    json: generatedItem,
                                    pairedItem: { item: i },
                                });
                            }
                        }
                        break;
                    default:
                        break;
                }
            }
            catch (error) {
                if (this.continueOnFail(error)) {
                    const executionErrorData = this.helpers.constructExecutionMetaData(this.helpers.returnJsonArray({ error: error.message }), { itemData: { item: i } });
                    returnData.push(...executionErrorData);
                    continue;
                }
                throw error;
            }
        }
        return [returnData];
    }
}
exports.DebugHelper = DebugHelper;
//# sourceMappingURL=DebugHelper.node.js.map