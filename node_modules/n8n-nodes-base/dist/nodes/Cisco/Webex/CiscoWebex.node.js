"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CiscoWebex = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const GenericFunctions_1 = require("./GenericFunctions");
const descriptions_1 = require("./descriptions");
const moment = require("moment-timezone");
class CiscoWebex {
    constructor() {
        this.description = {
            displayName: 'Webex by Cisco',
            name: 'ciscoWebex',
            icon: 'file:ciscoWebex.png',
            group: ['transform'],
            version: 1,
            subtitle: '={{$parameter["operation"] + ": " + $parameter["resource"]}}',
            description: 'Consume the Cisco Webex API',
            defaults: {
                name: 'Webex',
                color: '#29b6f6',
            },
            credentials: [
                {
                    name: 'ciscoWebexOAuth2Api',
                    required: true,
                },
            ],
            inputs: ['main'],
            outputs: ['main'],
            properties: [
                {
                    displayName: 'Resource',
                    name: 'resource',
                    type: 'options',
                    options: [
                        {
                            name: 'Meeting',
                            value: 'meeting',
                        },
                        {
                            name: 'Message',
                            value: 'message',
                        },
                    ],
                    default: 'message',
                    description: 'Resource to consume',
                },
                ...descriptions_1.meetingOperations,
                ...descriptions_1.meetingFields,
                ...descriptions_1.messageOperations,
                ...descriptions_1.messageFields,
            ],
        };
        this.methods = {
            loadOptions: {
                async getRooms() {
                    const returnData = [];
                    const rooms = await GenericFunctions_1.webexApiRequestAllItems.call(this, 'items', 'GET', '/rooms');
                    for (const room of rooms) {
                        returnData.push({
                            name: room.title,
                            value: room.id,
                        });
                    }
                    return returnData;
                },
                async getSites() {
                    const returnData = [];
                    const sites = await GenericFunctions_1.webexApiRequestAllItems.call(this, 'sites', 'GET', '/meetingPreferences/sites');
                    for (const site of sites) {
                        returnData.push({
                            name: site.siteUrl,
                            value: site.siteUrl,
                        });
                    }
                    return returnData;
                },
            },
        };
    }
    async execute() {
        const items = this.getInputData();
        const returnData = [];
        const timezone = this.getTimezone();
        const resource = this.getNodeParameter('resource', 0);
        const operation = this.getNodeParameter('operation', 0);
        let responseData;
        for (let i = 0; i < items.length; i++) {
            try {
                if (resource === 'message') {
                    if (operation === 'create') {
                        const destination = this.getNodeParameter('destination', i);
                        const file = this.getNodeParameter('additionalFields.fileUi.fileValue', i, {});
                        const markdown = this.getNodeParameter('additionalFields.markdown', i, '');
                        const body = {};
                        if (destination === 'room') {
                            body['roomId'] = this.getNodeParameter('roomId', i);
                        }
                        if (destination === 'person') {
                            const specifyPersonBy = this.getNodeParameter('specifyPersonBy', 0);
                            if (specifyPersonBy === 'id') {
                                body['toPersonId'] = this.getNodeParameter('toPersonId', i);
                            }
                            else {
                                body['toPersonEmail'] = this.getNodeParameter('toPersonEmail', i);
                            }
                        }
                        if (markdown) {
                            body['markdown'] = markdown;
                        }
                        body['text'] = this.getNodeParameter('text', i);
                        body.attachments = GenericFunctions_1.getAttachemnts(this.getNodeParameter('additionalFields.attachmentsUi.attachmentValues', i, []));
                        if (Object.keys(file).length) {
                            const isBinaryData = file.fileLocation === 'binaryData' ? true : false;
                            if (isBinaryData) {
                                if (!items[i].binary) {
                                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'No binary data exists on item!');
                                }
                                const binaryPropertyName = file.binaryPropertyName;
                                const binaryData = items[i].binary[binaryPropertyName];
                                const binaryDataBuffer = await this.helpers.getBinaryDataBuffer(i, binaryPropertyName);
                                const formData = {
                                    files: {
                                        value: binaryDataBuffer,
                                        options: {
                                            filename: binaryData.fileName,
                                            contentType: binaryData.mimeType,
                                        },
                                    },
                                };
                                Object.assign(body, formData);
                            }
                            else {
                                const url = file.url;
                                Object.assign(body, { files: url });
                            }
                        }
                        if (file.fileLocation === 'binaryData') {
                            responseData = await GenericFunctions_1.webexApiRequest.call(this, 'POST', '/messages', {}, {}, undefined, { formData: body });
                        }
                        else {
                            responseData = await GenericFunctions_1.webexApiRequest.call(this, 'POST', '/messages', body);
                        }
                    }
                    else if (operation === 'delete') {
                        const messageId = this.getNodeParameter('messageId', i);
                        const endpoint = `/messages/${messageId}`;
                        responseData = await GenericFunctions_1.webexApiRequest.call(this, 'DELETE', endpoint);
                        responseData = { success: true };
                    }
                    else if (operation === 'get') {
                        const messageId = this.getNodeParameter('messageId', i);
                        const endpoint = `/messages/${messageId}`;
                        responseData = await GenericFunctions_1.webexApiRequest.call(this, 'GET', endpoint);
                    }
                    else if (operation === 'getAll') {
                        const qs = {
                            roomId: this.getNodeParameter('roomId', i),
                        };
                        const filters = this.getNodeParameter('filters', i);
                        const returnAll = this.getNodeParameter('returnAll', i);
                        if (Object.keys(filters).length) {
                            Object.assign(qs, filters);
                        }
                        if (returnAll === true) {
                            responseData = await GenericFunctions_1.webexApiRequestAllItems.call(this, 'items', 'GET', '/messages', {}, qs);
                        }
                        else {
                            qs.max = this.getNodeParameter('limit', i);
                            responseData = await GenericFunctions_1.webexApiRequest.call(this, 'GET', '/messages', {}, qs);
                            responseData = responseData.items;
                        }
                    }
                    else if (operation === 'update') {
                        const messageId = this.getNodeParameter('messageId', i);
                        const markdown = this.getNodeParameter('markdown', i);
                        const endpoint = `/messages/${messageId}`;
                        responseData = await GenericFunctions_1.webexApiRequest.call(this, 'GET', endpoint);
                        const body = {
                            roomId: responseData.roomId,
                        };
                        if (markdown === true) {
                            body['markdown'] = this.getNodeParameter('markdownText', i);
                        }
                        else {
                            body['text'] = this.getNodeParameter('text', i);
                        }
                        responseData = await GenericFunctions_1.webexApiRequest.call(this, 'PUT', endpoint, body);
                    }
                }
                if (resource === 'meeting') {
                    if (operation === 'create') {
                        const title = this.getNodeParameter('title', i);
                        const start = this.getNodeParameter('start', i);
                        const end = this.getNodeParameter('end', i);
                        const invitees = this.getNodeParameter('additionalFields.inviteesUi.inviteeValues', i, []);
                        const additionalFields = this.getNodeParameter('additionalFields', i);
                        const body = Object.assign({ title, start: moment.tz(start, timezone).format(), end: moment.tz(end, timezone).format() }, additionalFields);
                        if (body.requireRegistrationInfo) {
                            body['registration'] = body.requireRegistrationInfo
                                .reduce((obj, value) => Object.assign(obj, { [`${value}`]: true }), {});
                            delete body.requireRegistrationInfo;
                        }
                        if (invitees) {
                            body['invitees'] = invitees;
                            delete body.inviteesUi;
                        }
                        responseData = await GenericFunctions_1.webexApiRequest.call(this, 'POST', '/meetings', body);
                    }
                    if (operation === 'delete') {
                        const meetingId = this.getNodeParameter('meetingId', i);
                        const options = this.getNodeParameter('options', i);
                        const qs = Object.assign({}, options);
                        responseData = await GenericFunctions_1.webexApiRequest.call(this, 'DELETE', `/meetings/${meetingId}`, {}, qs);
                        responseData = { success: true };
                    }
                    if (operation === 'get') {
                        const meetingId = this.getNodeParameter('meetingId', i);
                        const options = this.getNodeParameter('options', i);
                        let headers = {};
                        const qs = Object.assign({}, options);
                        if (options.passsword) {
                            headers = {
                                passsword: options.passsword,
                            };
                        }
                        responseData = await GenericFunctions_1.webexApiRequest.call(this, 'GET', `/meetings/${meetingId}`, {}, qs, undefined, { headers });
                    }
                    if (operation === 'getAll') {
                        const filters = this.getNodeParameter('filters', i);
                        const returnAll = this.getNodeParameter('returnAll', i);
                        const qs = Object.assign({}, filters);
                        if (qs.from) {
                            qs.from = moment(qs.from).utc(true).format();
                        }
                        if (qs.to) {
                            qs.to = moment(qs.to).utc(true).format();
                        }
                        if (returnAll === true) {
                            responseData = await GenericFunctions_1.webexApiRequestAllItems.call(this, 'items', 'GET', '/meetings', {}, qs);
                            returnData.push(...responseData);
                        }
                        else {
                            qs.max = this.getNodeParameter('limit', i);
                            responseData = await GenericFunctions_1.webexApiRequest.call(this, 'GET', '/meetings', {}, qs);
                            responseData = responseData.items;
                        }
                    }
                    if (operation === 'update') {
                        const meetingId = this.getNodeParameter('meetingId', i);
                        const invitees = this.getNodeParameter('updateFields.inviteesUi.inviteeValues', i, []);
                        const updateFields = this.getNodeParameter('updateFields', i);
                        const { title, password, start, end, } = await GenericFunctions_1.webexApiRequest.call(this, 'GET', `/meetings/${meetingId}`);
                        const body = Object.assign({}, updateFields);
                        if (body.requireRegistrationInfo) {
                            body['registration'] = body.requireRegistrationInfo
                                .reduce((obj, value) => Object.assign(obj, { [`${value}`]: true }), {});
                            delete body.requireRegistrationInfo;
                        }
                        if (invitees.length) {
                            body['invitees'] = invitees;
                        }
                        if (body.start) {
                            body.start = moment.tz(updateFields.start, timezone).format();
                        }
                        else {
                            body.start = start;
                        }
                        if (body.end) {
                            body.end = moment.tz(updateFields.end, timezone).format();
                        }
                        else {
                            body.end = end;
                        }
                        if (!body.title) {
                            body.title = title;
                        }
                        if (!body.password) {
                            body.password = password;
                        }
                        responseData = await GenericFunctions_1.webexApiRequest.call(this, 'PUT', `/meetings/${meetingId}`, body);
                    }
                }
                if (Array.isArray(responseData)) {
                    returnData.push.apply(returnData, responseData);
                }
                else if (responseData !== undefined) {
                    returnData.push(responseData);
                }
            }
            catch (error) {
                if (this.continueOnFail()) {
                    returnData.push({ error: error.toString() });
                    continue;
                }
                throw error;
            }
        }
        return [this.helpers.returnJsonArray(returnData)];
    }
}
exports.CiscoWebex = CiscoWebex;
//# sourceMappingURL=CiscoWebex.node.js.map