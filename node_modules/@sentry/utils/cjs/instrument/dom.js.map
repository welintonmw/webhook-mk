{"version":3,"file":"dom.js","sources":["../../../src/instrument/dom.ts"],"sourcesContent":["// TODO(v8): Move everything in this file into the browser package. Nothing here is generic and we run risk of leaking browser types into non-browser packages.\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport type { HandlerDataDom } from '@sentry/types';\n\nimport { uuid4 } from '../misc';\nimport { addNonEnumerableProperty, fill } from '../object';\nimport { GLOBAL_OBJ } from '../worldwide';\nimport { addHandler, maybeInstrument, triggerHandlers } from './_handlers';\n\ntype SentryWrappedTarget = HTMLElement & { _sentryId?: string };\n\ntype AddEventListener = (\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | AddEventListenerOptions,\n) => void;\ntype RemoveEventListener = (\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | EventListenerOptions,\n) => void;\n\ntype InstrumentedElement = Element & {\n  __sentry_instrumentation_handlers__?: {\n    [key in 'click' | 'keypress']?: {\n      handler?: Function;\n      /** The number of custom listeners attached to this element */\n      refCount: number;\n    };\n  };\n};\n\nconst WINDOW = GLOBAL_OBJ as unknown as Window;\nconst DEBOUNCE_DURATION = 1000;\n\nlet debounceTimerID: number | undefined;\nlet lastCapturedEventType: string | undefined;\nlet lastCapturedEventTargetId: string | undefined;\n\n/**\n * Add an instrumentation handler for when a click or a keypress happens.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addClickKeypressInstrumentationHandler(handler: (data: HandlerDataDom) => void): void {\n  const type = 'dom';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentDOM);\n}\n\n/** Exported for tests only. */\nexport function instrumentDOM(): void {\n  if (!WINDOW.document) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  const triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  WINDOW.document.addEventListener('click', globalDOMEventHandler, false);\n  WINDOW.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach((target: string) => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const proto = (WINDOW as any)[target] && (WINDOW as any)[target].prototype;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function (originalAddEventListener: AddEventListener): AddEventListener {\n      return function (\n        this: Element,\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: boolean | AddEventListenerOptions,\n      ): AddEventListener {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const el = this as InstrumentedElement;\n            const handlers = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});\n            const handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });\n\n            if (!handlerForType.handler) {\n              const handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount++;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n\n    fill(\n      proto,\n      'removeEventListener',\n      function (originalRemoveEventListener: RemoveEventListener): RemoveEventListener {\n        return function (\n          this: Element,\n          type: string,\n          listener: EventListenerOrEventListenerObject,\n          options?: boolean | EventListenerOptions,\n        ): () => void {\n          if (type === 'click' || type == 'keypress') {\n            try {\n              const el = this as InstrumentedElement;\n              const handlers = el.__sentry_instrumentation_handlers__ || {};\n              const handlerForType = handlers[type];\n\n              if (handlerForType) {\n                handlerForType.refCount--;\n                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n                if (handlerForType.refCount <= 0) {\n                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                  handlerForType.handler = undefined;\n                  delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n                }\n\n                // If there are no longer any custom handlers of any type on this element, cleanup everything.\n                if (Object.keys(handlers).length === 0) {\n                  delete el.__sentry_instrumentation_handlers__;\n                }\n              }\n            } catch (e) {\n              // Accessing dom properties is always fragile.\n              // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n            }\n          }\n\n          return originalRemoveEventListener.call(this, type, listener, options);\n        };\n      },\n    );\n  });\n}\n\n/**\n * Check whether the event is similar to the last captured one. For example, two click events on the same button.\n */\nfunction isSimilarToLastCapturedEvent(event: Event): boolean {\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (event.type !== lastCapturedEventType) {\n    return false;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (!event.target || (event.target as SentryWrappedTarget)._sentryId !== lastCapturedEventTargetId) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return true;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(eventType: string, target: SentryWrappedTarget | null): boolean {\n  // We are only interested in filtering `keypress` events for now.\n  if (eventType !== 'keypress') {\n    return false;\n  }\n\n  if (!target || !target.tagName) {\n    return true;\n  }\n\n  // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n  // e.g.tabbing through elements, hotkeys, etc.\n  if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n */\nfunction makeDOMEventHandler(\n  handler: (data: HandlerDataDom) => void,\n  globalListener: boolean = false,\n): (event: Event) => void {\n  return (event: Event & { _sentryCaptured?: true }): void => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || event['_sentryCaptured']) {\n      return;\n    }\n\n    const target = getEventTarget(event);\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event.type, target)) {\n      return;\n    }\n\n    // Mark event as \"seen\"\n    addNonEnumerableProperty(event, '_sentryCaptured', true);\n\n    if (target && !target._sentryId) {\n      // Add UUID to event target so we can identify if\n      addNonEnumerableProperty(target, '_sentryId', uuid4());\n    }\n\n    const name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no last captured event, it means that we can safely capture the new event and store it for future comparisons.\n    // If there is a last captured event, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    if (!isSimilarToLastCapturedEvent(event)) {\n      const handlerData: HandlerDataDom = { event, name, global: globalListener };\n      handler(handlerData);\n      lastCapturedEventType = event.type;\n      lastCapturedEventTargetId = target ? target._sentryId : undefined;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = WINDOW.setTimeout(() => {\n      lastCapturedEventTargetId = undefined;\n      lastCapturedEventType = undefined;\n    }, DEBOUNCE_DURATION);\n  };\n}\n\nfunction getEventTarget(event: Event): SentryWrappedTarget | null {\n  try {\n    return event.target as SentryWrappedTarget | null;\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n    return null;\n  }\n}\n"],"names":["GLOBAL_OBJ","addHandler","maybeInstrument","triggerHandlers","fill","addNonEnumerableProperty","uuid4"],"mappings":"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"}