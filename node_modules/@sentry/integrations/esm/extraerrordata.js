import { isError, normalize, isPlainObject, addNonEnumerableProperty, logger } from '@sentry/utils';
import { DEBUG_BUILD } from './debug-build.js';

/** JSDoc */

/** Patch toString calls to return proper name for wrapped functions */
class ExtraErrorData  {
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'ExtraErrorData';}

  /**
   * @inheritDoc
   */

  /** JSDoc */

  /**
   * @inheritDoc
   */
   constructor(options) {
    this.name = ExtraErrorData.id;

    this._options = {
      depth: 3,
      ...options,
    };
  }

  /**
   * @inheritDoc
   */
   setupOnce(_addGlobalEventProcessor, _getCurrentHub) {
    // noop
  }

  /** @inheritDoc */
   processEvent(event, hint) {
    return this.enhanceEventWithErrorData(event, hint);
  }

  /**
   * Attaches extracted information from the Error object to extra field in the Event.
   *
   * TODO (v8): Drop this public function.
   */
   enhanceEventWithErrorData(event, hint = {}) {
    return _enhanceEventWithErrorData(event, hint, this._options.depth);
  }
} ExtraErrorData.__initStatic();

function _enhanceEventWithErrorData(event, hint = {}, depth) {
  if (!hint.originalException || !isError(hint.originalException)) {
    return event;
  }
  const exceptionName = (hint.originalException ).name || hint.originalException.constructor.name;

  const errorData = _extractErrorData(hint.originalException );

  if (errorData) {
    const contexts = {
      ...event.contexts,
    };

    const normalizedErrorData = normalize(errorData, depth);

    if (isPlainObject(normalizedErrorData)) {
      // We mark the error data as "already normalized" here, because we don't want other normalization procedures to
      // potentially truncate the data we just already normalized, with a certain depth setting.
      addNonEnumerableProperty(normalizedErrorData, '__sentry_skip_normalization__', true);
      contexts[exceptionName] = normalizedErrorData;
    }

    return {
      ...event,
      contexts,
    };
  }

  return event;
}

/**
 * Extract extra information from the Error object
 */
function _extractErrorData(error) {
  // We are trying to enhance already existing event, so no harm done if it won't succeed
  try {
    const nativeKeys = [
      'name',
      'message',
      'stack',
      'line',
      'column',
      'fileName',
      'lineNumber',
      'columnNumber',
      'toJSON',
    ];

    const extraErrorInfo = {};

    // We want only enumerable properties, thus `getOwnPropertyNames` is redundant here, as we filter keys anyway.
    for (const key of Object.keys(error)) {
      if (nativeKeys.indexOf(key) !== -1) {
        continue;
      }
      const value = error[key];
      extraErrorInfo[key] = isError(value) ? value.toString() : value;
    }

    // Check if someone attached `toJSON` method to grab even more properties (eg. axios is doing that)
    if (typeof error.toJSON === 'function') {
      const serializedError = error.toJSON() ;

      for (const key of Object.keys(serializedError)) {
        const value = serializedError[key];
        extraErrorInfo[key] = isError(value) ? value.toString() : value;
      }
    }

    return extraErrorInfo;
  } catch (oO) {
    DEBUG_BUILD && logger.error('Unable to extract extra data from the Error object:', oO);
  }

  return null;
}

export { ExtraErrorData };
//# sourceMappingURL=extraerrordata.js.map
