"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectStoreService = void 0;
const node_crypto_1 = require("node:crypto");
const axios_1 = __importDefault(require("axios"));
const typedi_1 = require("typedi");
const aws4_1 = require("aws4");
const utils_1 = require("./utils");
const n8n_workflow_1 = require("n8n-workflow");
let ObjectStoreService = class ObjectStoreService {
    constructor() {
        this.host = '';
        this.bucket = { region: '', name: '' };
        this.credentials = { accessKeyId: '', secretAccessKey: '' };
        this.isReady = false;
        this.isReadOnly = false;
        this.logger = n8n_workflow_1.LoggerProxy;
    }
    async init(host, bucket, credentials) {
        this.host = host;
        this.bucket.name = bucket.name;
        this.bucket.region = bucket.region;
        this.credentials = {
            accessKeyId: credentials.accessKey,
            secretAccessKey: credentials.accessSecret,
        };
        await this.checkConnection();
        this.setReady(true);
    }
    setReadonly(newState) {
        this.isReadOnly = newState;
    }
    setReady(newState) {
        this.isReady = newState;
    }
    async checkConnection() {
        if (this.isReady)
            return;
        return await this.request('HEAD', this.host, this.bucket.name);
    }
    async put(filename, buffer, metadata = {}) {
        if (this.isReadOnly)
            return await this.blockWrite(filename);
        const headers = {
            'Content-Length': buffer.length,
            'Content-MD5': (0, node_crypto_1.createHash)('md5').update(buffer).digest('base64'),
        };
        if (metadata.fileName)
            headers['x-amz-meta-filename'] = metadata.fileName;
        if (metadata.mimeType)
            headers['Content-Type'] = metadata.mimeType;
        const path = `/${this.bucket.name}/${filename}`;
        return await this.request('PUT', this.host, path, { headers, body: buffer });
    }
    async get(fileId, { mode }) {
        const path = `${this.bucket.name}/${fileId}`;
        const { data } = await this.request('GET', this.host, path, {
            responseType: mode === 'buffer' ? 'arraybuffer' : 'stream',
        });
        if (mode === 'stream' && (0, utils_1.isStream)(data))
            return data;
        if (mode === 'buffer' && Buffer.isBuffer(data))
            return data;
        throw new TypeError(`Expected ${mode} but received ${typeof data}.`);
    }
    async getMetadata(fileId) {
        const path = `${this.bucket.name}/${fileId}`;
        const response = await this.request('HEAD', this.host, path);
        return response.headers;
    }
    async deleteOne(fileId) {
        const path = `${this.bucket.name}/${fileId}`;
        return await this.request('DELETE', this.host, path);
    }
    async deleteMany(prefix) {
        const objects = await this.list(prefix);
        if (objects.length === 0)
            return;
        const innerXml = objects.map(({ key }) => `<Object><Key>${key}</Key></Object>`).join('\n');
        const body = ['<Delete>', innerXml, '</Delete>'].join('\n');
        const headers = {
            'Content-Type': 'application/xml',
            'Content-Length': body.length,
            'Content-MD5': (0, node_crypto_1.createHash)('md5').update(body).digest('base64'),
        };
        const path = `${this.bucket.name}/?delete`;
        return await this.request('POST', this.host, path, { headers, body });
    }
    async list(prefix) {
        var _a;
        const items = [];
        let isTruncated;
        let nextPageToken;
        do {
            const listPage = await this.getListPage(prefix, nextPageToken);
            if (((_a = listPage.contents) === null || _a === void 0 ? void 0 : _a.length) > 0)
                items.push(...listPage.contents);
            isTruncated = listPage.isTruncated;
            nextPageToken = listPage.nextContinuationToken;
        } while (isTruncated && nextPageToken);
        return items;
    }
    async getListPage(prefix, nextPageToken) {
        const qs = { 'list-type': 2, prefix };
        if (nextPageToken)
            qs['continuation-token'] = nextPageToken;
        const { data } = await this.request('GET', this.host, this.bucket.name, { qs });
        if (typeof data !== 'string') {
            throw new TypeError(`Expected XML string but received ${typeof data}`);
        }
        const { listBucketResult: page } = await (0, utils_1.parseXml)(data);
        if (!page.contents)
            return { ...page, contents: [] };
        if (!Array.isArray(page.contents))
            page.contents = [page.contents];
        page.contents.forEach((item) => {
            Object.setPrototypeOf(item, Object.prototype);
        });
        return page;
    }
    toPath(rawPath, qs) {
        const path = rawPath.startsWith('/') ? rawPath : `/${rawPath}`;
        if (!qs)
            return path;
        const qsParams = Object.entries(qs)
            .map(([key, value]) => `${key}=${value}`)
            .join('&');
        return path.concat(`?${qsParams}`);
    }
    async blockWrite(filename) {
        const logMessage = (0, utils_1.writeBlockedMessage)(filename);
        this.logger.warn(logMessage);
        return {
            status: 403,
            statusText: 'Forbidden',
            data: logMessage,
            headers: {},
            config: {},
        };
    }
    async request(method, host, rawPath = '', { qs, headers, body, responseType } = {}) {
        const path = this.toPath(rawPath, qs);
        const optionsToSign = {
            method,
            service: 's3',
            region: this.bucket.region,
            host,
            path,
        };
        if (headers)
            optionsToSign.headers = headers;
        if (body)
            optionsToSign.body = body;
        const signedOptions = (0, aws4_1.sign)(optionsToSign, this.credentials);
        const config = {
            method,
            url: `https://${host}${path}`,
            headers: signedOptions.headers,
        };
        if (body)
            config.data = body;
        if (responseType)
            config.responseType = responseType;
        try {
            this.logger.debug('Sending request to S3', { config });
            return await axios_1.default.request(config);
        }
        catch (e) {
            const error = e instanceof Error ? e : new Error(`${e}`);
            const message = `Request to S3 failed: ${error.message}`;
            this.logger.error(message, { config });
            throw new n8n_workflow_1.ApplicationError(message, { cause: error, extra: { config } });
        }
    }
};
exports.ObjectStoreService = ObjectStoreService;
exports.ObjectStoreService = ObjectStoreService = __decorate([
    (0, typedi_1.Service)()
], ObjectStoreService);
//# sourceMappingURL=ObjectStore.service.ee.js.map