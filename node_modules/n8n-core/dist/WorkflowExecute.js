"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowExecute = void 0;
const events_1 = require("events");
const p_cancelable_1 = __importDefault(require("p-cancelable"));
const n8n_workflow_1 = require("n8n-workflow");
const get_1 = __importDefault(require("lodash/get"));
const NodeExecuteFunctions = __importStar(require("./NodeExecuteFunctions"));
class WorkflowExecute {
    constructor(additionalData, mode, runExecutionData = {
        startData: {},
        resultData: {
            runData: {},
            pinData: {},
        },
        executionData: {
            contextData: {},
            nodeExecutionStack: [],
            metadata: {},
            waitingExecution: {},
            waitingExecutionSource: {},
        },
    }) {
        this.additionalData = additionalData;
        this.mode = mode;
        this.runExecutionData = runExecutionData;
        this.status = 'new';
        this.abortController = new AbortController();
    }
    run(workflow, startNode, destinationNode, pinData) {
        this.status = 'running';
        startNode = startNode || workflow.getStartNode(destinationNode);
        if (startNode === undefined) {
            throw new n8n_workflow_1.ApplicationError('No node to start the workflow from could be found');
        }
        let runNodeFilter;
        if (destinationNode) {
            runNodeFilter = workflow.getParentNodes(destinationNode);
            runNodeFilter.push(destinationNode);
        }
        const nodeExecutionStack = [
            {
                node: startNode,
                data: {
                    main: [
                        [
                            {
                                json: {},
                            },
                        ],
                    ],
                },
                source: null,
            },
        ];
        this.runExecutionData = {
            startData: {
                destinationNode,
                runNodeFilter,
            },
            resultData: {
                runData: {},
                pinData,
            },
            executionData: {
                contextData: {},
                nodeExecutionStack,
                metadata: {},
                waitingExecution: {},
                waitingExecutionSource: {},
            },
        };
        return this.processRunExecutionData(workflow);
    }
    static isAbortError(e) {
        return (e === null || e === void 0 ? void 0 : e.message) === 'AbortError';
    }
    forceInputNodeExecution(workflow) {
        return workflow.settings.executionOrder !== 'v1';
    }
    runPartialWorkflow(workflow, runData, startNodes, destinationNode, pinData) {
        var _a, _b, _c, _d, _e;
        let incomingNodeConnections;
        let connection;
        this.status = 'running';
        const runIndex = 0;
        let runNodeFilter;
        const nodeExecutionStack = [];
        const waitingExecution = {};
        const waitingExecutionSource = {};
        for (const startNode of startNodes) {
            incomingNodeConnections = workflow.connectionsByDestinationNode[startNode.name];
            const incomingData = [];
            let incomingSourceData = null;
            if (incomingNodeConnections === undefined) {
                incomingData.push([
                    {
                        json: {},
                    },
                ]);
            }
            else {
                incomingSourceData = { main: [] };
                for (const connections of incomingNodeConnections.main) {
                    for (let inputIndex = 0; inputIndex < connections.length; inputIndex++) {
                        connection = connections[inputIndex];
                        const node = workflow.getNode(connection.node);
                        if (node === null || node === void 0 ? void 0 : node.disabled)
                            continue;
                        if (node && pinData && pinData[node.name]) {
                            incomingData.push(pinData[node.name]);
                        }
                        else {
                            if (!runData[connection.node]) {
                                continue;
                            }
                            const nodeIncomingData = (_d = (_c = (_b = (_a = runData[connection.node]) === null || _a === void 0 ? void 0 : _a[runIndex]) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c[connection.type]) === null || _d === void 0 ? void 0 : _d[connection.index];
                            if (nodeIncomingData) {
                                incomingData.push(nodeIncomingData);
                            }
                        }
                        incomingSourceData.main.push((_e = startNode.sourceData) !== null && _e !== void 0 ? _e : { previousNode: connection.node });
                    }
                }
            }
            const executeData = {
                node: workflow.getNode(startNode.name),
                data: {
                    main: incomingData,
                },
                source: incomingSourceData,
            };
            nodeExecutionStack.push(executeData);
            if (destinationNode) {
                incomingNodeConnections = workflow.connectionsByDestinationNode[destinationNode];
                if (incomingNodeConnections !== undefined) {
                    for (const connections of incomingNodeConnections.main) {
                        for (let inputIndex = 0; inputIndex < connections.length; inputIndex++) {
                            connection = connections[inputIndex];
                            if (waitingExecution[destinationNode] === undefined) {
                                waitingExecution[destinationNode] = {};
                                waitingExecutionSource[destinationNode] = {};
                            }
                            if (waitingExecution[destinationNode][runIndex] === undefined) {
                                waitingExecution[destinationNode][runIndex] = {};
                                waitingExecutionSource[destinationNode][runIndex] = {};
                            }
                            if (waitingExecution[destinationNode][runIndex][connection.type] === undefined) {
                                waitingExecution[destinationNode][runIndex][connection.type] = [];
                                waitingExecutionSource[destinationNode][runIndex][connection.type] = [];
                            }
                            if (runData[connection.node] !== undefined) {
                                waitingExecution[destinationNode][runIndex][connection.type].push(runData[connection.node][runIndex].data[connection.type][connection.index]);
                                waitingExecutionSource[destinationNode][runIndex][connection.type].push({
                                    previousNode: connection.node,
                                    previousNodeOutput: connection.index || undefined,
                                    previousNodeRun: runIndex || undefined,
                                });
                            }
                            else {
                                waitingExecution[destinationNode][runIndex][connection.type].push(null);
                                waitingExecutionSource[destinationNode][runIndex][connection.type].push(null);
                            }
                        }
                    }
                }
                runNodeFilter = workflow
                    .getParentNodes(destinationNode)
                    .filter((parentNodeName) => { var _a; return !((_a = workflow.getNode(parentNodeName)) === null || _a === void 0 ? void 0 : _a.disabled); });
                runNodeFilter.push(destinationNode);
            }
        }
        this.runExecutionData = {
            startData: {
                destinationNode,
                runNodeFilter,
            },
            resultData: {
                runData,
                pinData,
            },
            executionData: {
                contextData: {},
                nodeExecutionStack,
                metadata: {},
                waitingExecution,
                waitingExecutionSource,
            },
        };
        return this.processRunExecutionData(workflow);
    }
    async executeHook(hookName, parameters) {
        if (this.additionalData.hooks === undefined) {
            return;
        }
        return await this.additionalData.hooks.executeHookFunctions(hookName, parameters);
    }
    moveNodeMetadata() {
        const metadata = (0, get_1.default)(this.runExecutionData, 'executionData.metadata');
        if (metadata) {
            const runData = (0, get_1.default)(this.runExecutionData, 'resultData.runData');
            let index;
            let metaRunData;
            for (const nodeName of Object.keys(metadata)) {
                for ([index, metaRunData] of metadata[nodeName].entries()) {
                    runData[nodeName][index].metadata = metaRunData;
                }
            }
        }
    }
    incomingConnectionIsEmpty(runData, inputConnections, runIndex) {
        for (const inputConnection of inputConnections) {
            const nodeIncomingData = (0, get_1.default)(runData, [
                inputConnection.node,
                runIndex,
                'data',
                'main',
                inputConnection.index,
            ]);
            if (nodeIncomingData !== undefined && nodeIncomingData.length !== 0) {
                return false;
            }
        }
        return true;
    }
    prepareWaitingToExecution(nodeName, numberOfConnections, runIndex) {
        if (!this.runExecutionData.executionData.waitingExecutionSource) {
            this.runExecutionData.executionData.waitingExecutionSource = {};
        }
        this.runExecutionData.executionData.waitingExecution[nodeName][runIndex] = {
            main: [],
        };
        this.runExecutionData.executionData.waitingExecutionSource[nodeName][runIndex] = {
            main: [],
        };
        for (let i = 0; i < numberOfConnections; i++) {
            this.runExecutionData.executionData.waitingExecution[nodeName][runIndex].main.push(null);
            this.runExecutionData.executionData.waitingExecutionSource[nodeName][runIndex].main.push(null);
        }
    }
    addNodeToBeExecuted(workflow, connectionData, outputIndex, parentNodeName, nodeSuccessData, runIndex) {
        let stillDataMissing = false;
        const enqueueFn = workflow.settings.executionOrder === 'v1' ? 'unshift' : 'push';
        let waitingNodeIndex;
        if (workflow.connectionsByDestinationNode[connectionData.node].main.length > 1) {
            let nodeWasWaiting = true;
            if (!this.runExecutionData.executionData.waitingExecutionSource) {
                this.runExecutionData.executionData.waitingExecutionSource = {};
            }
            if (this.runExecutionData.executionData.waitingExecution[connectionData.node] === undefined) {
                this.runExecutionData.executionData.waitingExecution[connectionData.node] = {};
                this.runExecutionData.executionData.waitingExecutionSource[connectionData.node] = {};
                nodeWasWaiting = false;
            }
            let createNewWaitingEntry = true;
            if (Object.keys(this.runExecutionData.executionData.waitingExecution[connectionData.node])
                .length > 0) {
                for (const index of Object.keys(this.runExecutionData.executionData.waitingExecution[connectionData.node])) {
                    if (!this.runExecutionData.executionData.waitingExecution[connectionData.node][parseInt(index)].main[connectionData.index]) {
                        createNewWaitingEntry = false;
                        waitingNodeIndex = parseInt(index);
                        break;
                    }
                }
            }
            if (waitingNodeIndex === undefined) {
                waitingNodeIndex = Object.values(this.runExecutionData.executionData.waitingExecution[connectionData.node]).length;
            }
            if (createNewWaitingEntry) {
                this.prepareWaitingToExecution(connectionData.node, workflow.connectionsByDestinationNode[connectionData.node].main.length, waitingNodeIndex);
            }
            if (nodeSuccessData === null) {
                this.runExecutionData.executionData.waitingExecution[connectionData.node][waitingNodeIndex].main[connectionData.index] = null;
                this.runExecutionData.executionData.waitingExecutionSource[connectionData.node][waitingNodeIndex].main[connectionData.index] = null;
            }
            else {
                this.runExecutionData.executionData.waitingExecution[connectionData.node][waitingNodeIndex].main[connectionData.index] = nodeSuccessData[outputIndex];
                this.runExecutionData.executionData.waitingExecutionSource[connectionData.node][waitingNodeIndex].main[connectionData.index] = {
                    previousNode: parentNodeName,
                    previousNodeOutput: outputIndex || undefined,
                    previousNodeRun: runIndex || undefined,
                };
            }
            let thisExecutionData;
            let allDataFound = true;
            for (let i = 0; i <
                this.runExecutionData.executionData.waitingExecution[connectionData.node][waitingNodeIndex]
                    .main.length; i++) {
                thisExecutionData =
                    this.runExecutionData.executionData.waitingExecution[connectionData.node][waitingNodeIndex].main[i];
                if (thisExecutionData === null) {
                    allDataFound = false;
                    break;
                }
            }
            if (allDataFound) {
                const executionStackItem = {
                    node: workflow.nodes[connectionData.node],
                    data: this.runExecutionData.executionData.waitingExecution[connectionData.node][waitingNodeIndex],
                    source: this.runExecutionData.executionData.waitingExecutionSource[connectionData.node][waitingNodeIndex],
                };
                if (this.runExecutionData.executionData.waitingExecutionSource !== null &&
                    this.runExecutionData.executionData.waitingExecutionSource !== undefined) {
                    executionStackItem.source =
                        this.runExecutionData.executionData.waitingExecutionSource[connectionData.node][waitingNodeIndex];
                }
                this.runExecutionData.executionData.nodeExecutionStack[enqueueFn](executionStackItem);
                delete this.runExecutionData.executionData.waitingExecution[connectionData.node][waitingNodeIndex];
                delete this.runExecutionData.executionData.waitingExecutionSource[connectionData.node][waitingNodeIndex];
                if (Object.keys(this.runExecutionData.executionData.waitingExecution[connectionData.node])
                    .length === 0) {
                    delete this.runExecutionData.executionData.waitingExecution[connectionData.node];
                    delete this.runExecutionData.executionData.waitingExecutionSource[connectionData.node];
                }
                return;
            }
            stillDataMissing = true;
            if (!nodeWasWaiting) {
                const checkOutputNodes = [];
                for (const outputIndexParent in workflow.connectionsBySourceNode[parentNodeName].main) {
                    if (!workflow.connectionsBySourceNode[parentNodeName].main.hasOwnProperty(outputIndexParent)) {
                        continue;
                    }
                    for (const connectionDataCheck of workflow.connectionsBySourceNode[parentNodeName].main[outputIndexParent]) {
                        checkOutputNodes.push(connectionDataCheck.node);
                    }
                }
                const forceInputNodeExecution = this.forceInputNodeExecution(workflow);
                for (let inputIndex = 0; inputIndex < workflow.connectionsByDestinationNode[connectionData.node].main.length; inputIndex++) {
                    for (const inputData of workflow.connectionsByDestinationNode[connectionData.node].main[inputIndex]) {
                        if (inputData.node === parentNodeName) {
                            continue;
                        }
                        const executionStackNodes = this.runExecutionData.executionData.nodeExecutionStack.map((stackData) => stackData.node.name);
                        if (inputData.node !== parentNodeName && checkOutputNodes.includes(inputData.node)) {
                            if (!this.incomingConnectionIsEmpty(this.runExecutionData.resultData.runData, workflow.connectionsByDestinationNode[inputData.node].main[0], runIndex)) {
                                continue;
                            }
                        }
                        if (executionStackNodes.includes(inputData.node)) {
                            continue;
                        }
                        if (this.runExecutionData.resultData.runData[inputData.node] !== undefined) {
                            continue;
                        }
                        if (!forceInputNodeExecution) {
                            continue;
                        }
                        const parentNodes = workflow.getParentNodes(inputData.node, 'main', -1);
                        let nodeToAdd = inputData.node;
                        parentNodes.push(inputData.node);
                        parentNodes.reverse();
                        for (const parentNode of parentNodes) {
                            if (inputData.node !== parentNode && checkOutputNodes.includes(parentNode)) {
                                nodeToAdd = undefined;
                                break;
                            }
                            if (executionStackNodes.includes(parentNode)) {
                                nodeToAdd = undefined;
                                break;
                            }
                            if (this.runExecutionData.resultData.runData[parentNode] !== undefined) {
                                break;
                            }
                            nodeToAdd = parentNode;
                        }
                        const parentNodesNodeToAdd = workflow.getParentNodes(nodeToAdd);
                        if (parentNodesNodeToAdd.includes(parentNodeName) &&
                            nodeSuccessData[outputIndex].length === 0) {
                            nodeToAdd = undefined;
                        }
                        if (nodeToAdd === undefined) {
                            continue;
                        }
                        let addEmptyItem = false;
                        if (workflow.connectionsByDestinationNode[nodeToAdd] === undefined) {
                            addEmptyItem = true;
                        }
                        else if (this.incomingConnectionIsEmpty(this.runExecutionData.resultData.runData, workflow.connectionsByDestinationNode[nodeToAdd].main[0], runIndex)) {
                            addEmptyItem = true;
                        }
                        if (addEmptyItem) {
                            this.runExecutionData.executionData.nodeExecutionStack[enqueueFn]({
                                node: workflow.getNode(nodeToAdd),
                                data: {
                                    main: [
                                        [
                                            {
                                                json: {},
                                            },
                                        ],
                                    ],
                                },
                                source: {
                                    main: [
                                        {
                                            previousNode: parentNodeName,
                                            previousNodeOutput: outputIndex || undefined,
                                            previousNodeRun: runIndex || undefined,
                                        },
                                    ],
                                },
                            });
                        }
                    }
                }
            }
        }
        const connectionDataArray = [];
        for (let i = connectionData.index; i >= 0; i--) {
            connectionDataArray[i] = null;
        }
        if (nodeSuccessData === null) {
            connectionDataArray[connectionData.index] = null;
        }
        else {
            connectionDataArray[connectionData.index] = nodeSuccessData[outputIndex];
        }
        if (stillDataMissing) {
            waitingNodeIndex = waitingNodeIndex;
            this.prepareWaitingToExecution(connectionData.node, workflow.connectionsByDestinationNode[connectionData.node].main.length, waitingNodeIndex);
            this.runExecutionData.executionData.waitingExecution[connectionData.node][waitingNodeIndex] =
                {
                    main: connectionDataArray,
                };
            this.runExecutionData.executionData.waitingExecutionSource[connectionData.node][waitingNodeIndex].main[connectionData.index] = {
                previousNode: parentNodeName,
                previousNodeOutput: outputIndex || undefined,
                previousNodeRun: runIndex || undefined,
            };
        }
        else {
            this.runExecutionData.executionData.nodeExecutionStack[enqueueFn]({
                node: workflow.nodes[connectionData.node],
                data: {
                    main: connectionDataArray,
                },
                source: {
                    main: [
                        {
                            previousNode: parentNodeName,
                            previousNodeOutput: outputIndex || undefined,
                            previousNodeRun: runIndex || undefined,
                        },
                    ],
                },
            });
        }
    }
    processRunExecutionData(workflow) {
        var _a;
        n8n_workflow_1.LoggerProxy.verbose('Workflow execution started', { workflowId: workflow.id });
        const startedAt = new Date();
        const forceInputNodeExecution = this.forceInputNodeExecution(workflow);
        this.status = 'running';
        const startNode = this.runExecutionData.executionData.nodeExecutionStack[0].node.name;
        let destinationNode;
        if (this.runExecutionData.startData && this.runExecutionData.startData.destinationNode) {
            destinationNode = this.runExecutionData.startData.destinationNode;
        }
        const pinDataNodeNames = Object.keys((_a = this.runExecutionData.resultData.pinData) !== null && _a !== void 0 ? _a : {});
        const workflowIssues = workflow.checkReadyForExecution({
            startNode,
            destinationNode,
            pinDataNodeNames,
        });
        if (workflowIssues !== null) {
            throw new n8n_workflow_1.WorkflowOperationError('The workflow has issues and can for that reason not be executed. Please fix them first.');
        }
        let executionData;
        let executionError;
        let executionHints = [];
        let executionNode;
        let nodeSuccessData;
        let runIndex;
        let startTime;
        let taskData;
        if (this.runExecutionData.startData === undefined) {
            this.runExecutionData.startData = {};
        }
        if (this.runExecutionData.waitTill) {
            const lastNodeExecuted = this.runExecutionData.resultData.lastNodeExecuted;
            this.runExecutionData.executionData.nodeExecutionStack[0].node.disabled = true;
            this.runExecutionData.waitTill = undefined;
            this.runExecutionData.resultData.runData[lastNodeExecuted].pop();
        }
        let currentExecutionTry = '';
        let lastExecutionTry = '';
        let closeFunction;
        return new p_cancelable_1.default(async (resolve, _reject, onCancel) => {
            (0, events_1.setMaxListeners)(Infinity, this.abortController.signal);
            onCancel.shouldReject = false;
            onCancel(() => {
                this.status = 'canceled';
                this.abortController.abort();
                const fullRunData = this.getFullRunData(startedAt);
                void this.executeHook('workflowExecuteAfter', [fullRunData]);
            });
            const returnPromise = (async () => {
                var _a, _b, _c, _d, _e;
                try {
                    if (!this.additionalData.restartExecutionId) {
                        await this.executeHook('workflowExecuteBefore', [workflow]);
                    }
                }
                catch (error) {
                    const e = error;
                    executionError = {
                        ...e,
                        message: e.message,
                        stack: e.stack,
                    };
                    executionData = this.runExecutionData.executionData.nodeExecutionStack[0];
                    this.runExecutionData.resultData = {
                        runData: {
                            [executionData.node.name]: [
                                {
                                    startTime,
                                    executionTime: new Date().getTime() - startTime,
                                    data: {
                                        main: executionData.data.main,
                                    },
                                    source: [],
                                    executionStatus: 'error',
                                },
                            ],
                        },
                        lastNodeExecuted: executionData.node.name,
                        error: executionError,
                    };
                    throw error;
                }
                executionLoop: while (this.runExecutionData.executionData.nodeExecutionStack.length !== 0) {
                    if (this.additionalData.executionTimeoutTimestamp !== undefined &&
                        Date.now() >= this.additionalData.executionTimeoutTimestamp) {
                        this.status = 'canceled';
                    }
                    if (this.status === 'canceled') {
                        return;
                    }
                    nodeSuccessData = null;
                    executionError = undefined;
                    executionHints = [];
                    executionData =
                        this.runExecutionData.executionData.nodeExecutionStack.shift();
                    executionNode = executionData.node;
                    const newTaskDataConnections = {};
                    for (const inputName of Object.keys(executionData.data)) {
                        newTaskDataConnections[inputName] = executionData.data[inputName].map((input, inputIndex) => {
                            if (input === null) {
                                return input;
                            }
                            return input.map((item, itemIndex) => {
                                return {
                                    ...item,
                                    pairedItem: {
                                        item: itemIndex,
                                        input: inputIndex || undefined,
                                    },
                                };
                            });
                        });
                    }
                    executionData.data = newTaskDataConnections;
                    n8n_workflow_1.LoggerProxy.debug(`Start processing node "${executionNode.name}"`, {
                        node: executionNode.name,
                        workflowId: workflow.id,
                    });
                    await this.executeHook('nodeExecuteBefore', [executionNode.name]);
                    runIndex = 0;
                    if (this.runExecutionData.resultData.runData.hasOwnProperty(executionNode.name)) {
                        runIndex = this.runExecutionData.resultData.runData[executionNode.name].length;
                    }
                    currentExecutionTry = `${executionNode.name}:${runIndex}`;
                    if (currentExecutionTry === lastExecutionTry) {
                        throw new n8n_workflow_1.ApplicationError('Stopped execution because it seems to be in an endless loop');
                    }
                    if (this.runExecutionData.startData.runNodeFilter !== undefined &&
                        this.runExecutionData.startData.runNodeFilter.indexOf(executionNode.name) === -1) {
                        continue;
                    }
                    if (workflow.connectionsByDestinationNode.hasOwnProperty(executionNode.name)) {
                        if (workflow.connectionsByDestinationNode[executionNode.name].hasOwnProperty('main')) {
                            let inputConnections;
                            let connectionIndex;
                            inputConnections = workflow.connectionsByDestinationNode[executionNode.name].main;
                            for (connectionIndex = 0; connectionIndex < inputConnections.length; connectionIndex++) {
                                if (workflow.getHighestNode(executionNode.name, 'main', connectionIndex).length === 0) {
                                    continue;
                                }
                                if (!executionData.data.hasOwnProperty('main')) {
                                    this.runExecutionData.executionData.nodeExecutionStack.push(executionData);
                                    lastExecutionTry = currentExecutionTry;
                                    continue executionLoop;
                                }
                                if (forceInputNodeExecution) {
                                    if (executionData.data.main.length < connectionIndex ||
                                        executionData.data.main[connectionIndex] === null) {
                                        this.runExecutionData.executionData.nodeExecutionStack.push(executionData);
                                        lastExecutionTry = currentExecutionTry;
                                        continue executionLoop;
                                    }
                                }
                            }
                        }
                    }
                    startTime = new Date().getTime();
                    let maxTries = 1;
                    if (executionData.node.retryOnFail === true) {
                        maxTries = Math.min(5, Math.max(2, executionData.node.maxTries || 3));
                    }
                    let waitBetweenTries = 0;
                    if (executionData.node.retryOnFail === true) {
                        waitBetweenTries = Math.min(5000, Math.max(0, executionData.node.waitBetweenTries || 1000));
                    }
                    for (let tryIndex = 0; tryIndex < maxTries; tryIndex++) {
                        try {
                            if (tryIndex !== 0) {
                                executionError = undefined;
                                if (waitBetweenTries !== 0) {
                                    await new Promise((resolve) => {
                                        setTimeout(() => {
                                            resolve(undefined);
                                        }, waitBetweenTries);
                                    });
                                }
                            }
                            const { pinData } = this.runExecutionData.resultData;
                            if (pinData && !executionNode.disabled && pinData[executionNode.name] !== undefined) {
                                const nodePinData = pinData[executionNode.name];
                                nodeSuccessData = [nodePinData];
                            }
                            else {
                                n8n_workflow_1.LoggerProxy.debug(`Running node "${executionNode.name}" started`, {
                                    node: executionNode.name,
                                    workflowId: workflow.id,
                                });
                                let runNodeData = await workflow.runNode(executionData, this.runExecutionData, runIndex, this.additionalData, NodeExecuteFunctions, this.mode, this.abortController.signal);
                                nodeSuccessData = runNodeData.data;
                                const didContinueOnFail = ((_c = (_b = (_a = nodeSuccessData === null || nodeSuccessData === void 0 ? void 0 : nodeSuccessData.at(0)) === null || _a === void 0 ? void 0 : _a.at(0)) === null || _b === void 0 ? void 0 : _b.json) === null || _c === void 0 ? void 0 : _c.error) !== undefined;
                                while (didContinueOnFail && tryIndex !== maxTries - 1) {
                                    await (0, n8n_workflow_1.sleep)(waitBetweenTries);
                                    runNodeData = await workflow.runNode(executionData, this.runExecutionData, runIndex, this.additionalData, NodeExecuteFunctions, this.mode, this.abortController.signal);
                                    tryIndex++;
                                }
                                if (nodeSuccessData instanceof n8n_workflow_1.NodeExecutionOutput) {
                                    const hints = nodeSuccessData.getHints();
                                    executionHints.push(...hints);
                                }
                                if (nodeSuccessData && executionData.node.onError === 'continueErrorOutput') {
                                    const nodeType = workflow.nodeTypes.getByNameAndVersion(executionData.node.type, executionData.node.typeVersion);
                                    const outputs = n8n_workflow_1.NodeHelpers.getNodeOutputs(workflow, executionData.node, nodeType.description);
                                    const outputTypes = n8n_workflow_1.NodeHelpers.getConnectionTypes(outputs);
                                    const mainOutputTypes = outputTypes.filter((output) => output === "main");
                                    const errorItems = [];
                                    const successItems = [];
                                    const closeFunctions = [];
                                    const executeFunctions = NodeExecuteFunctions.getExecuteFunctions(workflow, this.runExecutionData, runIndex, [], executionData.data, executionData.node, this.additionalData, executionData, this.mode, closeFunctions, this.abortController.signal);
                                    const dataProxy = executeFunctions.getWorkflowDataProxy(0);
                                    for (let outputIndex = 0; outputIndex < mainOutputTypes.length - 1; outputIndex++) {
                                        successItems.length = 0;
                                        const items = nodeSuccessData.length ? nodeSuccessData[0] : [];
                                        while (items.length) {
                                            const item = items.pop();
                                            if (item === undefined) {
                                                continue;
                                            }
                                            let errorData;
                                            if (item.error) {
                                                errorData = item.error;
                                                item.error = undefined;
                                            }
                                            else if (item.json.error && Object.keys(item.json).length === 1) {
                                                errorData = item.json.error;
                                            }
                                            else if (item.json.error &&
                                                item.json.message &&
                                                Object.keys(item.json).length === 2) {
                                                errorData = item.json.error;
                                            }
                                            if (errorData) {
                                                const pairedItemData = item.pairedItem && typeof item.pairedItem === 'object'
                                                    ? Array.isArray(item.pairedItem)
                                                        ? item.pairedItem[0]
                                                        : item.pairedItem
                                                    : undefined;
                                                if (executionData.source === null || pairedItemData === undefined) {
                                                    errorItems.push(item);
                                                }
                                                else {
                                                    const pairedItemInputIndex = pairedItemData.input || 0;
                                                    const sourceData = executionData.source["main"][pairedItemInputIndex];
                                                    const constPairedItem = dataProxy.$getPairedItem(sourceData.previousNode, sourceData, pairedItemData);
                                                    if (constPairedItem === null) {
                                                        errorItems.push(item);
                                                    }
                                                    else {
                                                        errorItems.push({
                                                            ...item,
                                                            json: {
                                                                ...constPairedItem.json,
                                                                ...item.json,
                                                            },
                                                        });
                                                    }
                                                }
                                            }
                                            else {
                                                successItems.push(item);
                                            }
                                        }
                                        nodeSuccessData[outputIndex] = successItems;
                                    }
                                    nodeSuccessData[mainOutputTypes.length - 1] = errorItems;
                                }
                                if (runNodeData.closeFunction) {
                                    closeFunction = runNodeData.closeFunction();
                                }
                            }
                            n8n_workflow_1.LoggerProxy.debug(`Running node "${executionNode.name}" finished successfully`, {
                                node: executionNode.name,
                                workflowId: workflow.id,
                            });
                            if (nodeSuccessData === null || nodeSuccessData === void 0 ? void 0 : nodeSuccessData.length) {
                                const isSingleInputAndOutput = executionData.data.main.length === 1 && ((_d = executionData.data.main[0]) === null || _d === void 0 ? void 0 : _d.length) === 1;
                                const isSameNumberOfItems = nodeSuccessData.length === 1 &&
                                    executionData.data.main.length === 1 &&
                                    ((_e = executionData.data.main[0]) === null || _e === void 0 ? void 0 : _e.length) === nodeSuccessData[0].length;
                                checkOutputData: for (const outputData of nodeSuccessData) {
                                    if (outputData === null) {
                                        continue;
                                    }
                                    for (const [index, item] of outputData.entries()) {
                                        if (item.pairedItem === undefined) {
                                            if (isSingleInputAndOutput) {
                                                item.pairedItem = {
                                                    item: 0,
                                                };
                                            }
                                            else if (isSameNumberOfItems) {
                                                item.pairedItem = {
                                                    item: index,
                                                };
                                            }
                                            else {
                                                break checkOutputData;
                                            }
                                        }
                                    }
                                }
                            }
                            if (nodeSuccessData === undefined) {
                                nodeSuccessData = null;
                            }
                            else {
                                this.runExecutionData.resultData.lastNodeExecuted = executionData.node.name;
                            }
                            if (nodeSuccessData === null || nodeSuccessData[0][0] === undefined) {
                                if (executionData.node.alwaysOutputData === true) {
                                    const pairedItem = [];
                                    executionData.data.main.forEach((inputData, inputIndex) => {
                                        if (!inputData) {
                                            return;
                                        }
                                        inputData.forEach((_item, itemIndex) => {
                                            pairedItem.push({
                                                item: itemIndex,
                                                input: inputIndex,
                                            });
                                        });
                                    });
                                    nodeSuccessData = nodeSuccessData || [];
                                    nodeSuccessData[0] = [
                                        {
                                            json: {},
                                            pairedItem,
                                        },
                                    ];
                                }
                            }
                            if (nodeSuccessData === null && !this.runExecutionData.waitTill) {
                                continue executionLoop;
                            }
                            break;
                        }
                        catch (error) {
                            this.runExecutionData.resultData.lastNodeExecuted = executionData.node.name;
                            const message = error instanceof n8n_workflow_1.ApplicationError ? error.message : n8n_workflow_1.OBFUSCATED_ERROR_MESSAGE;
                            const e = error;
                            executionError = { ...e, message, stack: e.stack };
                            n8n_workflow_1.LoggerProxy.debug(`Running node "${executionNode.name}" finished with error`, {
                                node: executionNode.name,
                                workflowId: workflow.id,
                            });
                        }
                    }
                    if (!this.runExecutionData.resultData.runData.hasOwnProperty(executionNode.name)) {
                        this.runExecutionData.resultData.runData[executionNode.name] = [];
                    }
                    taskData = {
                        hints: executionHints,
                        startTime,
                        executionTime: new Date().getTime() - startTime,
                        source: !executionData.source ? [] : executionData.source.main,
                        executionStatus: 'success',
                    };
                    if (executionError !== undefined) {
                        taskData.error = executionError;
                        taskData.executionStatus = 'error';
                        if (executionData.node.continueOnFail === true ||
                            ['continueRegularOutput', 'continueErrorOutput'].includes(executionData.node.onError || '')) {
                            if (executionData.data.hasOwnProperty('main') && executionData.data.main.length > 0) {
                                if (executionData.data.main[0] !== null) {
                                    nodeSuccessData = [executionData.data.main[0]];
                                }
                            }
                        }
                        else {
                            this.runExecutionData.resultData.runData[executionNode.name].push(taskData);
                            this.runExecutionData.executionData.nodeExecutionStack.unshift(executionData);
                            if (!WorkflowExecute.isAbortError(executionError)) {
                                await this.executeHook('nodeExecuteAfter', [
                                    executionNode.name,
                                    taskData,
                                    this.runExecutionData,
                                ]);
                            }
                            break;
                        }
                    }
                    for (const execution of nodeSuccessData) {
                        for (const lineResult of execution) {
                            if (lineResult.json !== undefined &&
                                lineResult.json.$error !== undefined &&
                                lineResult.json.$json !== undefined) {
                                lineResult.error = lineResult.json.$error;
                                lineResult.json = {
                                    error: lineResult.json.$error.message,
                                };
                            }
                            else if (lineResult.error !== undefined) {
                                lineResult.json = { error: lineResult.error.message };
                            }
                        }
                    }
                    taskData.data = {
                        main: nodeSuccessData,
                    };
                    this.runExecutionData.resultData.runData[executionNode.name].push(taskData);
                    if (this.runExecutionData.waitTill) {
                        await this.executeHook('nodeExecuteAfter', [
                            executionNode.name,
                            taskData,
                            this.runExecutionData,
                        ]);
                        this.runExecutionData.executionData.nodeExecutionStack.unshift(executionData);
                        break;
                    }
                    if (this.runExecutionData.startData &&
                        this.runExecutionData.startData.destinationNode &&
                        this.runExecutionData.startData.destinationNode === executionNode.name) {
                        await this.executeHook('nodeExecuteAfter', [
                            executionNode.name,
                            taskData,
                            this.runExecutionData,
                        ]);
                        continue;
                    }
                    if (workflow.connectionsBySourceNode.hasOwnProperty(executionNode.name)) {
                        if (workflow.connectionsBySourceNode[executionNode.name].hasOwnProperty('main')) {
                            let outputIndex;
                            let connectionData;
                            const nodesToAdd = [];
                            for (outputIndex in workflow.connectionsBySourceNode[executionNode.name].main) {
                                if (!workflow.connectionsBySourceNode[executionNode.name].main.hasOwnProperty(outputIndex)) {
                                    continue;
                                }
                                for (connectionData of workflow.connectionsBySourceNode[executionNode.name].main[outputIndex]) {
                                    if (!workflow.nodes.hasOwnProperty(connectionData.node)) {
                                        throw new n8n_workflow_1.ApplicationError('Destination node not found', {
                                            extra: {
                                                sourceNodeName: executionNode.name,
                                                destinationNodeName: connectionData.node,
                                            },
                                        });
                                    }
                                    if (nodeSuccessData[outputIndex] &&
                                        (nodeSuccessData[outputIndex].length !== 0 ||
                                            (connectionData.index > 0 && forceInputNodeExecution))) {
                                        if (workflow.settings.executionOrder === 'v1') {
                                            const nodeToAdd = workflow.getNode(connectionData.node);
                                            nodesToAdd.push({
                                                position: (nodeToAdd === null || nodeToAdd === void 0 ? void 0 : nodeToAdd.position) || [0, 0],
                                                connection: connectionData,
                                                outputIndex: parseInt(outputIndex, 10),
                                            });
                                        }
                                        else {
                                            this.addNodeToBeExecuted(workflow, connectionData, parseInt(outputIndex, 10), executionNode.name, nodeSuccessData, runIndex);
                                        }
                                    }
                                }
                            }
                            if (workflow.settings.executionOrder === 'v1') {
                                nodesToAdd.sort((a, b) => {
                                    if (a.position[1] < b.position[1]) {
                                        return 1;
                                    }
                                    if (a.position[1] > b.position[1]) {
                                        return -1;
                                    }
                                    if (a.position[0] > b.position[0]) {
                                        return -1;
                                    }
                                    return 0;
                                });
                                for (const nodeData of nodesToAdd) {
                                    this.addNodeToBeExecuted(workflow, nodeData.connection, nodeData.outputIndex, executionNode.name, nodeSuccessData, runIndex);
                                }
                            }
                        }
                    }
                    await this.executeHook('nodeExecuteAfter', [
                        executionNode.name,
                        taskData,
                        this.runExecutionData,
                    ]);
                    let waitingNodes = Object.keys(this.runExecutionData.executionData.waitingExecution);
                    if (this.runExecutionData.executionData.nodeExecutionStack.length === 0 &&
                        waitingNodes.length) {
                        for (let i = 0; i < waitingNodes.length; i++) {
                            const nodeName = waitingNodes[i];
                            const checkNode = workflow.getNode(nodeName);
                            if (!checkNode) {
                                continue;
                            }
                            const nodeType = workflow.nodeTypes.getByNameAndVersion(checkNode.type, checkNode.typeVersion);
                            let requiredInputs = workflow.settings.executionOrder === 'v1'
                                ? nodeType.description.requiredInputs
                                : undefined;
                            if (requiredInputs !== undefined) {
                                if (typeof requiredInputs === 'string') {
                                    requiredInputs = workflow.expression.getSimpleParameterValue(checkNode, requiredInputs, this.mode, { $version: checkNode.typeVersion }, undefined, []);
                                }
                                if ((requiredInputs !== undefined &&
                                    Array.isArray(requiredInputs) &&
                                    requiredInputs.length === nodeType.description.inputs.length) ||
                                    requiredInputs === nodeType.description.inputs.length) {
                                    continue;
                                }
                            }
                            const parentNodes = workflow.getParentNodes(nodeName);
                            const parentIsWaiting = parentNodes.some((value) => waitingNodes.includes(value));
                            if (parentIsWaiting) {
                                continue;
                            }
                            const runIndexes = Object.keys(this.runExecutionData.executionData.waitingExecution[nodeName]).sort();
                            const firstRunIndex = parseInt(runIndexes[0]);
                            const inputsWithData = this.runExecutionData
                                .executionData.waitingExecution[nodeName][firstRunIndex].main.map((data, index) => (data === null ? null : index))
                                .filter((data) => data !== null);
                            if (requiredInputs !== undefined) {
                                if (Array.isArray(requiredInputs)) {
                                    let inputDataMissing = false;
                                    for (const requiredInput of requiredInputs) {
                                        if (!inputsWithData.includes(requiredInput)) {
                                            inputDataMissing = true;
                                            break;
                                        }
                                    }
                                    if (inputDataMissing) {
                                        continue;
                                    }
                                }
                                else {
                                    if (inputsWithData.length < requiredInputs) {
                                        continue;
                                    }
                                }
                            }
                            const taskDataMain = this.runExecutionData.executionData.waitingExecution[nodeName][firstRunIndex].main.map((data) => {
                                return data === null ? [] : data;
                            });
                            if (taskDataMain.filter((data) => data.length).length !== 0) {
                                if (taskDataMain.length < nodeType.description.inputs.length) {
                                    for (; taskDataMain.length < nodeType.description.inputs.length;) {
                                        taskDataMain.push([]);
                                    }
                                }
                                this.runExecutionData.executionData.nodeExecutionStack.push({
                                    node: workflow.nodes[nodeName],
                                    data: {
                                        main: taskDataMain,
                                    },
                                    source: this.runExecutionData.executionData.waitingExecutionSource[nodeName][firstRunIndex],
                                });
                            }
                            delete this.runExecutionData.executionData.waitingExecution[nodeName][firstRunIndex];
                            delete this.runExecutionData.executionData.waitingExecutionSource[nodeName][firstRunIndex];
                            if (Object.keys(this.runExecutionData.executionData.waitingExecution[nodeName])
                                .length === 0) {
                                delete this.runExecutionData.executionData.waitingExecution[nodeName];
                                delete this.runExecutionData.executionData.waitingExecutionSource[nodeName];
                            }
                            if (taskDataMain.filter((data) => data.length).length !== 0) {
                                break;
                            }
                            else {
                                waitingNodes = Object.keys(this.runExecutionData.executionData.waitingExecution);
                                i = -1;
                            }
                        }
                    }
                }
                return;
            })()
                .then(async () => {
                if (this.status === 'canceled' && executionError === undefined) {
                    return await this.processSuccessExecution(startedAt, workflow, new n8n_workflow_1.WorkflowOperationError('Workflow has been canceled or timed out'), closeFunction);
                }
                return await this.processSuccessExecution(startedAt, workflow, executionError, closeFunction);
            })
                .catch(async (error) => {
                const fullRunData = this.getFullRunData(startedAt);
                fullRunData.data.resultData.error = {
                    ...error,
                    message: error.message,
                    stack: error.stack,
                };
                let newStaticData;
                if (workflow.staticData.__dataChanged === true) {
                    newStaticData = workflow.staticData;
                }
                this.moveNodeMetadata();
                await this.executeHook('workflowExecuteAfter', [fullRunData, newStaticData]).catch((error) => {
                    console.error('There was a problem running hook "workflowExecuteAfter"', error);
                });
                if (closeFunction) {
                    try {
                        await closeFunction;
                    }
                    catch (errorClose) {
                        n8n_workflow_1.LoggerProxy.error(`There was a problem deactivating trigger of workflow "${workflow.id}": "${errorClose.message}"`, {
                            workflowId: workflow.id,
                        });
                    }
                }
                return fullRunData;
            });
            return await returnPromise.then(resolve);
        });
    }
    async processSuccessExecution(startedAt, workflow, executionError, closeFunction) {
        var _a;
        const fullRunData = this.getFullRunData(startedAt);
        if (executionError !== undefined) {
            n8n_workflow_1.LoggerProxy.verbose('Workflow execution finished with error', {
                error: executionError,
                workflowId: workflow.id,
            });
            fullRunData.data.resultData.error = {
                ...executionError,
                message: executionError.message,
                stack: executionError.stack,
            };
            if ((_a = executionError.message) === null || _a === void 0 ? void 0 : _a.includes('canceled')) {
                fullRunData.status = 'canceled';
            }
        }
        else if (this.runExecutionData.waitTill) {
            n8n_workflow_1.LoggerProxy.verbose(`Workflow execution will wait until ${this.runExecutionData.waitTill}`, {
                workflowId: workflow.id,
            });
            fullRunData.waitTill = this.runExecutionData.waitTill;
            fullRunData.status = 'waiting';
        }
        else {
            n8n_workflow_1.LoggerProxy.verbose('Workflow execution finished successfully', { workflowId: workflow.id });
            fullRunData.finished = true;
            fullRunData.status = 'success';
        }
        let newStaticData;
        if (workflow.staticData.__dataChanged === true) {
            newStaticData = workflow.staticData;
        }
        this.moveNodeMetadata();
        if (!WorkflowExecute.isAbortError(executionError)) {
            await this.executeHook('workflowExecuteAfter', [fullRunData, newStaticData]);
        }
        if (closeFunction) {
            try {
                await closeFunction;
            }
            catch (error) {
                n8n_workflow_1.LoggerProxy.error(`There was a problem deactivating trigger of workflow "${workflow.id}": "${error.message}"`, {
                    workflowId: workflow.id,
                });
            }
        }
        return fullRunData;
    }
    getFullRunData(startedAt) {
        const fullRunData = {
            data: this.runExecutionData,
            mode: this.mode,
            startedAt,
            stoppedAt: new Date(),
            status: this.status,
        };
        return fullRunData;
    }
}
exports.WorkflowExecute = WorkflowExecute;
//# sourceMappingURL=WorkflowExecute.js.map