"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActiveWorkflows = void 0;
const typedi_1 = require("typedi");
const cron_1 = require("cron");
const n8n_workflow_1 = require("n8n-workflow");
let ActiveWorkflows = class ActiveWorkflows {
    constructor() {
        this.activeWorkflows = {};
    }
    isActive(workflowId) {
        return this.activeWorkflows.hasOwnProperty(workflowId);
    }
    allActiveWorkflows() {
        return Object.keys(this.activeWorkflows);
    }
    get(workflowId) {
        return this.activeWorkflows[workflowId];
    }
    async add(workflowId, workflow, additionalData, mode, activation, getTriggerFunctions, getPollFunctions) {
        this.activeWorkflows[workflowId] = {};
        const triggerNodes = workflow.getTriggerNodes();
        let triggerResponse;
        this.activeWorkflows[workflowId].triggerResponses = [];
        for (const triggerNode of triggerNodes) {
            try {
                triggerResponse = await workflow.runTrigger(triggerNode, getTriggerFunctions, additionalData, mode, activation);
                if (triggerResponse !== undefined) {
                    this.activeWorkflows[workflowId].triggerResponses.push(triggerResponse);
                }
            }
            catch (e) {
                const error = e instanceof Error ? e : new Error(`${e}`);
                throw new n8n_workflow_1.WorkflowActivationError(`There was a problem activating the workflow: "${error.message}"`, { cause: error, node: triggerNode });
            }
        }
        const pollingNodes = workflow.getPollNodes();
        if (pollingNodes.length === 0)
            return;
        this.activeWorkflows[workflowId].pollResponses = [];
        for (const pollNode of pollingNodes) {
            try {
                this.activeWorkflows[workflowId].pollResponses.push(await this.activatePolling(pollNode, workflow, additionalData, getPollFunctions, mode, activation));
            }
            catch (e) {
                const error = e instanceof Error ? e : new Error(`${e}`);
                throw new n8n_workflow_1.WorkflowActivationError(`There was a problem activating the workflow: "${error.message}"`, { cause: error, node: pollNode });
            }
        }
    }
    async activatePolling(node, workflow, additionalData, getPollFunctions, mode, activation) {
        const pollFunctions = getPollFunctions(workflow, node, additionalData, mode, activation);
        const pollTimes = pollFunctions.getNodeParameter('pollTimes');
        const cronTimes = (pollTimes.item || []).map(n8n_workflow_1.toCronExpression);
        const executeTrigger = async (testingTrigger = false) => {
            n8n_workflow_1.LoggerProxy.debug(`Polling trigger initiated for workflow "${workflow.name}"`, {
                workflowName: workflow.name,
                workflowId: workflow.id,
            });
            try {
                const pollResponse = await workflow.runPoll(node, pollFunctions);
                if (pollResponse !== null) {
                    pollFunctions.__emit(pollResponse);
                }
            }
            catch (error) {
                if (testingTrigger) {
                    throw error;
                }
                pollFunctions.__emitError(error);
            }
        };
        await executeTrigger(true);
        const timezone = pollFunctions.getTimezone();
        const cronJobs = [];
        for (const cronTime of cronTimes) {
            const cronTimeParts = cronTime.split(' ');
            if (cronTimeParts.length > 0 && cronTimeParts[0].includes('*')) {
                throw new n8n_workflow_1.ApplicationError('The polling interval is too short. It has to be at least a minute.');
            }
            cronJobs.push(new cron_1.CronJob(cronTime, executeTrigger, undefined, true, timezone));
        }
        async function closeFunction() {
            for (const cronJob of cronJobs) {
                cronJob.stop();
            }
        }
        return {
            closeFunction,
        };
    }
    async remove(workflowId) {
        var _a, _b;
        if (!this.isActive(workflowId)) {
            n8n_workflow_1.LoggerProxy.warn(`Cannot deactivate already inactive workflow ID "${workflowId}"`);
            return false;
        }
        const w = this.activeWorkflows[workflowId];
        for (const r of (_a = w.triggerResponses) !== null && _a !== void 0 ? _a : []) {
            await this.close(r, workflowId, 'trigger');
        }
        for (const r of (_b = w.pollResponses) !== null && _b !== void 0 ? _b : []) {
            await this.close(r, workflowId, 'poller');
        }
        delete this.activeWorkflows[workflowId];
        return true;
    }
    async removeAllTriggerAndPollerBasedWorkflows() {
        for (const workflowId of Object.keys(this.activeWorkflows)) {
            await this.remove(workflowId);
        }
    }
    async close(response, workflowId, target) {
        if (!response.closeFunction)
            return;
        try {
            await response.closeFunction();
        }
        catch (e) {
            if (e instanceof n8n_workflow_1.TriggerCloseError) {
                n8n_workflow_1.LoggerProxy.error(`There was a problem calling "closeFunction" on "${e.node.name}" in workflow "${workflowId}"`);
                n8n_workflow_1.ErrorReporterProxy.error(e, { extra: { target, workflowId } });
                return;
            }
            const error = e instanceof Error ? e : new Error(`${e}`);
            throw new n8n_workflow_1.WorkflowDeactivationError(`Failed to deactivate ${target} of workflow ID "${workflowId}": "${error.message}"`, { cause: error, workflowId });
        }
    }
};
exports.ActiveWorkflows = ActiveWorkflows;
exports.ActiveWorkflows = ActiveWorkflows = __decorate([
    (0, typedi_1.Service)()
], ActiveWorkflows);
//# sourceMappingURL=ActiveWorkflows.js.map