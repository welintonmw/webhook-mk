"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientOAuth2Token = void 0;
const utils_1 = require("./utils");
const constants_1 = require("./constants");
class ClientOAuth2Token {
    constructor(client, data) {
        var _a, _b;
        this.client = client;
        this.data = data;
        this.tokenType = (_b = (_a = data.token_type) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : 'bearer';
        this.accessToken = data.access_token;
        this.refreshToken = data.refresh_token;
        this.expires = new Date();
        this.expires.setSeconds(this.expires.getSeconds() + Number(data.expires_in));
    }
    sign(requestObject) {
        var _a;
        if (!this.accessToken) {
            throw new Error('Unable to sign without access token');
        }
        requestObject.headers = (_a = requestObject.headers) !== null && _a !== void 0 ? _a : {};
        if (this.tokenType === 'bearer') {
            requestObject.headers.Authorization = 'Bearer ' + this.accessToken;
        }
        else {
            const parts = requestObject.url.split('#');
            const token = 'access_token=' + this.accessToken;
            const url = parts[0].replace(/[?&]access_token=[^&#]/, '');
            const fragment = parts[1] ? '#' + parts[1] : '';
            requestObject.url = url + (url.indexOf('?') > -1 ? '&' : '?') + token + fragment;
            requestObject.headers.Pragma = 'no-store';
            requestObject.headers['Cache-Control'] = 'no-store';
        }
        return requestObject;
    }
    async refresh(opts) {
        const options = { ...this.client.options, ...opts };
        (0, utils_1.expects)(options, 'clientSecret');
        if (!this.refreshToken)
            throw new Error('No refresh token');
        const clientId = options.clientId;
        const clientSecret = options.clientSecret;
        const headers = { ...constants_1.DEFAULT_HEADERS };
        const body = {
            refresh_token: this.refreshToken,
            grant_type: 'refresh_token',
        };
        if (options.authentication === 'body') {
            body.client_id = clientId;
            body.client_secret = clientSecret;
        }
        else {
            headers.Authorization = (0, utils_1.auth)(clientId, clientSecret);
        }
        const requestOptions = (0, utils_1.getRequestOptions)({
            url: options.accessTokenUri,
            method: 'POST',
            headers,
            body,
        }, options);
        const responseData = await this.client.request(requestOptions);
        return this.client.createToken({ ...this.data, ...responseData });
    }
    expired() {
        return Date.now() > this.expires.getTime();
    }
}
exports.ClientOAuth2Token = ClientOAuth2Token;
//# sourceMappingURL=ClientOAuth2Token.js.map