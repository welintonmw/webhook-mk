"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRequestOptions = exports.auth = exports.getAuthError = exports.AuthError = exports.expects = void 0;
const constants_1 = require("./constants");
function expects(obj, ...keys) {
    for (const key of keys) {
        if (obj[key] === null || obj[key] === undefined) {
            throw new TypeError('Expected "' + key + '" to exist');
        }
    }
}
exports.expects = expects;
class AuthError extends Error {
    constructor(message, body, code = 'EAUTH') {
        super(message);
        this.body = body;
        this.code = code;
    }
}
exports.AuthError = AuthError;
function getAuthError(body) {
    var _a, _b;
    const message = (_b = (_a = constants_1.ERROR_RESPONSES[body.error]) !== null && _a !== void 0 ? _a : body.error_description) !== null && _b !== void 0 ? _b : body.error;
    if (message) {
        return new AuthError(message, body);
    }
    return undefined;
}
exports.getAuthError = getAuthError;
function toString(str) {
    return str === null ? '' : String(str);
}
function auth(username, password) {
    return 'Basic ' + Buffer.from(toString(username) + ':' + toString(password)).toString('base64');
}
exports.auth = auth;
function getRequestOptions({ url, method, body, query, headers }, options) {
    const rOptions = {
        url,
        method,
        body: { ...body, ...options.body },
        query: { ...query, ...options.query },
        headers: headers !== null && headers !== void 0 ? headers : {},
        ignoreSSLIssues: options.ignoreSSLIssues,
    };
    if (rOptions.headers.Authorization === '') {
        delete rOptions.headers.Authorization;
    }
    return rOptions;
}
exports.getRequestOptions = getRequestOptions;
//# sourceMappingURL=utils.js.map