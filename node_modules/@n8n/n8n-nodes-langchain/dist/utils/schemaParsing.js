"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.throwIfToolSchema = exports.generateSchema = exports.getSandboxWithZod = void 0;
const vm2_1 = require("@n8n/vm2");
const generate_schema_1 = require("generate-schema");
const JavaScriptSandbox_1 = require("n8n-nodes-base/dist/nodes/Code/JavaScriptSandbox");
const Sandbox_1 = require("n8n-nodes-base/dist/nodes/Code/Sandbox");
const n8n_workflow_1 = require("n8n-workflow");
const vmResolver = (0, vm2_1.makeResolverFromLegacyOptions)({
    external: {
        modules: ['json-schema-to-zod', 'zod'],
        transitive: false,
    },
    resolve(moduleName, parentDirname) {
        if (moduleName === 'json-schema-to-zod') {
            return require.resolve('@n8n/n8n-nodes-langchain/node_modules/json-schema-to-zod/dist/cjs/jsonSchemaToZod.js', {
                paths: [parentDirname],
            });
        }
        if (moduleName === 'zod') {
            return require.resolve('@n8n/n8n-nodes-langchain/node_modules/zod.cjs', {
                paths: [parentDirname],
            });
        }
        return;
    },
    builtin: [],
});
function getSandboxWithZod(ctx, schema, itemIndex) {
    var _a;
    const context = Sandbox_1.getSandboxContext.call(ctx, itemIndex);
    let itemSchema = schema;
    try {
        if (itemSchema.type === undefined) {
            itemSchema = {
                type: 'object',
                properties: (_a = itemSchema.properties) !== null && _a !== void 0 ? _a : itemSchema,
            };
        }
    }
    catch (error) {
        throw new n8n_workflow_1.NodeOperationError(ctx.getNode(), 'Error during parsing of JSON Schema.');
    }
    const { description, ...restOfSchema } = itemSchema;
    const sandboxedSchema = new JavaScriptSandbox_1.JavaScriptSandbox(context, `
			const { z } = require('zod');
			const { parseSchema } = require('json-schema-to-zod');
			const zodSchema = parseSchema(${JSON.stringify(restOfSchema)});
			const itemSchema = new Function('z', 'return (' + zodSchema + ')')(z)
			return itemSchema
		`, itemIndex, ctx.helpers, { resolver: vmResolver });
    return sandboxedSchema;
}
exports.getSandboxWithZod = getSandboxWithZod;
function generateSchema(schemaString) {
    const parsedSchema = (0, n8n_workflow_1.jsonParse)(schemaString);
    return (0, generate_schema_1.json)(parsedSchema);
}
exports.generateSchema = generateSchema;
function throwIfToolSchema(ctx, error) {
    var _a;
    if ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.includes('tool input did not match expected schema')) {
        throw new n8n_workflow_1.NodeOperationError(ctx.getNode(), `${error.message}.
			This is most likely because some of your tools are configured to require a specific schema. This is not supported by Conversational Agent. Remove the schema from the tool configuration or use Tools agent instead.`);
    }
}
exports.throwIfToolSchema = throwIfToolSchema;
//# sourceMappingURL=schemaParsing.js.map