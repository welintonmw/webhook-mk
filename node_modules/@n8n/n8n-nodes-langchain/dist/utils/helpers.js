"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConnectedTools = exports.serializeChatHistory = exports.logAiEvent = exports.getSessionId = exports.getPromptInputByType = exports.getOptionalOutputParsers = exports.isChatInstance = exports.getMetadataFiltersValues = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const tools_1 = require("@langchain/core/tools");
function getMetadataFiltersValues(ctx, itemIndex) {
    const metadata = ctx.getNodeParameter('options.metadata.metadataValues', itemIndex, []);
    if (metadata.length > 0) {
        return metadata.reduce((acc, { name, value }) => ({ ...acc, [name]: value }), {});
    }
    return undefined;
}
exports.getMetadataFiltersValues = getMetadataFiltersValues;
function isChatInstance(model) {
    var _a;
    const namespace = (_a = model === null || model === void 0 ? void 0 : model.lc_namespace) !== null && _a !== void 0 ? _a : [];
    return namespace.includes('chat_models');
}
exports.isChatInstance = isChatInstance;
async function getOptionalOutputParsers(ctx) {
    let outputParsers = [];
    if (ctx.getNodeParameter('hasOutputParser', 0, true) === true) {
        outputParsers = (await ctx.getInputConnectionData("ai_outputParser", 0));
    }
    return outputParsers;
}
exports.getOptionalOutputParsers = getOptionalOutputParsers;
function getPromptInputByType(options) {
    const { ctx, i, promptTypeKey, inputKey } = options;
    const prompt = ctx.getNodeParameter(promptTypeKey, i);
    let input;
    if (prompt === 'auto') {
        input = ctx.evaluateExpression('{{ $json["chatInput"] }}', i);
    }
    else {
        input = ctx.getNodeParameter(inputKey, i);
    }
    if (input === undefined) {
        throw new n8n_workflow_1.NodeOperationError(ctx.getNode(), 'No prompt specified', {
            description: "Expected to find the prompt in an input field called 'chatInput' (this is what the chat trigger node outputs). To use something else, change the 'Prompt' parameter",
        });
    }
    return input;
}
exports.getPromptInputByType = getPromptInputByType;
function getSessionId(ctx, itemIndex, selectorKey = 'sessionIdType', autoSelect = 'fromInput', customKey = 'sessionKey') {
    let sessionId = '';
    const selectorType = ctx.getNodeParameter(selectorKey, itemIndex);
    if (selectorType === autoSelect) {
        sessionId = ctx.evaluateExpression('{{ $json.sessionId }}', itemIndex);
        if (sessionId === '' || sessionId === undefined) {
            throw new n8n_workflow_1.NodeOperationError(ctx.getNode(), 'No session ID found', {
                description: "Expected to find the session ID in an input field called 'sessionId' (this is what the chat trigger node outputs). To use something else, change the 'Session ID' parameter",
                itemIndex,
            });
        }
    }
    else {
        sessionId = ctx.getNodeParameter(customKey, itemIndex, '');
        if (sessionId === '' || sessionId === undefined) {
            throw new n8n_workflow_1.NodeOperationError(ctx.getNode(), 'Key parameter is empty', {
                description: "Provide a key to use as session ID in the 'Key' parameter or use the 'Take from previous node automatically' option to use the session ID from the previous node, e.t. chat trigger node",
                itemIndex,
            });
        }
    }
    return sessionId;
}
exports.getSessionId = getSessionId;
async function logAiEvent(executeFunctions, event, data) {
    try {
        await executeFunctions.logAiEvent(event, data ? (0, n8n_workflow_1.jsonStringify)(data) : undefined);
    }
    catch (error) {
        executeFunctions.logger.debug(`Error logging AI event: ${event}`);
    }
}
exports.logAiEvent = logAiEvent;
function serializeChatHistory(chatHistory) {
    return chatHistory
        .map((chatMessage) => {
        if (chatMessage._getType() === 'human') {
            return `Human: ${chatMessage.content}`;
        }
        else if (chatMessage._getType() === 'ai') {
            return `Assistant: ${chatMessage.content}`;
        }
        else {
            return `${chatMessage.content}`;
        }
    })
        .join('\n');
}
exports.serializeChatHistory = serializeChatHistory;
const getConnectedTools = async (ctx, enforceUniqueNames) => {
    const connectedTools = (await ctx.getInputConnectionData("ai_tool", 0)) || [];
    if (!enforceUniqueNames)
        return connectedTools;
    const seenNames = new Set();
    for (const tool of connectedTools) {
        if (!(tool instanceof tools_1.DynamicTool))
            continue;
        const { name } = tool;
        if (seenNames.has(name)) {
            throw new n8n_workflow_1.NodeOperationError(ctx.getNode(), `You have multiple tools with the same name: '${name}', please rename them to avoid conflicts`);
        }
        seenNames.add(name);
    }
    return connectedTools;
};
exports.getConnectedTools = getConnectedTools;
//# sourceMappingURL=helpers.js.map