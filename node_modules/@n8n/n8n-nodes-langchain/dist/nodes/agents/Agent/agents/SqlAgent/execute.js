"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sqlAgentAgentExecute = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const sql_db_1 = require("langchain/sql_db");
const sql_1 = require("langchain/agents/toolkits/sql");
const helpers_1 = require("../../../../../utils/helpers");
const tracing_1 = require("../../../../../utils/tracing");
const sqlite_1 = require("./other/handlers/sqlite");
const postgres_1 = require("./other/handlers/postgres");
const prompts_1 = require("./other/prompts");
const mysql_1 = require("./other/handlers/mysql");
const parseTablesString = (tablesString) => tablesString
    .split(',')
    .map((table) => table.trim())
    .filter((table) => table.length > 0);
async function sqlAgentAgentExecute() {
    var _a, _b, _c, _d, _e, _f;
    this.logger.verbose('Executing SQL Agent');
    const model = (await this.getInputConnectionData("ai_languageModel", 0));
    const items = this.getInputData();
    const returnData = [];
    for (let i = 0; i < items.length; i++) {
        try {
            const item = items[i];
            let input;
            if (this.getNode().typeVersion <= 1.2) {
                input = this.getNodeParameter('input', i);
            }
            else {
                input = (0, helpers_1.getPromptInputByType)({
                    ctx: this,
                    i,
                    inputKey: 'text',
                    promptTypeKey: 'promptType',
                });
            }
            if (input === undefined) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'The ‘prompt’ parameter is empty.');
            }
            const options = this.getNodeParameter('options', i, {});
            const selectedDataSource = this.getNodeParameter('dataSource', i, 'sqlite');
            const includedSampleRows = options.includedSampleRows;
            const includedTablesArray = parseTablesString((_a = options.includedTables) !== null && _a !== void 0 ? _a : '');
            const ignoredTablesArray = parseTablesString((_b = options.ignoredTables) !== null && _b !== void 0 ? _b : '');
            let dataSource = null;
            if (selectedDataSource === 'sqlite') {
                if (!item.binary) {
                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'No binary data found, please connect a binary to the input if you want to use SQLite as data source');
                }
                const binaryPropertyName = this.getNodeParameter('binaryPropertyName', i, 'data');
                dataSource = await sqlite_1.getSqliteDataSource.call(this, item.binary, binaryPropertyName);
            }
            if (selectedDataSource === 'postgres') {
                dataSource = await postgres_1.getPostgresDataSource.call(this);
            }
            if (selectedDataSource === 'mysql') {
                dataSource = await mysql_1.getMysqlDataSource.call(this);
            }
            if (!dataSource) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'No data source found, please configure data source');
            }
            const agentOptions = {
                topK: (_c = options.topK) !== null && _c !== void 0 ? _c : 10,
                prefix: (_d = options.prefixPrompt) !== null && _d !== void 0 ? _d : prompts_1.SQL_PREFIX,
                suffix: (_e = options.suffixPrompt) !== null && _e !== void 0 ? _e : prompts_1.SQL_SUFFIX,
                inputVariables: ['chatHistory', 'input', 'agent_scratchpad'],
            };
            const dbInstance = await sql_db_1.SqlDatabase.fromDataSourceParams({
                appDataSource: dataSource,
                includesTables: includedTablesArray.length > 0 ? includedTablesArray : undefined,
                ignoreTables: ignoredTablesArray.length > 0 ? ignoredTablesArray : undefined,
                sampleRowsInTableInfo: includedSampleRows !== null && includedSampleRows !== void 0 ? includedSampleRows : 3,
            });
            const toolkit = new sql_1.SqlToolkit(dbInstance, model);
            const agentExecutor = (0, sql_1.createSqlAgent)(model, toolkit, agentOptions);
            const memory = (await this.getInputConnectionData("ai_memory", 0));
            agentExecutor.memory = memory;
            let chatHistory = '';
            if (memory) {
                const messages = await memory.chatHistory.getMessages();
                chatHistory = (0, helpers_1.serializeChatHistory)(messages);
            }
            let response;
            try {
                response = await agentExecutor.withConfig((0, tracing_1.getTracingConfig)(this)).invoke({
                    input,
                    signal: this.getExecutionCancelSignal(),
                    chatHistory,
                });
            }
            catch (error) {
                if ((_f = error.message) === null || _f === void 0 ? void 0 : _f.output) {
                    response = error.message;
                }
                else {
                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), error.message, { itemIndex: i });
                }
            }
            returnData.push({ json: response });
        }
        catch (error) {
            if (this.continueOnFail(error)) {
                returnData.push({ json: { error: error.message }, pairedItem: { item: i } });
                continue;
            }
            throw error;
        }
    }
    return [returnData];
}
exports.sqlAgentAgentExecute = sqlAgentAgentExecute;
//# sourceMappingURL=execute.js.map