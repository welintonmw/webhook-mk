"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.conversationalAgentExecute = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const agents_1 = require("langchain/agents");
const prompts_1 = require("@langchain/core/prompts");
const output_parsers_1 = require("langchain/output_parsers");
const helpers_1 = require("../../../../../utils/helpers");
const tracing_1 = require("../../../../../utils/tracing");
const schemaParsing_1 = require("../../../../../utils/schemaParsing");
async function conversationalAgentExecute(nodeVersion) {
    var _a;
    this.logger.verbose('Executing Conversational Agent');
    const model = await this.getInputConnectionData("ai_languageModel", 0);
    if (!(0, helpers_1.isChatInstance)(model)) {
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Conversational Agent requires Chat Model');
    }
    const memory = (await this.getInputConnectionData("ai_memory", 0));
    const tools = await (0, helpers_1.getConnectedTools)(this, nodeVersion >= 1.5);
    const outputParsers = await (0, helpers_1.getOptionalOutputParsers)(this);
    const options = this.getNodeParameter('options', 0, {});
    const agentExecutor = await (0, agents_1.initializeAgentExecutorWithOptions)(tools, model, {
        agentType: 'chat-conversational-react-description',
        memory,
        returnIntermediateSteps: (options === null || options === void 0 ? void 0 : options.returnIntermediateSteps) === true,
        maxIterations: (_a = options.maxIterations) !== null && _a !== void 0 ? _a : 10,
        agentArgs: {
            systemMessage: options.systemMessage,
            humanMessage: options.humanMessage,
        },
    });
    const returnData = [];
    let outputParser;
    let prompt;
    if (outputParsers.length) {
        if (outputParsers.length === 1) {
            outputParser = outputParsers[0];
        }
        else {
            outputParser = new output_parsers_1.CombiningOutputParser(...outputParsers);
        }
        if (outputParser) {
            const formatInstructions = outputParser.getFormatInstructions();
            prompt = new prompts_1.PromptTemplate({
                template: '{input}\n{formatInstructions}',
                inputVariables: ['input'],
                partialVariables: { formatInstructions },
            });
        }
    }
    const items = this.getInputData();
    for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
        try {
            let input;
            if (this.getNode().typeVersion <= 1.2) {
                input = this.getNodeParameter('text', itemIndex);
            }
            else {
                input = (0, helpers_1.getPromptInputByType)({
                    ctx: this,
                    i: itemIndex,
                    inputKey: 'text',
                    promptTypeKey: 'promptType',
                });
            }
            if (input === undefined) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'The â€˜text parameter is empty.');
            }
            if (prompt) {
                input = (await prompt.invoke({ input })).value;
            }
            let response = await agentExecutor
                .withConfig((0, tracing_1.getTracingConfig)(this))
                .invoke({ input, outputParsers });
            if (outputParser) {
                response = { output: await outputParser.parse(response.output) };
            }
            returnData.push({ json: response });
        }
        catch (error) {
            (0, schemaParsing_1.throwIfToolSchema)(this, error);
            if (this.continueOnFail(error)) {
                returnData.push({ json: { error: error.message }, pairedItem: { item: itemIndex } });
                continue;
            }
            throw error;
        }
    }
    return [returnData];
}
exports.conversationalAgentExecute = conversationalAgentExecute;
//# sourceMappingURL=execute.js.map