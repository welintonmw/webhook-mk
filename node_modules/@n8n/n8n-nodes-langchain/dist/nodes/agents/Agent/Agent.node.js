"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Agent = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const sharedFields_1 = require("../../../utils/sharedFields");
const descriptions_1 = require("../../../utils/descriptions");
const description_1 = require("./agents/ConversationalAgent/description");
const execute_1 = require("./agents/ConversationalAgent/execute");
const description_2 = require("./agents/OpenAiFunctionsAgent/description");
const execute_2 = require("./agents/OpenAiFunctionsAgent/execute");
const description_3 = require("./agents/PlanAndExecuteAgent/description");
const execute_3 = require("./agents/PlanAndExecuteAgent/execute");
const description_4 = require("./agents/ReActAgent/description");
const execute_4 = require("./agents/ReActAgent/execute");
const description_5 = require("./agents/SqlAgent/description");
const execute_5 = require("./agents/SqlAgent/execute");
const description_6 = require("./agents/ToolsAgent/description");
const execute_6 = require("./agents/ToolsAgent/execute");
function getInputs(agent, hasOutputParser) {
    const getInputData = (inputs) => {
        const displayNames = {
            ["ai_languageModel"]: 'Model',
            ["ai_memory"]: 'Memory',
            ["ai_tool"]: 'Tool',
            ["ai_outputParser"]: 'Output Parser',
        };
        return inputs.map(({ type, filter }) => {
            const input = {
                type,
                displayName: type in displayNames ? displayNames[type] : undefined,
                required: type === "ai_languageModel",
                maxConnections: ["ai_languageModel", "ai_memory"].includes(type)
                    ? 1
                    : undefined,
            };
            if (filter) {
                input.filter = filter;
            }
            return input;
        });
    };
    let specialInputs = [];
    if (agent === 'conversationalAgent') {
        specialInputs = [
            {
                type: "ai_languageModel",
                filter: {
                    nodes: [
                        '@n8n/n8n-nodes-langchain.lmChatAnthropic',
                        '@n8n/n8n-nodes-langchain.lmChatGroq',
                        '@n8n/n8n-nodes-langchain.lmChatOllama',
                        '@n8n/n8n-nodes-langchain.lmChatOpenAi',
                        '@n8n/n8n-nodes-langchain.lmChatGooglePalm',
                        '@n8n/n8n-nodes-langchain.lmChatGoogleGemini',
                        '@n8n/n8n-nodes-langchain.lmChatMistralCloud',
                        '@n8n/n8n-nodes-langchain.lmChatAzureOpenAi',
                    ],
                },
            },
            {
                type: "ai_memory",
            },
            {
                type: "ai_tool",
            },
            {
                type: "ai_outputParser",
            },
        ];
    }
    else if (agent === 'toolsAgent') {
        specialInputs = [
            {
                type: "ai_languageModel",
                filter: {
                    nodes: [
                        '@n8n/n8n-nodes-langchain.lmChatAnthropic',
                        '@n8n/n8n-nodes-langchain.lmChatAzureOpenAi',
                        '@n8n/n8n-nodes-langchain.lmChatMistralCloud',
                        '@n8n/n8n-nodes-langchain.lmChatOpenAi',
                        '@n8n/n8n-nodes-langchain.lmChatGroq',
                    ],
                },
            },
            {
                type: "ai_memory",
            },
            {
                type: "ai_tool",
                required: true,
            },
            {
                type: "ai_outputParser",
            },
        ];
    }
    else if (agent === 'openAiFunctionsAgent') {
        specialInputs = [
            {
                type: "ai_languageModel",
                filter: {
                    nodes: [
                        '@n8n/n8n-nodes-langchain.lmChatOpenAi',
                        '@n8n/n8n-nodes-langchain.lmChatAzureOpenAi',
                    ],
                },
            },
            {
                type: "ai_memory",
            },
            {
                type: "ai_tool",
                required: true,
            },
            {
                type: "ai_outputParser",
            },
        ];
    }
    else if (agent === 'reActAgent') {
        specialInputs = [
            {
                type: "ai_languageModel",
            },
            {
                type: "ai_tool",
            },
            {
                type: "ai_outputParser",
            },
        ];
    }
    else if (agent === 'sqlAgent') {
        specialInputs = [
            {
                type: "ai_languageModel",
            },
            {
                type: "ai_memory",
            },
        ];
    }
    else if (agent === 'planAndExecuteAgent') {
        specialInputs = [
            {
                type: "ai_languageModel",
            },
            {
                type: "ai_tool",
            },
            {
                type: "ai_outputParser",
            },
        ];
    }
    if (hasOutputParser === false) {
        specialInputs = specialInputs.filter((input) => input.type !== "ai_outputParser");
    }
    return ["main", ...getInputData(specialInputs)];
}
const agentTypeProperty = {
    displayName: 'Agent',
    name: 'agent',
    type: 'options',
    noDataExpression: true,
    options: [
        {
            name: 'Tools Agent',
            value: 'toolsAgent',
            description: 'Utilized unified Tool calling interface to select the appropriate tools and argument for execution',
        },
        {
            name: 'Conversational Agent',
            value: 'conversationalAgent',
            description: 'Selects tools to accomplish its task and uses memory to recall previous conversations',
        },
        {
            name: 'OpenAI Functions Agent',
            value: 'openAiFunctionsAgent',
            description: "Utilizes OpenAI's Function Calling feature to select the appropriate tool and arguments for execution",
        },
        {
            name: 'Plan and Execute Agent',
            value: 'planAndExecuteAgent',
            description: 'Plan and execute agents accomplish an objective by first planning what to do, then executing the sub tasks',
        },
        {
            name: 'ReAct Agent',
            value: 'reActAgent',
            description: 'Strategically select tools to accomplish a given task',
        },
        {
            name: 'SQL Agent',
            value: 'sqlAgent',
            description: 'Answers questions about data in an SQL database',
        },
    ],
    default: '',
};
class Agent {
    constructor() {
        var _a;
        this.description = {
            displayName: 'AI Agent',
            name: 'agent',
            icon: 'fa:robot',
            iconColor: 'black',
            group: ['transform'],
            version: [1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6],
            description: 'Generates an action plan and executes it. Can use external tools.',
            subtitle: "={{ {	toolsAgent: 'Tools Agent', conversationalAgent: 'Conversational Agent', openAiFunctionsAgent: 'OpenAI Functions Agent', reActAgent: 'ReAct Agent', sqlAgent: 'SQL Agent', planAndExecuteAgent: 'Plan and Execute Agent' }[$parameter.agent] }}",
            defaults: {
                name: 'AI Agent',
                color: '#404040',
            },
            codex: {
                alias: ['LangChain'],
                categories: ['AI'],
                subcategories: {
                    AI: ['Agents', 'Root Nodes'],
                },
                resources: {
                    primaryDocumentation: [
                        {
                            url: 'https://docs.n8n.io/integrations/builtin/cluster-nodes/root-nodes/n8n-nodes-langchain.agent/',
                        },
                    ],
                },
            },
            inputs: `={{
			((agent, hasOutputParser) => {
				${getInputs.toString()};
				return getInputs(agent, hasOutputParser)
			})($parameter.agent, $parameter.hasOutputParser === undefined || $parameter.hasOutputParser === true)
		}}`,
            outputs: ["main"],
            credentials: [
                {
                    name: 'mySql',
                    required: true,
                    testedBy: 'mysqlConnectionTest',
                    displayOptions: {
                        show: {
                            agent: ['sqlAgent'],
                            '/dataSource': ['mysql'],
                        },
                    },
                },
                {
                    name: 'postgres',
                    required: true,
                    displayOptions: {
                        show: {
                            agent: ['sqlAgent'],
                            '/dataSource': ['postgres'],
                        },
                    },
                },
            ],
            properties: [
                {
                    ...(0, sharedFields_1.getTemplateNoticeField)(1954),
                    displayOptions: {
                        show: {
                            agent: ['conversationalAgent'],
                        },
                    },
                },
                {
                    ...agentTypeProperty,
                    options: (_a = agentTypeProperty === null || agentTypeProperty === void 0 ? void 0 : agentTypeProperty.options) === null || _a === void 0 ? void 0 : _a.filter((o) => 'value' in o && o.value !== 'toolsAgent'),
                    displayOptions: { show: { '@version': [{ _cnd: { lte: 1.5 } }] } },
                    default: 'conversationalAgent',
                },
                {
                    ...agentTypeProperty,
                    displayOptions: { show: { '@version': [{ _cnd: { gte: 1.6 } }] } },
                    default: 'toolsAgent',
                },
                {
                    ...descriptions_1.promptTypeOptions,
                    displayOptions: {
                        hide: {
                            '@version': [{ _cnd: { lte: 1.2 } }],
                            agent: ['sqlAgent'],
                        },
                    },
                },
                {
                    ...descriptions_1.textInput,
                    displayOptions: {
                        show: {
                            promptType: ['define'],
                        },
                        hide: {
                            agent: ['sqlAgent'],
                        },
                    },
                },
                {
                    displayName: 'Require Specific Output Format',
                    name: 'hasOutputParser',
                    type: 'boolean',
                    default: false,
                    noDataExpression: true,
                    displayOptions: {
                        hide: {
                            '@version': [{ _cnd: { lte: 1.2 } }],
                            agent: ['sqlAgent'],
                        },
                    },
                },
                {
                    displayName: `Connect an <a data-action='openSelectiveNodeCreator' data-action-parameter-connectiontype='${"ai_outputParser"}'>output parser</a> on the canvas to specify the output format you require`,
                    name: 'notice',
                    type: 'notice',
                    default: '',
                    displayOptions: {
                        show: {
                            hasOutputParser: [true],
                        },
                    },
                },
                ...description_6.toolsAgentProperties,
                ...description_1.conversationalAgentProperties,
                ...description_2.openAiFunctionsAgentProperties,
                ...description_4.reActAgentAgentProperties,
                ...description_5.sqlAgentAgentProperties,
                ...description_3.planAndExecuteAgentProperties,
            ],
        };
    }
    async execute() {
        const agentType = this.getNodeParameter('agent', 0, '');
        const nodeVersion = this.getNode().typeVersion;
        if (agentType === 'conversationalAgent') {
            return await execute_1.conversationalAgentExecute.call(this, nodeVersion);
        }
        else if (agentType === 'toolsAgent') {
            return await execute_6.toolsAgentExecute.call(this);
        }
        else if (agentType === 'openAiFunctionsAgent') {
            return await execute_2.openAiFunctionsAgentExecute.call(this, nodeVersion);
        }
        else if (agentType === 'reActAgent') {
            return await execute_4.reActAgentAgentExecute.call(this, nodeVersion);
        }
        else if (agentType === 'sqlAgent') {
            return await execute_5.sqlAgentAgentExecute.call(this);
        }
        else if (agentType === 'planAndExecuteAgent') {
            return await execute_3.planAndExecuteAgentExecute.call(this, nodeVersion);
        }
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), `The agent type "${agentType}" is not supported`);
    }
}
exports.Agent = Agent;
//# sourceMappingURL=Agent.node.js.map