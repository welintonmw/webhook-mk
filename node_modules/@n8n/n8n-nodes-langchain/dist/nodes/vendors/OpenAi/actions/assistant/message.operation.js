"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.description = void 0;
const agents_1 = require("langchain/agents");
const openai_assistant_1 = require("langchain/experimental/openai_assistant");
const openai_1 = require("openai");
const n8n_workflow_1 = require("n8n-workflow");
const omit_1 = __importDefault(require("lodash/omit"));
const utils_1 = require("../../helpers/utils");
const descriptions_1 = require("../descriptions");
const helpers_1 = require("../../../../../utils/helpers");
const tracing_1 = require("../../../../../utils/tracing");
const properties = [
    descriptions_1.assistantRLC,
    {
        displayName: 'Prompt',
        name: 'prompt',
        type: 'options',
        options: [
            {
                name: 'Take from previous node automatically',
                value: 'auto',
                description: 'Looks for an input field called chatInput',
            },
            {
                name: 'Define below',
                value: 'define',
                description: 'Use an expression to reference data in previous nodes or enter static text',
            },
        ],
        default: 'auto',
    },
    {
        displayName: 'Text',
        name: 'text',
        type: 'string',
        default: '',
        placeholder: 'e.g. Hello, how can you help me?',
        typeOptions: {
            rows: 2,
        },
        displayOptions: {
            show: {
                prompt: ['define'],
            },
        },
    },
    {
        displayName: 'Connect your own custom n8n tools to this node on the canvas',
        name: 'noticeTools',
        type: 'notice',
        default: '',
    },
    {
        displayName: 'Options',
        name: 'options',
        placeholder: 'Add Option',
        description: 'Additional options to add',
        type: 'collection',
        default: {},
        options: [
            {
                displayName: 'Base URL',
                name: 'baseURL',
                default: 'https://api.openai.com/v1',
                description: 'Override the default base URL for the API',
                type: 'string',
            },
            {
                displayName: 'Max Retries',
                name: 'maxRetries',
                default: 2,
                description: 'Maximum number of retries to attempt',
                type: 'number',
            },
            {
                displayName: 'Timeout',
                name: 'timeout',
                default: 10000,
                description: 'Maximum amount of time a request is allowed to take in milliseconds',
                type: 'number',
            },
            {
                displayName: 'Preserve Original Tools',
                name: 'preserveOriginalTools',
                type: 'boolean',
                default: true,
                description: 'Whether to preserve the original tools of the assistant after the execution of this node, otherwise the tools will be replaced with the connected tools, if any, default is true',
                displayOptions: {
                    show: {
                        '@version': [{ _cnd: { gte: 1.3 } }],
                    },
                },
            },
        ],
    },
];
const displayOptions = {
    show: {
        operation: ['message'],
        resource: ['assistant'],
    },
};
exports.description = (0, n8n_workflow_1.updateDisplayOptions)(displayOptions, properties);
const mapChatMessageToThreadMessage = (message) => ({
    role: message._getType() === 'ai' ? 'assistant' : 'user',
    content: message.content.toString(),
});
async function execute(i) {
    var _a, _b, _c, _d, _e;
    const credentials = await this.getCredentials('openAiApi');
    const nodeVersion = this.getNode().typeVersion;
    const prompt = this.getNodeParameter('prompt', i);
    let input;
    if (prompt === 'auto') {
        input = this.evaluateExpression('{{ $json["chatInput"] }}', i);
    }
    else {
        input = this.getNodeParameter('text', i);
    }
    if (input === undefined) {
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'No prompt specified', {
            description: "Expected to find the prompt in an input field called 'chatInput' (this is what the chat trigger node outputs). To use something else, change the 'Prompt' parameter",
        });
    }
    const assistantId = this.getNodeParameter('assistantId', i, '', { extractValue: true });
    const options = this.getNodeParameter('options', i, {});
    const client = new openai_1.OpenAI({
        apiKey: credentials.apiKey,
        maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : 2,
        timeout: (_b = options.timeout) !== null && _b !== void 0 ? _b : 10000,
        baseURL: options.baseURL,
    });
    const agent = new openai_assistant_1.OpenAIAssistantRunnable({ assistantId, client, asAgent: true });
    const tools = await (0, helpers_1.getConnectedTools)(this, nodeVersion > 1);
    let assistantTools;
    if (tools.length) {
        const transformedConnectedTools = (_c = tools === null || tools === void 0 ? void 0 : tools.map(utils_1.formatToOpenAIAssistantTool)) !== null && _c !== void 0 ? _c : [];
        const nativeToolsParsed = [];
        assistantTools = (await client.beta.assistants.retrieve(assistantId)).tools;
        const useCodeInterpreter = assistantTools.some((tool) => tool.type === 'code_interpreter');
        if (useCodeInterpreter) {
            nativeToolsParsed.push({
                type: 'code_interpreter',
            });
        }
        const useRetrieval = assistantTools.some((tool) => tool.type === 'file_search');
        if (useRetrieval) {
            nativeToolsParsed.push({
                type: 'file_search',
            });
        }
        await client.beta.assistants.update(assistantId, {
            tools: [...nativeToolsParsed, ...transformedConnectedTools],
        });
    }
    const agentExecutor = agents_1.AgentExecutor.fromAgentAndTools({
        agent,
        tools: tools !== null && tools !== void 0 ? tools : [],
    });
    const memory = (await this.getInputConnectionData("ai_memory", 0));
    const chainValues = {
        content: input,
        signal: this.getExecutionCancelSignal(),
        timeout: (_d = options.timeout) !== null && _d !== void 0 ? _d : 10000,
    };
    let thread;
    if (memory) {
        const chatMessages = await memory.chatHistory.getMessages();
        if (chatMessages.length) {
            const first32Messages = chatMessages.slice(0, 32);
            const mappedMessages = first32Messages.map(mapChatMessageToThreadMessage);
            thread = await client.beta.threads.create({ messages: mappedMessages });
            const overLimitMessages = chatMessages.slice(32).map(mapChatMessageToThreadMessage);
            for (const message of overLimitMessages) {
                await client.beta.threads.messages.create(thread.id, message);
            }
            chainValues.threadId = thread.id;
        }
    }
    const response = await agentExecutor.withConfig((0, tracing_1.getTracingConfig)(this)).invoke(chainValues);
    if (memory) {
        await memory.saveContext({ input }, { output: response.output });
        if (response.threadId && response.runId) {
            const threadRun = await client.beta.threads.runs.retrieve(response.threadId, response.runId);
            response.usage = threadRun.usage;
        }
    }
    if (options.preserveOriginalTools !== false &&
        nodeVersion >= 1.3 &&
        ((_e = (assistantTools !== null && assistantTools !== void 0 ? assistantTools : [])) === null || _e === void 0 ? void 0 : _e.length)) {
        await client.beta.assistants.update(assistantId, {
            tools: assistantTools,
        });
    }
    const filteredResponse = (0, omit_1.default)(response, ['signal', 'timeout']);
    return [{ json: filteredResponse, pairedItem: { item: i } }];
}
exports.execute = execute;
//# sourceMappingURL=message.operation.js.map