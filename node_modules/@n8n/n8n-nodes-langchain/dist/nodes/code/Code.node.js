"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Code = exports.vmResolver = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const Sandbox_1 = require("n8n-nodes-base/dist/nodes/Code/Sandbox");
const JavaScriptSandbox_1 = require("n8n-nodes-base/dist/nodes/Code/JavaScriptSandbox");
const utils_1 = require("n8n-nodes-base/dist/nodes/Code/utils");
const vm2_1 = require("@n8n/vm2");
const logWrapper_1 = require("../../utils/logWrapper");
const { NODE_FUNCTION_ALLOW_BUILTIN: builtIn, NODE_FUNCTION_ALLOW_EXTERNAL: external } = process.env;
const connectorTypes = {
    ["ai_chain"]: 'Chain',
    ["ai_document"]: 'Document',
    ["ai_embedding"]: 'Embedding',
    ["ai_languageModel"]: 'Language Model',
    ["ai_memory"]: 'Memory',
    ["ai_outputParser"]: 'Output Parser',
    ["ai_textSplitter"]: 'Text Splitter',
    ["ai_tool"]: 'Tool',
    ["ai_vectorStore"]: 'Vector Store',
    ["main"]: 'Main',
};
const defaultCodeExecute = `const { PromptTemplate } = require('@langchain/core/prompts');

const query = 'Tell me a joke';
const prompt = PromptTemplate.fromTemplate(query);
const llm = await this.getInputConnectionData('ai_languageModel', 0);
let chain = prompt.pipe(llm);
const output = await chain.invoke();
return [ {json: { output } } ];`;
const defaultCodeSupplyData = `const { WikipediaQueryRun } = require('langchain/tools');
return new WikipediaQueryRun();`;
const langchainModules = ['langchain', '@langchain/*'];
exports.vmResolver = (0, vm2_1.makeResolverFromLegacyOptions)({
    external: {
        modules: external ? [...langchainModules, ...external.split(',')] : [...langchainModules],
        transitive: false,
    },
    resolve(moduleName, parentDirname) {
        var _a;
        if ((_a = moduleName.match(/^langchain\//)) !== null && _a !== void 0 ? _a : moduleName.match(/^@langchain\//)) {
            return require.resolve(`@n8n/n8n-nodes-langchain/node_modules/${moduleName}.cjs`, {
                paths: [parentDirname],
            });
        }
        return;
    },
    builtin: (_a = builtIn === null || builtIn === void 0 ? void 0 : builtIn.split(',')) !== null && _a !== void 0 ? _a : [],
});
function getSandbox(code, options) {
    var _a;
    const itemIndex = (_a = options === null || options === void 0 ? void 0 : options.itemIndex) !== null && _a !== void 0 ? _a : 0;
    const node = this.getNode();
    const workflowMode = this.getMode();
    const context = Sandbox_1.getSandboxContext.call(this, itemIndex);
    context.addInputData = this.addInputData;
    context.addOutputData = this.addOutputData;
    context.getInputConnectionData = this.getInputConnectionData;
    context.getInputData = this.getInputData;
    context.getNode = this.getNode;
    context.getExecutionCancelSignal = this.getExecutionCancelSignal;
    context.getNodeOutputs = this.getNodeOutputs;
    context.executeWorkflow = this.executeWorkflow;
    context.getWorkflowDataProxy = this.getWorkflowDataProxy;
    context.logger = this.logger;
    if (options === null || options === void 0 ? void 0 : options.addItems) {
        context.items = context.$input.all();
    }
    const sandbox = new JavaScriptSandbox_1.JavaScriptSandbox(context, code, itemIndex, this.helpers, {
        resolver: exports.vmResolver,
    });
    sandbox.on('output', workflowMode === 'manual'
        ? this.sendMessageToUI.bind(this)
        : (...args) => console.log(`[Workflow "${this.getWorkflow().id}"][Node "${node.name}"]`, ...args));
    return sandbox;
}
class Code {
    constructor() {
        this.description = {
            displayName: 'LangChain Code',
            name: 'code',
            icon: 'fa:code',
            group: ['transform'],
            version: 1,
            description: 'LangChain Code Node',
            defaults: {
                name: 'LangChain Code',
            },
            codex: {
                categories: ['AI'],
                subcategories: {
                    AI: ['Miscellaneous'],
                },
                resources: {
                    primaryDocumentation: [
                        {
                            url: 'https://docs.n8n.io/integrations/builtin/cluster-nodes/root-nodes/n8n-nodes-langchain.code/',
                        },
                    ],
                },
            },
            inputs: `={{ ((values) => { const connectorTypes = ${JSON.stringify(connectorTypes)}; return values.map(value => { return { type: value.type, required: value.required, maxConnections: value.maxConnections === -1 ? undefined : value.maxConnections, displayName: connectorTypes[value.type] !== 'Main' ? connectorTypes[value.type] : undefined } } ) })($parameter.inputs.input) }}`,
            outputs: `={{ ((values) => { const connectorTypes = ${JSON.stringify(connectorTypes)}; return values.map(value => { return { type: value.type, displayName: connectorTypes[value.type] !== 'Main' ? connectorTypes[value.type] : undefined } } ) })($parameter.outputs.output) }}`,
            properties: [
                {
                    displayName: 'Code',
                    name: 'code',
                    placeholder: 'Add Code',
                    type: 'fixedCollection',
                    noDataExpression: true,
                    default: {},
                    options: [
                        {
                            name: 'execute',
                            displayName: 'Execute',
                            values: [
                                {
                                    displayName: 'JavaScript - Execute',
                                    name: 'code',
                                    type: 'string',
                                    typeOptions: {
                                        editor: 'jsEditor',
                                    },
                                    default: defaultCodeExecute,
                                    hint: 'This code will only run and return data if a "Main" input & output got created.',
                                    noDataExpression: true,
                                },
                            ],
                        },
                        {
                            name: 'supplyData',
                            displayName: 'Supply Data',
                            values: [
                                {
                                    displayName: 'JavaScript - Supply Data',
                                    name: 'code',
                                    type: 'string',
                                    typeOptions: {
                                        editor: 'jsEditor',
                                    },
                                    default: defaultCodeSupplyData,
                                    hint: 'This code will only run and return data if an output got created which is not "Main".',
                                    noDataExpression: true,
                                },
                            ],
                        },
                    ],
                },
                {
                    displayName: 'You can import LangChain and use all available functionality. Debug by using <code>console.log()</code> statements and viewing their output in the browser console.',
                    name: 'notice',
                    type: 'notice',
                    default: '',
                },
                {
                    displayName: 'Inputs',
                    name: 'inputs',
                    placeholder: 'Add Input',
                    type: 'fixedCollection',
                    noDataExpression: true,
                    typeOptions: {
                        multipleValues: true,
                        sortable: true,
                    },
                    description: 'The input to add',
                    default: {},
                    options: [
                        {
                            name: 'input',
                            displayName: 'Input',
                            values: [
                                {
                                    displayName: 'Type',
                                    name: 'type',
                                    type: 'options',
                                    options: Object.keys(connectorTypes).map((key) => ({
                                        name: connectorTypes[key],
                                        value: key,
                                    })),
                                    noDataExpression: true,
                                    default: '',
                                    required: true,
                                    description: 'The type of the input',
                                },
                                {
                                    displayName: 'Max Connections',
                                    name: 'maxConnections',
                                    type: 'number',
                                    noDataExpression: true,
                                    default: -1,
                                    required: true,
                                    description: 'How many nodes of this type are allowed to be connected. Set it to -1 for unlimited.',
                                },
                                {
                                    displayName: 'Required',
                                    name: 'required',
                                    type: 'boolean',
                                    noDataExpression: true,
                                    default: false,
                                    required: true,
                                    description: 'Whether the input needs a connection',
                                },
                            ],
                        },
                    ],
                },
                {
                    displayName: 'Outputs',
                    name: 'outputs',
                    placeholder: 'Add Output',
                    type: 'fixedCollection',
                    noDataExpression: true,
                    typeOptions: {
                        multipleValues: true,
                        sortable: true,
                    },
                    description: 'The output to add',
                    default: {},
                    options: [
                        {
                            name: 'output',
                            displayName: 'Output',
                            values: [
                                {
                                    displayName: 'Type',
                                    name: 'type',
                                    type: 'options',
                                    options: Object.keys(connectorTypes).map((key) => ({
                                        name: connectorTypes[key],
                                        value: key,
                                    })),
                                    noDataExpression: true,
                                    default: '',
                                    required: true,
                                    description: 'The type of the input',
                                },
                            ],
                        },
                    ],
                },
            ],
        };
    }
    async execute() {
        var _a;
        const itemIndex = 0;
        const code = this.getNodeParameter('code', itemIndex);
        if (!((_a = code.execute) === null || _a === void 0 ? void 0 : _a.code)) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), `No code for "Execute" set on node "${this.getNode().name}`, {
                itemIndex,
            });
        }
        const sandbox = getSandbox.call(this, code.execute.code, { addItems: true, itemIndex });
        const outputs = this.getNodeOutputs();
        const mainOutputs = outputs.filter((output) => output.type === "main");
        const options = { multiOutput: mainOutputs.length !== 1 };
        let items;
        try {
            items = await sandbox.runCodeAllItems(options);
        }
        catch (error) {
            if (!this.continueOnFail(error))
                throw error;
            items = [{ json: { error: error.message } }];
            if (options.multiOutput) {
                items = [items];
            }
        }
        if (mainOutputs.length === 0) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'The node does not have a "Main" output set. Please add one.', {
                itemIndex,
            });
        }
        else if (!options.multiOutput) {
            for (const item of items) {
                (0, utils_1.standardizeOutput)(item.json);
            }
            return [items];
        }
        else {
            items.forEach((data) => {
                for (const item of data) {
                    (0, utils_1.standardizeOutput)(item.json);
                }
            });
            return items;
        }
    }
    async supplyData(itemIndex) {
        var _a;
        const code = this.getNodeParameter('code', itemIndex);
        if (!((_a = code.supplyData) === null || _a === void 0 ? void 0 : _a.code)) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), `No code for "Supply Data" set on node "${this.getNode().name}`, {
                itemIndex,
            });
        }
        const sandbox = getSandbox.call(this, code.supplyData.code, { itemIndex });
        const response = (await sandbox.runCode());
        return {
            response: (0, logWrapper_1.logWrapper)(response, this),
        };
    }
}
exports.Code = Code;
//# sourceMappingURL=Code.node.js.map