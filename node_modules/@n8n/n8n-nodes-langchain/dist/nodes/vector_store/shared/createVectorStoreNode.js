"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createVectorStoreNode = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const logWrapper_1 = require("../../../utils/logWrapper");
const helpers_1 = require("../../../utils/helpers");
const sharedFields_1 = require("../../../utils/sharedFields");
const processDocuments_1 = require("./processDocuments");
function transformDescriptionForOperationMode(fields, mode) {
    return fields.map((field) => ({
        ...field,
        displayOptions: { show: { mode: [mode] } },
    }));
}
const createVectorStoreNode = (args) => class VectorStoreNodeType {
    constructor() {
        var _a, _b, _c;
        this.description = {
            displayName: args.meta.displayName,
            name: args.meta.name,
            description: args.meta.description,
            icon: args.meta.icon,
            group: ['transform'],
            version: 1,
            defaults: {
                name: args.meta.displayName,
            },
            codex: {
                categories: ['AI'],
                subcategories: {
                    AI: ['Vector Stores'],
                },
                resources: {
                    primaryDocumentation: [
                        {
                            url: args.meta.docsUrl,
                        },
                    ],
                },
            },
            credentials: args.meta.credentials,
            inputs: `={{
			((parameters) => {
				const mode = parameters?.mode;
				const inputs = [{ displayName: "Embedding", type: "${"ai_embedding"}", required: true, maxConnections: 1}]

				if (['insert', 'load'].includes(mode)) {
					inputs.push({ displayName: "", type: "${"main"}"})
				}

				if (mode === 'insert') {
					inputs.push({ displayName: "Document", type: "${"ai_document"}", required: true, maxConnections: 1})
				}
				return inputs
			})($parameter)
		}}`,
            outputs: `={{
			((parameters) => {
				const mode = parameters?.mode ?? 'retrieve';
				if (mode === 'retrieve') {
					return [{ displayName: "Vector Store", type: "${"ai_vectorStore"}"}]
				}
				return [{ displayName: "", type: "${"main"}"}]
			})($parameter)
		}}`,
            properties: [
                {
                    displayName: 'Operation Mode',
                    name: 'mode',
                    type: 'options',
                    noDataExpression: true,
                    default: 'retrieve',
                    options: [
                        {
                            name: 'Get Many',
                            value: 'load',
                            description: 'Get many ranked documents from vector store for query',
                            action: 'Get many ranked documents from vector store for query',
                        },
                        {
                            name: 'Insert Documents',
                            value: 'insert',
                            description: 'Insert documents into vector store',
                            action: 'Insert documents into vector store',
                        },
                        {
                            name: 'Retrieve Documents (For Agent/Chain)',
                            value: 'retrieve',
                            description: 'Retrieve documents from vector store to be used with AI nodes',
                            action: 'Retrieve documents from vector store to be used with AI nodes',
                        },
                    ],
                },
                {
                    ...(0, sharedFields_1.getConnectionHintNoticeField)(["ai_retriever"]),
                    displayOptions: {
                        show: {
                            mode: ['retrieve'],
                        },
                    },
                },
                ...args.sharedFields,
                ...transformDescriptionForOperationMode((_a = args.insertFields) !== null && _a !== void 0 ? _a : [], 'insert'),
                {
                    displayName: 'Prompt',
                    name: 'prompt',
                    type: 'string',
                    default: '',
                    required: true,
                    description: 'Search prompt to retrieve matching documents from the vector store using similarity-based ranking',
                    displayOptions: {
                        show: {
                            mode: ['load'],
                        },
                    },
                },
                {
                    displayName: 'Limit',
                    name: 'topK',
                    type: 'number',
                    default: 4,
                    description: 'Number of top results to fetch from vector store',
                    displayOptions: {
                        show: {
                            mode: ['load'],
                        },
                    },
                },
                ...transformDescriptionForOperationMode((_b = args.loadFields) !== null && _b !== void 0 ? _b : [], 'load'),
                ...transformDescriptionForOperationMode((_c = args.retrieveFields) !== null && _c !== void 0 ? _c : [], 'retrieve'),
            ],
        };
        this.methods = args.methods;
    }
    async execute() {
        const mode = this.getNodeParameter('mode', 0);
        const embeddings = (await this.getInputConnectionData("ai_embedding", 0));
        if (mode === 'load') {
            const items = this.getInputData(0);
            const resultData = [];
            for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                const filter = (0, helpers_1.getMetadataFiltersValues)(this, itemIndex);
                const vectorStore = await args.getVectorStoreClient(this, undefined, embeddings, itemIndex);
                const prompt = this.getNodeParameter('prompt', itemIndex);
                const topK = this.getNodeParameter('topK', itemIndex, 4);
                const embeddedPrompt = await embeddings.embedQuery(prompt);
                const docs = await vectorStore.similaritySearchVectorWithScore(embeddedPrompt, topK, filter);
                const serializedDocs = docs.map(([doc, score]) => {
                    const document = {
                        metadata: doc.metadata,
                        pageContent: doc.pageContent,
                    };
                    return {
                        json: { document, score },
                        pairedItem: {
                            item: itemIndex,
                        },
                    };
                });
                resultData.push(...serializedDocs);
                void (0, helpers_1.logAiEvent)(this, 'n8n.ai.vector.store.searched', { query: prompt });
            }
            return [resultData];
        }
        if (mode === 'insert') {
            const items = this.getInputData();
            const documentInput = (await this.getInputConnectionData("ai_document", 0));
            const resultData = [];
            for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                const itemData = items[itemIndex];
                const { processedDocuments, serializedDocuments } = await (0, processDocuments_1.processDocument)(documentInput, itemData, itemIndex);
                resultData.push(...serializedDocuments);
                try {
                    await args.populateVectorStore(this, embeddings, processedDocuments, itemIndex);
                    void (0, helpers_1.logAiEvent)(this, 'n8n.ai.vector.store.populated');
                }
                catch (error) {
                    throw error;
                }
            }
            return [resultData];
        }
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Only the "load" and "insert" operation modes are supported with execute');
    }
    async supplyData(itemIndex) {
        const mode = this.getNodeParameter('mode', 0);
        const filter = (0, helpers_1.getMetadataFiltersValues)(this, itemIndex);
        const embeddings = (await this.getInputConnectionData("ai_embedding", 0));
        if (mode === 'retrieve') {
            const vectorStore = await args.getVectorStoreClient(this, filter, embeddings, itemIndex);
            return {
                response: (0, logWrapper_1.logWrapper)(vectorStore, this),
            };
        }
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Only the "retrieve" operation mode is supported to supply data');
    }
};
exports.createVectorStoreNode = createVectorStoreNode;
//# sourceMappingURL=createVectorStoreNode.js.map