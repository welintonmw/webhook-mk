"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OutputParserStructured = exports.N8nStructuredOutputParser = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const zod_1 = require("zod");
const output_parsers_1 = require("langchain/output_parsers");
const output_parsers_2 = require("@langchain/core/output_parsers");
const get_1 = __importDefault(require("lodash/get"));
const sharedFields_1 = require("../../../utils/sharedFields");
const logWrapper_1 = require("../../../utils/logWrapper");
const schemaParsing_1 = require("../../../utils/schemaParsing");
const descriptions_1 = require("../../../utils/descriptions");
const STRUCTURED_OUTPUT_KEY = '__structured__output';
const STRUCTURED_OUTPUT_OBJECT_KEY = '__structured__output__object';
const STRUCTURED_OUTPUT_ARRAY_KEY = '__structured__output__array';
class N8nStructuredOutputParser extends output_parsers_1.StructuredOutputParser {
    async parse(text) {
        var _a, _b, _c;
        try {
            const parsed = (await super.parse(text));
            return ((_c = (_b = (_a = (0, get_1.default)(parsed, [STRUCTURED_OUTPUT_KEY, STRUCTURED_OUTPUT_OBJECT_KEY])) !== null && _a !== void 0 ? _a : (0, get_1.default)(parsed, [STRUCTURED_OUTPUT_KEY, STRUCTURED_OUTPUT_ARRAY_KEY])) !== null && _b !== void 0 ? _b : (0, get_1.default)(parsed, STRUCTURED_OUTPUT_KEY)) !== null && _c !== void 0 ? _c : parsed);
        }
        catch (e) {
            throw new output_parsers_2.OutputParserException(`Failed to parse. Text: "${text}". Error: ${e}`, text);
        }
    }
    static async fromZedJsonSchema(sandboxedSchema, nodeVersion) {
        const zodSchema = (await sandboxedSchema.runCode());
        let returnSchema;
        if (nodeVersion === 1) {
            returnSchema = zod_1.z.object({
                [STRUCTURED_OUTPUT_KEY]: zod_1.z
                    .object({
                    [STRUCTURED_OUTPUT_OBJECT_KEY]: zodSchema.optional(),
                    [STRUCTURED_OUTPUT_ARRAY_KEY]: zod_1.z.array(zodSchema).optional(),
                })
                    .describe(`Wrapper around the output data. It can only contain ${STRUCTURED_OUTPUT_OBJECT_KEY} or ${STRUCTURED_OUTPUT_ARRAY_KEY} but never both.`)
                    .refine((data) => {
                    return (Boolean(data[STRUCTURED_OUTPUT_OBJECT_KEY]) !==
                        Boolean(data[STRUCTURED_OUTPUT_ARRAY_KEY]));
                }, {
                    message: 'One and only one of __structured__output__object and __structured__output__array should be present.',
                    path: [STRUCTURED_OUTPUT_KEY],
                }),
            });
        }
        else {
            returnSchema = zod_1.z.object({
                output: zodSchema.optional(),
            });
        }
        return N8nStructuredOutputParser.fromZodSchema(returnSchema);
    }
}
exports.N8nStructuredOutputParser = N8nStructuredOutputParser;
class OutputParserStructured {
    constructor() {
        this.description = {
            displayName: 'Structured Output Parser',
            name: 'outputParserStructured',
            icon: 'fa:code',
            group: ['transform'],
            version: [1, 1.1, 1.2],
            defaultVersion: 1.2,
            description: 'Return data in a defined JSON format',
            defaults: {
                name: 'Structured Output Parser',
            },
            codex: {
                alias: ['json', 'zod'],
                categories: ['AI'],
                subcategories: {
                    AI: ['Output Parsers'],
                },
                resources: {
                    primaryDocumentation: [
                        {
                            url: 'https://docs.n8n.io/integrations/builtin/cluster-nodes/sub-nodes/n8n-nodes-langchain.outputparserstructured/',
                        },
                    ],
                },
            },
            inputs: [],
            outputs: ["ai_outputParser"],
            outputNames: ['Output Parser'],
            properties: [
                (0, sharedFields_1.getConnectionHintNoticeField)(["ai_chain", "ai_agent"]),
                { ...descriptions_1.schemaTypeField, displayOptions: { show: { '@version': [{ _cnd: { gte: 1.2 } }] } } },
                {
                    ...descriptions_1.jsonSchemaExampleField,
                    default: `{
	"state": "California",
	"cities": ["Los Angeles", "San Francisco", "San Diego"]
}`,
                },
                {
                    ...descriptions_1.inputSchemaField,
                    displayName: 'JSON Schema',
                    description: 'JSON Schema to structure and validate the output against',
                    default: `{
	"type": "object",
	"properties": {
		"state": {
			"type": "string"
		},
		"cities": {
			"type": "array",
			"items": {
				"type": "string"
			}
		}
	}
}`,
                },
                {
                    displayName: 'Schema Type',
                    name: 'schemaType',
                    type: 'options',
                    noDataExpression: true,
                    options: [
                        {
                            name: 'Generate From JSON Example',
                            value: 'fromJson',
                            description: 'Generate a schema from an example JSON object',
                        },
                        {
                            name: 'Define Below',
                            value: 'manual',
                            description: 'Define the JSON schema manually',
                        },
                    ],
                    default: 'fromJson',
                    description: 'How to specify the schema for the function',
                    displayOptions: {
                        show: {
                            '@version': [{ _cnd: { gte: 1.2 } }],
                        },
                    },
                },
                {
                    displayName: 'JSON Example',
                    name: 'jsonSchemaExample',
                    type: 'json',
                    default: `{
	"state": "California",
	"cities": ["Los Angeles", "San Francisco", "San Diego"]
}`,
                    noDataExpression: true,
                    typeOptions: {
                        rows: 10,
                    },
                    displayOptions: {
                        show: {
                            schemaType: ['fromJson'],
                        },
                    },
                    description: 'Example JSON object to use to generate the schema',
                },
                {
                    displayName: 'Input Schema',
                    name: 'inputSchema',
                    type: 'json',
                    default: `{
	"type": "object",
	"properties": {
		"state": {
			"type": "string"
		},
		"cities": {
			"type": "array",
			"items": {
				"type": "string"
			}
		}
	}
}`,
                    noDataExpression: true,
                    typeOptions: {
                        rows: 10,
                    },
                    displayOptions: {
                        show: {
                            schemaType: ['manual'],
                        },
                    },
                    description: 'Schema to use for the function',
                },
                {
                    displayName: 'JSON Schema',
                    name: 'jsonSchema',
                    type: 'json',
                    description: 'JSON Schema to structure and validate the output against',
                    default: `{
  "type": "object",
  "properties": {
    "state": {
      "type": "string"
    },
    "cities": {
      "type": "array",
      "items": {
        "type": "string"
      }
    }
  }
}`,
                    typeOptions: {
                        rows: 10,
                    },
                    required: true,
                    displayOptions: {
                        show: {
                            '@version': [{ _cnd: { lte: 1.1 } }],
                        },
                    },
                },
                {
                    displayName: 'The schema has to be defined in the <a target="_blank" href="https://json-schema.org/">JSON Schema</a> format. Look at <a target="_blank" href="https://json-schema.org/learn/miscellaneous-examples.html">this</a> page for examples.',
                    name: 'notice',
                    type: 'notice',
                    default: '',
                    displayOptions: {
                        hide: {
                            schemaType: ['fromJson'],
                        },
                    },
                },
            ],
        };
    }
    async supplyData(itemIndex) {
        const schemaType = this.getNodeParameter('schemaType', itemIndex, '');
        const jsonExample = this.getNodeParameter('jsonSchemaExample', itemIndex, '');
        let inputSchema;
        if (this.getNode().typeVersion <= 1.1) {
            inputSchema = this.getNodeParameter('jsonSchema', itemIndex, '');
        }
        else {
            inputSchema = this.getNodeParameter('inputSchema', itemIndex, '');
        }
        const jsonSchema = schemaType === 'fromJson' ? (0, schemaParsing_1.generateSchema)(jsonExample) : (0, n8n_workflow_1.jsonParse)(inputSchema);
        const zodSchemaSandbox = (0, schemaParsing_1.getSandboxWithZod)(this, jsonSchema, 0);
        const nodeVersion = this.getNode().typeVersion;
        try {
            const parser = await N8nStructuredOutputParser.fromZedJsonSchema(zodSchemaSandbox, nodeVersion);
            return {
                response: (0, logWrapper_1.logWrapper)(parser, this),
            };
        }
        catch (error) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Error during parsing of JSON Schema.');
        }
    }
}
exports.OutputParserStructured = OutputParserStructured;
//# sourceMappingURL=OutputParserStructured.node.js.map