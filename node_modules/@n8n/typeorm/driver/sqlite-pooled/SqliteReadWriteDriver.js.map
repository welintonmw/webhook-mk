{"version":3,"sources":["../../src/driver/sqlite-pooled/SqliteReadWriteDriver.ts"],"names":[],"mappings":"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","file":"SqliteReadWriteDriver.js","sourcesContent":["import { mkdirp } from \"mkdirp\"\nimport path, { isAbsolute } from \"path\"\n\nimport { DataSource } from \"../../data-source/DataSource\"\nimport { AbstractSqliteDriver } from \"../sqlite-abstract/AbstractSqliteDriver\"\nimport { ColumnType } from \"../types/ColumnTypes\"\nimport { filepathToName } from \"../../util/PathUtils\"\nimport { SqlitePooledConnectionOptions } from \"./SqlitePooledConnectionOptions\"\nimport { SqliteWriteConnection } from \"./SqliteWriteConnection\"\nimport { SqliteReadonlyConnectionPool } from \"./SqliteReadonlyConnectionPool\"\nimport { SqliteReadWriteQueryRunner } from \"./SqliteReadWriteQueryRunner\"\nimport { SqliteLibrary } from \"./SqliteLibrary\"\n\n/**\n * Database driver for sqlite that uses sqlite3 npm package and\n * pooled database connections.\n */\nexport class SqliteReadWriteDriver extends AbstractSqliteDriver {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection options.\n     */\n    options: SqlitePooledConnectionOptions\n\n    queryRunner?: never\n    databaseConnection: never\n\n    /**\n     * SQLite underlying library.\n     */\n    sqlite: SqliteLibrary[\"sqlite\"]\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Represent transaction support by this driver. We intentionally\n     * do NOT support nested transactions\n     */\n    transactionSupport: \"simple\" | \"none\" = \"simple\"\n\n    /**\n     * Pool of read-only connections to the database.\n     */\n    private readonly readonlyPool: SqliteReadonlyConnectionPool\n\n    /**\n     * A single write connection to the database.\n     */\n    private readonly writeConnection: SqliteWriteConnection\n\n    private readonly sqliteLibrary: SqliteLibrary\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(connection: DataSource) {\n        super(connection)\n\n        this.options = connection.options as SqlitePooledConnectionOptions\n\n        this.sqliteLibrary = new SqliteLibrary(this.options)\n\n        // load sqlite package\n        this.sqliteLibrary.loadLibrary()\n        this.sqlite = this.sqliteLibrary.sqlite\n\n        this.readonlyPool = new SqliteReadonlyConnectionPool(\n            this.sqliteLibrary,\n            {\n                poolSize: this.options.poolSize ?? 4,\n                acquireTimeout: this.options.acquireTimeout ?? 60_000,\n                destroyTimeout: this.options.destroyTimeout ?? 5_000,\n            },\n        )\n        this.writeConnection = new SqliteWriteConnection(this.sqliteLibrary, {\n            acquireTimeout: this.options.acquireTimeout ?? 60_000,\n            destroyTimeout: this.options.destroyTimeout ?? 5_000,\n        })\n    }\n\n    /**\n     * Performs connection to the database.\n     */\n    async connect(): Promise<void> {\n        // We need to connect the write connection first, as that creates\n        // the main database file.\n        await this.writeConnection.connect()\n        await this.readonlyPool.connect()\n    }\n\n    /**\n     * Closes connection with database.\n     */\n    async disconnect(): Promise<void> {\n        await Promise.all([\n            this.readonlyPool.close(),\n            this.writeConnection.close(),\n        ])\n    }\n\n    /**\n     * Returns true if driver supports RETURNING / OUTPUT statement.\n     */\n    isReturningSqlSupported(): boolean {\n        return false\n    }\n\n    /**\n     * Creates a query runner used to execute database queries.\n     */\n    createQueryRunner(): SqliteReadWriteQueryRunner {\n        return new SqliteReadWriteQueryRunner(\n            this,\n            this.connection,\n            this.sqliteLibrary,\n            this.writeConnection,\n            this.readonlyPool,\n            this.options,\n        )\n    }\n\n    normalizeType(column: {\n        type?: ColumnType\n        length?: number | string\n        precision?: number | null\n        scale?: number\n    }): string {\n        if ((column.type as any) === Buffer) {\n            return \"blob\"\n        }\n\n        return super.normalizeType(column)\n    }\n\n    async afterConnect(): Promise<void> {\n        return this.attachDatabases()\n    }\n\n    /**\n     * For SQLite, the database may be added in the decorator metadata. It will be a filepath to a database file.\n     */\n    buildTableName(\n        tableName: string,\n        _schema?: string,\n        database?: string,\n    ): string {\n        if (!database) return tableName\n        if (this.getAttachedDatabaseHandleByRelativePath(database))\n            return `${this.getAttachedDatabaseHandleByRelativePath(\n                database,\n            )}.${tableName}`\n\n        if (database === this.options.database) return tableName\n\n        // we use the decorated name as supplied when deriving attach handle (ideally without non-portable absolute path)\n        const identifierHash = filepathToName(database)\n        // decorated name will be assumed relative to main database file when non absolute. Paths supplied as absolute won't be portable\n        const absFilepath = isAbsolute(database)\n            ? database\n            : path.join(this.getMainDatabasePath(), database)\n\n        this.attachedDatabases[database] = {\n            attachFilepathAbsolute: absFilepath,\n            attachFilepathRelative: database,\n            attachHandle: identifierHash,\n        }\n        this.sqliteLibrary.attachedDatabases.set(database, {\n            attachFilepathAbsolute: absFilepath,\n            attachFilepathRelative: database,\n            attachHandle: identifierHash,\n        })\n\n        return `${identifierHash}.${tableName}`\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Auto creates database directory if it does not exist.\n     */\n    protected async createDatabaseDirectory(fullPath: string): Promise<void> {\n        await mkdirp(path.dirname(fullPath))\n    }\n\n    /**\n     * Performs the attaching of the database files. The attachedDatabase should have been populated during calls to #buildTableName\n     * during EntityMetadata production (see EntityMetadata#buildTablePath)\n     *\n     * https://sqlite.org/lang_attach.html\n     */\n    protected async attachDatabases() {\n        // @todo - possibly check number of databases (but unqueriable at runtime sadly) - https://www.sqlite.org/limits.html#max_attached\n        for await (const {\n            attachHandle,\n            attachFilepathAbsolute,\n        } of Object.values(this.attachedDatabases)) {\n            await this.createDatabaseDirectory(attachFilepathAbsolute)\n\n            const queryRunner = this.createQueryRunner()\n            try {\n                await this.writeConnection.runExclusive(\n                    queryRunner,\n                    async (dbLease) => {\n                        await queryRunner.runQueryWithinConnection(\n                            dbLease.connection,\n                            `ATTACH \"${attachFilepathAbsolute}\" AS \"${attachHandle}\"`,\n                        )\n                    },\n                )\n            } finally {\n                await queryRunner.release()\n            }\n        }\n    }\n\n    protected getMainDatabasePath(): string {\n        const optionsDb = this.options.database\n        return path.dirname(\n            isAbsolute(optionsDb)\n                ? optionsDb\n                : path.join(process.cwd(), optionsDb),\n        )\n    }\n}\n"],"sourceRoot":"../.."}