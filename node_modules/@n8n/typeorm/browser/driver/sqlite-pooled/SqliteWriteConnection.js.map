{"version":3,"sources":["../browser/src/driver/sqlite-pooled/SqliteWriteConnection.ts"],"names":[],"mappings":"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","file":"SqliteWriteConnection.js","sourcesContent":["import { captureException } from \"@sentry/node\"\nimport { Database as Sqlite3Database } from \"sqlite3\"\nimport {\n    DbLease,\n    DbLeaseHolder,\n    DbLeaseOwner,\n    SqliteConnectionPool,\n} from \"./SqlitePooledTypes\"\nimport { Mutex, MutexInterface, withTimeout, E_TIMEOUT } from \"async-mutex\"\nimport assert from \"assert\"\nimport { DriverAlreadyReleasedError } from \"../../error/DriverAlreadyReleasedError\"\nimport { SqliteLibrary } from \"./SqliteLibrary\"\nimport { LeasedDbConnection } from \"./LeasedDbConnection\"\nimport { TimeoutTimer } from \"./Timer\"\n\n/**\n * A single write connection to the database.\n */\nexport class SqliteWriteConnection\n    implements SqliteConnectionPool, DbLeaseOwner\n{\n    private writeConnectionPromise: Promise<Sqlite3Database> | null = null\n\n    /**\n     * Should the connection be re-created after it has been released\n     */\n    private isConnectionValid = true\n\n    private isReleased = false\n\n    /**\n     * Mutex to control access to the write connection.\n     */\n    private readonly writeConnectionMutex: MutexInterface\n\n    private dbLease: DbLease | undefined\n\n    constructor(\n        private readonly sqliteLibray: SqliteLibrary,\n        private readonly options: {\n            acquireTimeout: number\n            destroyTimeout: number\n        },\n    ) {\n        const acquireTimeout = options.acquireTimeout\n\n        this.writeConnectionMutex = withTimeout(new Mutex(), acquireTimeout)\n    }\n\n    public async connect() {\n        this.assertNotReleased()\n\n        await this.writeConnectionMutex.runExclusive(\n            async () => await this.createConnection(),\n        )\n    }\n\n    public async close(): Promise<void> {\n        if (this.isReleased) return\n\n        this.isReleased = true\n\n        // Cancel any pending acquires\n        this.writeConnectionMutex.cancel()\n        // If there is an existing lease, request it to be released\n        if (this.dbLease) {\n            this.dbLease.requestRelease()\n        }\n\n        const timeoutTimer = TimeoutTimer.start(this.options.destroyTimeout)\n        await Promise.race([\n            this.writeConnectionMutex.acquire(),\n            timeoutTimer.promise,\n        ]).finally(() => {\n            timeoutTimer.clear()\n        })\n\n        if (this.writeConnectionPromise) {\n            const dbConnection = await this.writeConnectionPromise\n            this.sqliteLibray.destroyDatabaseConnection(dbConnection)\n        }\n    }\n\n    public async runExclusive<T>(\n        dbLeaseHolder: DbLeaseHolder,\n        callback: (dbLease: DbLease) => Promise<T>,\n    ): Promise<T> {\n        this.assertNotReleased()\n\n        try {\n            return await this.writeConnectionMutex.runExclusive(async () => {\n                this.dbLease = await this.createAndGetConnection(dbLeaseHolder)\n\n                const result = await callback(this.dbLease)\n\n                return result\n            })\n        } catch (error) {\n            if (error === E_TIMEOUT) {\n                captureException(error)\n            }\n\n            throw error\n        } finally {\n            this.dbLease = undefined\n        }\n    }\n\n    public async leaseConnection(dbLeaseHolder: DbLeaseHolder) {\n        this.assertNotReleased()\n\n        try {\n            await this.writeConnectionMutex.acquire()\n        } catch (error) {\n            captureException(error)\n            throw error\n        }\n\n        this.dbLease = await this.createAndGetConnection(dbLeaseHolder)\n        return this.dbLease\n    }\n\n    public invalidateConnection(leasedDbConnection: DbLease): void {\n        assert(this.dbLease === leasedDbConnection)\n        assert(this.writeConnectionMutex.isLocked())\n        assert(this.writeConnectionPromise)\n        this.isConnectionValid = false\n    }\n\n    public async releaseConnection(leasedDbConnection: DbLease) {\n        assert(this.dbLease === leasedDbConnection)\n        assert(this.writeConnectionMutex.isLocked())\n        assert(this.writeConnectionPromise)\n\n        try {\n            const connection = await this.writeConnectionPromise\n            if (!this.isConnectionValid) {\n                this.sqliteLibray.destroyDatabaseConnection(connection)\n                this.writeConnectionPromise = null\n            }\n        } finally {\n            this.dbLease = undefined\n            this.writeConnectionMutex.release()\n        }\n    }\n\n    private async createAndGetConnection(\n        dbLeaseHolder: DbLeaseHolder,\n    ): Promise<LeasedDbConnection> {\n        if (!this.writeConnectionPromise) {\n            this.writeConnectionPromise =\n                this.sqliteLibray.createDatabaseConnection()\n        }\n\n        const dbConnection = await this.writeConnectionPromise\n\n        assert(!this.dbLease)\n        return new LeasedDbConnection(dbConnection, this, dbLeaseHolder)\n    }\n\n    private async createConnection() {\n        this.assertNotReleased()\n\n        if (this.writeConnectionPromise) {\n            throw new Error(\"Connection already created\")\n        }\n\n        this.writeConnectionPromise =\n            this.sqliteLibray.createDatabaseConnection()\n        return this.writeConnectionPromise\n    }\n\n    private assertNotReleased() {\n        if (this.isReleased) {\n            throw new DriverAlreadyReleasedError()\n        }\n    }\n}\n"],"sourceRoot":"../.."}