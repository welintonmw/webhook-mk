/// <reference types="node" />
import type { DeleteResult } from '@n8n/typeorm';
import EventEmitter from 'events';
import type { MessageEventBusDestinationOptions } from 'n8n-workflow';
import { EventDestinationsRepository } from '../../databases/repositories/eventDestinations.repository';
import { ExecutionRepository } from '../../databases/repositories/execution.repository';
import { WorkflowRepository } from '../../databases/repositories/workflow.repository';
import { OrchestrationService } from '../../services/orchestration.service';
import { Logger } from '../../Logger';
import type { EventMessageTypes } from '../EventMessageClasses/';
import type { MessageEventBusDestination } from '../MessageEventBusDestination/MessageEventBusDestination.ee';
import { MessageEventBusLogWriter } from '../MessageEventBusWriter/MessageEventBusLogWriter';
import type { EventMessageConfirmSource } from '../EventMessageClasses/EventMessageConfirm';
import type { EventMessageAuditOptions } from '../EventMessageClasses/EventMessageAudit';
import type { EventMessageWorkflowOptions } from '../EventMessageClasses/EventMessageWorkflow';
import type { EventMessageNodeOptions } from '../EventMessageClasses/EventMessageNode';
import { ExecutionRecoveryService } from '../../executions/execution-recovery.service';
import { type EventMessageAiNodeOptions } from '../EventMessageClasses/EventMessageAiNode';
import { License } from '../../License';
export type EventMessageReturnMode = 'sent' | 'unsent' | 'all' | 'unfinished';
export interface MessageWithCallback {
    msg: EventMessageTypes;
    confirmCallback: (message: EventMessageTypes, src: EventMessageConfirmSource) => void;
}
export interface MessageEventBusInitializeOptions {
    skipRecoveryPass?: boolean;
    workerId?: string;
}
export declare class MessageEventBus extends EventEmitter {
    private readonly logger;
    private readonly executionRepository;
    private readonly eventDestinationsRepository;
    private readonly workflowRepository;
    private readonly orchestrationService;
    private readonly recoveryService;
    private readonly license;
    private isInitialized;
    logWriter: MessageEventBusLogWriter;
    destinations: {
        [key: string]: MessageEventBusDestination;
    };
    private pushIntervalTimer;
    constructor(logger: Logger, executionRepository: ExecutionRepository, eventDestinationsRepository: EventDestinationsRepository, workflowRepository: WorkflowRepository, orchestrationService: OrchestrationService, recoveryService: ExecutionRecoveryService, license: License);
    initialize(options?: MessageEventBusInitializeOptions): Promise<void>;
    addDestination(destination: MessageEventBusDestination, notifyWorkers?: boolean): Promise<MessageEventBusDestination>;
    findDestination(id?: string): Promise<MessageEventBusDestinationOptions[]>;
    removeDestination(id: string, notifyWorkers?: boolean): Promise<DeleteResult | undefined>;
    private trySendingUnsent;
    close(): Promise<void>;
    restart(): Promise<void>;
    send(msgs: EventMessageTypes | EventMessageTypes[]): Promise<void>;
    testDestination(destinationId: string): Promise<boolean>;
    confirmSent(msg: EventMessageTypes, source?: EventMessageConfirmSource): void;
    private hasAnyDestinationSubscribedToEvent;
    private emitMessage;
    private emitMessageWithCallback;
    shouldSendMsg(msg: EventMessageTypes): boolean;
    getEventsAll(): Promise<EventMessageTypes[]>;
    getEventsSent(): Promise<EventMessageTypes[]>;
    getEventsUnsent(): Promise<EventMessageTypes[]>;
    getUnfinishedExecutions(): Promise<Record<string, EventMessageTypes[]>>;
    getUnsentAndUnfinishedExecutions(): Promise<{
        unsentMessages: EventMessageTypes[];
        unfinishedExecutions: Record<string, EventMessageTypes[] | undefined>;
    }>;
    getEventsByExecutionId(executionId: string, logHistory?: number): Promise<EventMessageTypes[]>;
    sendAuditEvent(options: EventMessageAuditOptions): Promise<void>;
    sendWorkflowEvent(options: EventMessageWorkflowOptions): Promise<void>;
    sendNodeEvent(options: EventMessageNodeOptions): Promise<void>;
    sendAiNodeEvent(options: EventMessageAiNodeOptions): Promise<void>;
}
