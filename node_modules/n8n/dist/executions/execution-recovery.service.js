"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecutionRecoveryService = void 0;
const typedi_1 = __importStar(require("typedi"));
const push_1 = require("../push");
const n8n_workflow_1 = require("n8n-workflow");
const execution_repository_1 = require("../databases/repositories/execution.repository");
const WorkflowExecuteAdditionalData_1 = require("../WorkflowExecuteAdditionalData");
const InternalHooks_1 = require("../InternalHooks");
const node_crashed_error_1 = require("../errors/node-crashed.error");
const workflow_crashed_error_1 = require("../errors/workflow-crashed.error");
const constants_1 = require("../constants");
const Logger_1 = require("../Logger");
const config_1 = __importDefault(require("../config"));
const OnShutdown_1 = require("../decorators/OnShutdown");
const orchestration_service_1 = require("../services/orchestration.service");
const event_relay_service_1 = require("../eventbus/event-relay.service");
let ExecutionRecoveryService = class ExecutionRecoveryService {
    constructor(logger, push, executionRepository, orchestrationService, eventRelay) {
        this.logger = logger;
        this.push = push;
        this.executionRepository = executionRepository;
        this.orchestrationService = orchestrationService;
        this.eventRelay = eventRelay;
        this.queueRecoverySettings = {
            batchSize: config_1.default.getEnv('executions.queueRecovery.batchSize'),
            waitMs: config_1.default.getEnv('executions.queueRecovery.interval') * 60 * 1000,
        };
        this.isShuttingDown = false;
    }
    init() {
        if (config_1.default.getEnv('executions.mode') === 'regular')
            return;
        const { isLeader, isMultiMainSetupEnabled } = this.orchestrationService;
        if (isLeader)
            this.scheduleQueueRecovery();
        if (isMultiMainSetupEnabled) {
            this.orchestrationService.multiMainSetup
                .on('leader-takeover', () => this.scheduleQueueRecovery())
                .on('leader-stepdown', () => this.stopQueueRecovery());
        }
    }
    async recoverFromLogs(executionId, messages) {
        if (this.orchestrationService.isFollower)
            return;
        const amendedExecution = await this.amend(executionId, messages);
        if (!amendedExecution)
            return null;
        this.logger.info('[Recovery] Logs available, amended execution', {
            executionId: amendedExecution.id,
        });
        await this.executionRepository.updateExistingExecution(executionId, amendedExecution);
        await this.runHooks(amendedExecution);
        this.push.once('editorUiConnected', async () => {
            await (0, n8n_workflow_1.sleep)(1000);
            this.push.broadcast('executionRecovered', { executionId });
        });
        return amendedExecution;
    }
    scheduleQueueRecovery(waitMs = this.queueRecoverySettings.waitMs) {
        if (!this.shouldScheduleQueueRecovery())
            return;
        this.queueRecoverySettings.timeout = setTimeout(async () => {
            try {
                const nextWaitMs = await this.recoverFromQueue();
                this.scheduleQueueRecovery(nextWaitMs);
            }
            catch (error) {
                const msg = this.toErrorMsg(error);
                this.logger.error('[Recovery] Failed to recover dangling executions from queue', { msg });
                this.logger.error('[Recovery] Retrying...');
                this.scheduleQueueRecovery();
            }
        }, waitMs);
        const wait = [this.queueRecoverySettings.waitMs / (60 * 1000), 'min'].join(' ');
        this.logger.debug(`[Recovery] Scheduled queue recovery check for next ${wait}`);
    }
    stopQueueRecovery() {
        clearTimeout(this.queueRecoverySettings.timeout);
    }
    shutdown() {
        this.isShuttingDown = true;
        this.stopQueueRecovery();
    }
    async recoverFromQueue() {
        const { waitMs, batchSize } = this.queueRecoverySettings;
        const storedIds = await this.executionRepository.getInProgressExecutionIds(batchSize);
        if (storedIds.length === 0) {
            this.logger.debug('[Recovery] Completed queue recovery check, no dangling executions');
            return waitMs;
        }
        const { Queue } = await Promise.resolve().then(() => __importStar(require('../Queue')));
        const queuedIds = await typedi_1.default.get(Queue).getInProgressExecutionIds();
        if (queuedIds.size === 0) {
            this.logger.debug('[Recovery] Completed queue recovery check, no dangling executions');
            return waitMs;
        }
        const danglingIds = storedIds.filter((id) => !queuedIds.has(id));
        if (danglingIds.length === 0) {
            this.logger.debug('[Recovery] Completed queue recovery check, no dangling executions');
            return waitMs;
        }
        await this.executionRepository.markAsCrashed(danglingIds);
        this.logger.info('[Recovery] Completed queue recovery check, recovered dangling executions', {
            danglingIds,
        });
        return storedIds.length >= this.queueRecoverySettings.batchSize ? waitMs / 2 : waitMs;
    }
    async amend(executionId, messages) {
        var _a, _b;
        if (messages.length === 0)
            return await this.amendWithoutLogs(executionId);
        const { nodeMessages, workflowMessages } = this.toRelevantMessages(messages);
        if (nodeMessages.length === 0)
            return null;
        const execution = await this.executionRepository.findSingleExecution(executionId, {
            includeData: true,
            unflattenData: true,
        });
        if (!execution || execution.status === 'success')
            return null;
        const runExecutionData = (_a = execution.data) !== null && _a !== void 0 ? _a : { resultData: { runData: {} } };
        let lastNodeRunTimestamp;
        for (const node of execution.workflowData.nodes) {
            const nodeStartedMessage = nodeMessages.find((m) => m.payload.nodeName === node.name && m.eventName === 'n8n.node.started');
            if (!nodeStartedMessage)
                continue;
            const nodeFinishedMessage = nodeMessages.find((m) => m.payload.nodeName === node.name && m.eventName === 'n8n.node.finished');
            const taskData = {
                startTime: nodeStartedMessage.ts.toUnixInteger(),
                executionTime: -1,
                source: [null],
            };
            if (nodeFinishedMessage) {
                taskData.executionStatus = 'success';
                (_b = taskData.data) !== null && _b !== void 0 ? _b : (taskData.data = constants_1.ARTIFICIAL_TASK_DATA);
                taskData.executionTime = nodeFinishedMessage.ts.diff(nodeStartedMessage.ts).toMillis();
                lastNodeRunTimestamp = nodeFinishedMessage.ts;
            }
            else {
                taskData.executionStatus = 'crashed';
                taskData.error = new node_crashed_error_1.NodeCrashedError(node);
                taskData.executionTime = 0;
                runExecutionData.resultData.error = new workflow_crashed_error_1.WorkflowCrashedError();
                lastNodeRunTimestamp = nodeStartedMessage.ts;
            }
            runExecutionData.resultData.lastNodeExecuted = node.name;
            runExecutionData.resultData.runData[node.name] = [taskData];
        }
        return {
            ...execution,
            status: execution.status === 'error' ? 'error' : 'crashed',
            stoppedAt: this.toStoppedAt(lastNodeRunTimestamp, workflowMessages),
            data: runExecutionData,
        };
    }
    async amendWithoutLogs(executionId) {
        const exists = await this.executionRepository.exists({ where: { id: executionId } });
        if (!exists)
            return null;
        await this.executionRepository.markAsCrashed(executionId);
        const execution = await this.executionRepository.findSingleExecution(executionId, {
            includeData: true,
            unflattenData: true,
        });
        return execution !== null && execution !== void 0 ? execution : null;
    }
    toRelevantMessages(messages) {
        return messages.reduce((acc, cur) => {
            if (cur.eventName.startsWith('n8n.node.')) {
                acc.nodeMessages.push(cur);
            }
            else if (cur.eventName.startsWith('n8n.workflow.')) {
                acc.workflowMessages.push(cur);
            }
            return acc;
        }, { nodeMessages: [], workflowMessages: [] });
    }
    toStoppedAt(timestamp, messages) {
        var _a, _b;
        if (timestamp)
            return timestamp.toJSDate();
        const WORKFLOW_END_EVENTS = new Set([
            'n8n.workflow.success',
            'n8n.workflow.crashed',
            'n8n.workflow.failed',
        ]);
        return (_b = ((_a = messages.find((m) => WORKFLOW_END_EVENTS.has(m.eventName))) !== null && _a !== void 0 ? _a : messages.find((m) => m.eventName === 'n8n.workflow.started'))) === null || _b === void 0 ? void 0 : _b.ts.toJSDate();
    }
    async runHooks(execution) {
        var _a, _b;
        (_a = execution.data) !== null && _a !== void 0 ? _a : (execution.data = { resultData: { runData: {} } });
        await typedi_1.default.get(InternalHooks_1.InternalHooks).onWorkflowPostExecute(execution.id, execution.workflowData, {
            data: execution.data,
            finished: false,
            mode: execution.mode,
            waitTill: execution.waitTill,
            startedAt: execution.startedAt,
            stoppedAt: execution.stoppedAt,
            status: execution.status,
        });
        this.eventRelay.emit('workflow-post-execute', {
            workflowId: execution.workflowData.id,
            workflowName: execution.workflowData.name,
            executionId: execution.id,
            success: execution.status === 'success',
            isManual: execution.mode === 'manual',
        });
        const externalHooks = (0, WorkflowExecuteAdditionalData_1.getWorkflowHooksMain)({
            userId: '',
            workflowData: execution.workflowData,
            executionMode: execution.mode,
            executionData: execution.data,
            runData: execution.data.resultData.runData,
            retryOf: execution.retryOf,
        }, execution.id);
        const run = {
            data: execution.data,
            finished: false,
            mode: execution.mode,
            waitTill: (_b = execution.waitTill) !== null && _b !== void 0 ? _b : undefined,
            startedAt: execution.startedAt,
            stoppedAt: execution.stoppedAt,
            status: execution.status,
        };
        await externalHooks.executeHookFunctions('workflowExecuteAfter', [run]);
    }
    toErrorMsg(error) {
        return error instanceof Error
            ? error.message
            : (0, n8n_workflow_1.jsonStringify)(error, { replaceCircularRefs: true });
    }
    shouldScheduleQueueRecovery() {
        return (config_1.default.getEnv('executions.mode') === 'queue' &&
            config_1.default.getEnv('multiMainSetup.instanceType') === 'leader' &&
            !this.isShuttingDown);
    }
};
exports.ExecutionRecoveryService = ExecutionRecoveryService;
__decorate([
    (0, OnShutdown_1.OnShutdown)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ExecutionRecoveryService.prototype, "shutdown", null);
exports.ExecutionRecoveryService = ExecutionRecoveryService = __decorate([
    (0, typedi_1.Service)(),
    __metadata("design:paramtypes", [Logger_1.Logger,
        push_1.Push,
        execution_repository_1.ExecutionRepository,
        orchestration_service_1.OrchestrationService,
        event_relay_service_1.EventRelay])
], ExecutionRecoveryService);
//# sourceMappingURL=execution-recovery.service.js.map