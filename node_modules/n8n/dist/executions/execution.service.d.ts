import type { ExecutionError, INode, WorkflowExecuteMode } from 'n8n-workflow';
import { Workflow } from 'n8n-workflow';
import { ActiveExecutions } from '../ActiveExecutions';
import type { IExecutionFlattedResponse, IExecutionResponse, IWorkflowDb } from '../Interfaces';
import { NodeTypes } from '../NodeTypes';
import { Queue } from '../Queue';
import type { ExecutionRequest, ExecutionSummaries } from './execution.types';
import { WorkflowRunner } from '../WorkflowRunner';
import { ExecutionRepository } from '../databases/repositories/execution.repository';
import { WorkflowRepository } from '../databases/repositories/workflow.repository';
import { Logger } from '../Logger';
import { WaitTracker } from '../WaitTracker';
import { ConcurrencyControlService } from '../concurrency/concurrency-control.service';
import { License } from '../License';
export declare const schemaGetExecutionsQueryFilter: {
    $id: string;
    type: string;
    properties: {
        id: {
            type: string;
        };
        finished: {
            type: string;
        };
        mode: {
            type: string;
        };
        retryOf: {
            type: string;
        };
        retrySuccessId: {
            type: string;
        };
        status: {
            type: string;
            items: {
                type: string;
            };
        };
        waitTill: {
            type: string;
        };
        workflowId: {
            anyOf: {
                type: string;
            }[];
        };
        metadata: {
            type: string;
            items: {
                $ref: string;
            };
        };
        startedAfter: {
            type: string;
        };
        startedBefore: {
            type: string;
        };
    };
    $defs: {
        metadata: {
            type: string;
            required: string[];
            properties: {
                key: {
                    type: string;
                };
                value: {
                    type: string;
                };
            };
        };
    };
};
export declare const allowedExecutionsQueryFilterFields: string[];
export declare class ExecutionService {
    private readonly logger;
    private readonly queue;
    private readonly activeExecutions;
    private readonly executionRepository;
    private readonly workflowRepository;
    private readonly nodeTypes;
    private readonly waitTracker;
    private readonly workflowRunner;
    private readonly concurrencyControl;
    private readonly license;
    constructor(logger: Logger, queue: Queue, activeExecutions: ActiveExecutions, executionRepository: ExecutionRepository, workflowRepository: WorkflowRepository, nodeTypes: NodeTypes, waitTracker: WaitTracker, workflowRunner: WorkflowRunner, concurrencyControl: ConcurrencyControlService, license: License);
    findOne(req: ExecutionRequest.GetOne, sharedWorkflowIds: string[]): Promise<IExecutionResponse | IExecutionFlattedResponse | undefined>;
    retry(req: ExecutionRequest.Retry, sharedWorkflowIds: string[]): Promise<boolean>;
    delete(req: ExecutionRequest.Delete, sharedWorkflowIds: string[]): Promise<void>;
    createErrorExecution(error: ExecutionError, node: INode, workflowData: IWorkflowDb, workflow: Workflow, mode: WorkflowExecuteMode): Promise<void>;
    private readonly isRegularMode;
    findRangeWithCount(query: ExecutionSummaries.RangeQuery): Promise<{
        count: number;
        estimated: boolean;
        results: import("n8n-workflow").ExecutionSummary[];
    }>;
    findLatestCurrentAndCompleted(query: ExecutionSummaries.RangeQuery): Promise<{
        results: import("n8n-workflow").ExecutionSummary[];
        count: number;
        estimated: boolean;
    }>;
    stop(executionId: string): Promise<import("../Interfaces").ExecutionStopResult | undefined>;
    private toExecutionStopResult;
    findAllEnqueuedExecutions(): Promise<IExecutionResponse[]>;
}
