"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WaitTracker = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const typedi_1 = require("typedi");
const WorkflowRunner_1 = require("./WorkflowRunner");
const execution_repository_1 = require("./databases/repositories/execution.repository");
const ownership_service_1 = require("./services/ownership.service");
const Logger_1 = require("./Logger");
const orchestration_service_1 = require("./services/orchestration.service");
let WaitTracker = class WaitTracker {
    constructor(logger, executionRepository, ownershipService, workflowRunner, orchestrationService) {
        this.logger = logger;
        this.executionRepository = executionRepository;
        this.ownershipService = ownershipService;
        this.workflowRunner = workflowRunner;
        this.orchestrationService = orchestrationService;
        this.waitingExecutions = {};
    }
    init() {
        const { isLeader, isMultiMainSetupEnabled } = this.orchestrationService;
        if (isLeader)
            this.startTracking();
        if (isMultiMainSetupEnabled) {
            this.orchestrationService.multiMainSetup
                .on('leader-takeover', () => this.startTracking())
                .on('leader-stepdown', () => this.stopTracking());
        }
    }
    startTracking() {
        this.logger.debug('Wait tracker started tracking waiting executions');
        this.mainTimer = setInterval(() => {
            void this.getWaitingExecutions();
        }, 60000);
        void this.getWaitingExecutions();
    }
    async getWaitingExecutions() {
        this.logger.debug('Wait tracker querying database for waiting executions');
        const executions = await this.executionRepository.getWaitingExecutions();
        if (executions.length === 0) {
            return;
        }
        const executionIds = executions.map((execution) => execution.id).join(', ');
        this.logger.debug(`Wait tracker found ${executions.length} executions. Setting timer for IDs: ${executionIds}`);
        for (const execution of executions) {
            const executionId = execution.id;
            if (this.waitingExecutions[executionId] === undefined) {
                if (!(execution.waitTill instanceof Date)) {
                    n8n_workflow_1.ErrorReporterProxy.error('Wait Till is not a date object', {
                        extra: {
                            variableType: typeof execution.waitTill,
                        },
                    });
                    if (typeof execution.waitTill === 'string') {
                        execution.waitTill = new Date(execution.waitTill);
                    }
                }
                const triggerTime = execution.waitTill.getTime() - new Date().getTime();
                this.waitingExecutions[executionId] = {
                    executionId,
                    timer: setTimeout(() => {
                        this.startExecution(executionId);
                    }, triggerTime),
                };
            }
        }
    }
    async stopExecution(executionId) {
        if (this.waitingExecutions[executionId] !== undefined) {
            clearTimeout(this.waitingExecutions[executionId].timer);
            delete this.waitingExecutions[executionId];
        }
        const fullExecutionData = await this.executionRepository.findSingleExecution(executionId, {
            includeData: true,
            unflattenData: true,
        });
        if (!fullExecutionData) {
            throw new n8n_workflow_1.ApplicationError('Execution not found.', {
                extra: { executionId },
            });
        }
        if (!['new', 'unknown', 'waiting', 'running'].includes(fullExecutionData.status)) {
            throw new n8n_workflow_1.WorkflowOperationError(`Only running or waiting executions can be stopped and ${executionId} is currently ${fullExecutionData.status}.`);
        }
        const error = new n8n_workflow_1.WorkflowOperationError('Workflow-Execution has been canceled!');
        fullExecutionData.data.resultData.error = {
            ...error,
            message: error.message,
            stack: error.stack,
        };
        fullExecutionData.stoppedAt = new Date();
        fullExecutionData.waitTill = null;
        fullExecutionData.status = 'canceled';
        await this.executionRepository.updateExistingExecution(executionId, fullExecutionData);
        return {
            mode: fullExecutionData.mode,
            startedAt: new Date(fullExecutionData.startedAt),
            stoppedAt: fullExecutionData.stoppedAt ? new Date(fullExecutionData.stoppedAt) : undefined,
            finished: fullExecutionData.finished,
            status: fullExecutionData.status,
        };
    }
    startExecution(executionId) {
        this.logger.debug(`Wait tracker resuming execution ${executionId}`, { executionId });
        delete this.waitingExecutions[executionId];
        (async () => {
            const fullExecutionData = await this.executionRepository.findSingleExecution(executionId, {
                includeData: true,
                unflattenData: true,
            });
            if (!fullExecutionData) {
                throw new n8n_workflow_1.ApplicationError('Execution does not exist.', { extra: { executionId } });
            }
            if (fullExecutionData.finished) {
                throw new n8n_workflow_1.ApplicationError('The execution did succeed and can so not be started again.');
            }
            if (!fullExecutionData.workflowData.id) {
                throw new n8n_workflow_1.ApplicationError('Only saved workflows can be resumed.');
            }
            const workflowId = fullExecutionData.workflowData.id;
            const project = await this.ownershipService.getWorkflowProjectCached(workflowId);
            const data = {
                executionMode: fullExecutionData.mode,
                executionData: fullExecutionData.data,
                workflowData: fullExecutionData.workflowData,
                projectId: project.id,
            };
            await this.workflowRunner.run(data, false, false, executionId);
        })().catch((error) => {
            n8n_workflow_1.ErrorReporterProxy.error(error);
            this.logger.error(`There was a problem starting the waiting execution with id "${executionId}": "${error.message}"`, { executionId });
        });
    }
    stopTracking() {
        this.logger.debug('Wait tracker shutting down');
        clearInterval(this.mainTimer);
        Object.keys(this.waitingExecutions).forEach((executionId) => {
            clearTimeout(this.waitingExecutions[executionId].timer);
        });
    }
};
exports.WaitTracker = WaitTracker;
exports.WaitTracker = WaitTracker = __decorate([
    (0, typedi_1.Service)(),
    __metadata("design:paramtypes", [Logger_1.Logger,
        execution_repository_1.ExecutionRepository,
        ownership_service_1.OwnershipService,
        WorkflowRunner_1.WorkflowRunner,
        orchestration_service_1.OrchestrationService])
], WaitTracker);
//# sourceMappingURL=WaitTracker.js.map