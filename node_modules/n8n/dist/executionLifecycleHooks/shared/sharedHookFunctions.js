"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateExistingExecution = exports.prepareExecutionDataForDbUpdate = exports.determineFinalExecutionStatus = void 0;
const typedi_1 = require("typedi");
const pick_1 = __importDefault(require("lodash/pick"));
const utils_1 = require("../../utils");
const execution_repository_1 = require("../../databases/repositories/execution.repository");
const executionMetadata_service_1 = require("../../services/executionMetadata.service");
const Logger_1 = require("../../Logger");
function determineFinalExecutionStatus(runData) {
    var _a;
    const workflowHasCrashed = runData.status === 'crashed';
    const workflowWasCanceled = runData.status === 'canceled';
    const workflowHasFailed = runData.status === 'error';
    const workflowDidSucceed = !((_a = runData.data.resultData) === null || _a === void 0 ? void 0 : _a.error) &&
        !workflowHasCrashed &&
        !workflowWasCanceled &&
        !workflowHasFailed;
    let workflowStatusFinal = workflowDidSucceed ? 'success' : 'error';
    if (workflowHasCrashed)
        workflowStatusFinal = 'crashed';
    if (workflowWasCanceled)
        workflowStatusFinal = 'canceled';
    if (runData.waitTill)
        workflowStatusFinal = 'waiting';
    return workflowStatusFinal;
}
exports.determineFinalExecutionStatus = determineFinalExecutionStatus;
function prepareExecutionDataForDbUpdate(parameters) {
    const { runData, workflowData, workflowStatusFinal, retryOf } = parameters;
    const pristineWorkflowData = (0, pick_1.default)(workflowData, [
        'id',
        'name',
        'active',
        'createdAt',
        'updatedAt',
        'nodes',
        'connections',
        'settings',
        'staticData',
        'pinData',
    ]);
    const fullExecutionData = {
        data: runData.data,
        mode: runData.mode,
        finished: runData.finished ? runData.finished : false,
        startedAt: runData.startedAt,
        stoppedAt: runData.stoppedAt,
        workflowData: pristineWorkflowData,
        waitTill: runData.waitTill,
        status: workflowStatusFinal,
        workflowId: pristineWorkflowData.id,
    };
    if (retryOf !== undefined) {
        fullExecutionData.retryOf = retryOf.toString();
    }
    const workflowId = workflowData.id;
    if ((0, utils_1.isWorkflowIdValid)(workflowId)) {
        fullExecutionData.workflowId = workflowId;
    }
    return fullExecutionData;
}
exports.prepareExecutionDataForDbUpdate = prepareExecutionDataForDbUpdate;
async function updateExistingExecution(parameters) {
    var _a;
    const logger = typedi_1.Container.get(Logger_1.Logger);
    const { executionId, workflowId, executionData } = parameters;
    logger.debug(`Save execution data to database for execution ID ${executionId}`, {
        executionId,
        workflowId,
        finished: executionData.finished,
        stoppedAt: executionData.stoppedAt,
    });
    await typedi_1.Container.get(execution_repository_1.ExecutionRepository).updateExistingExecution(executionId, executionData);
    try {
        if ((_a = executionData.data) === null || _a === void 0 ? void 0 : _a.resultData.metadata) {
            await typedi_1.Container.get(executionMetadata_service_1.ExecutionMetadataService).save(executionId, executionData.data.resultData.metadata);
        }
    }
    catch (e) {
        logger.error(`Failed to save metadata for execution ID ${executionId}`, e);
    }
    if (executionData.finished === true && executionData.retryOf !== undefined) {
        await typedi_1.Container.get(execution_repository_1.ExecutionRepository).updateExistingExecution(executionData.retryOf, {
            retrySuccessId: executionId,
        });
    }
}
exports.updateExistingExecution = updateExistingExecution;
//# sourceMappingURL=sharedHookFunctions.js.map