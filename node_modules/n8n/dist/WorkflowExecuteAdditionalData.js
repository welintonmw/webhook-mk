"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWorkflowHooksMain = exports.getWorkflowHooksWorkerMain = exports.getWorkflowHooksWorkerExecuter = exports.getBase = exports.sendDataToUI = exports.setExecutionStatus = exports.getWorkflowData = exports.getRunData = exports.hookFunctionsPreExecute = exports.executeErrorWorkflow = exports.objectToError = void 0;
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const typedi_1 = require("typedi");
const config_1 = __importDefault(require("./config"));
const ActiveExecutions_1 = require("./ActiveExecutions");
const CredentialsHelper_1 = require("./CredentialsHelper");
const ExternalHooks_1 = require("./ExternalHooks");
const NodeTypes_1 = require("./NodeTypes");
const push_1 = require("./push");
const WorkflowHelpers = __importStar(require("./WorkflowHelpers"));
const utils_1 = require("./utils");
const PermissionChecker_1 = require("./UserManagement/PermissionChecker");
const InternalHooks_1 = require("./InternalHooks");
const execution_repository_1 = require("./databases/repositories/execution.repository");
const events_service_1 = require("./services/events.service");
const SecretsHelpers_1 = require("./SecretsHelpers");
const ownership_service_1 = require("./services/ownership.service");
const sharedHookFunctions_1 = require("./executionLifecycleHooks/shared/sharedHookFunctions");
const restoreBinaryDataId_1 = require("./executionLifecycleHooks/restoreBinaryDataId");
const toSaveSettings_1 = require("./executionLifecycleHooks/toSaveSettings");
const Logger_1 = require("./Logger");
const saveExecutionProgress_1 = require("./executionLifecycleHooks/saveExecutionProgress");
const workflowStaticData_service_1 = require("./workflows/workflowStaticData.service");
const workflow_repository_1 = require("./databases/repositories/workflow.repository");
const url_service_1 = require("./services/url.service");
const workflowExecution_service_1 = require("./workflows/workflowExecution.service");
const MessageEventBus_1 = require("./eventbus/MessageEventBus/MessageEventBus");
const event_relay_service_1 = require("./eventbus/event-relay.service");
const ERROR_TRIGGER_TYPE = config_1.default.getEnv('nodes.errorTriggerType');
function objectToError(errorObject, workflow) {
    if (errorObject instanceof Error) {
        return errorObject;
    }
    else if (errorObject && typeof errorObject === 'object' && 'message' in errorObject) {
        let error;
        if ('node' in errorObject) {
            const node = workflow.getNode(errorObject.node.name);
            if (node) {
                error = new n8n_workflow_1.NodeOperationError(node, errorObject, errorObject);
            }
        }
        if (error === undefined) {
            error = new Error(errorObject.message);
        }
        if ('description' in errorObject) {
            error.description = errorObject.description;
        }
        if ('stack' in errorObject) {
            error.stack = errorObject.stack;
        }
        return error;
    }
    else {
        return new Error('An error occurred');
    }
}
exports.objectToError = objectToError;
function executeErrorWorkflow(workflowData, fullRunData, mode, executionId, retryOf) {
    var _a;
    const logger = typedi_1.Container.get(Logger_1.Logger);
    let pastExecutionUrl;
    if (executionId !== undefined) {
        pastExecutionUrl = `${typedi_1.Container.get(url_service_1.UrlService).getWebhookBaseUrl()}workflow/${workflowData.id}/executions/${executionId}`;
    }
    if (fullRunData.data.resultData.error !== undefined) {
        let workflowErrorData;
        const workflowId = workflowData.id;
        if (executionId) {
            workflowErrorData = {
                execution: {
                    id: executionId,
                    url: pastExecutionUrl,
                    error: fullRunData.data.resultData.error,
                    lastNodeExecuted: fullRunData.data.resultData.lastNodeExecuted,
                    mode,
                    retryOf,
                },
                workflow: {
                    id: workflowId,
                    name: workflowData.name,
                },
            };
        }
        else {
            workflowErrorData = {
                trigger: {
                    error: fullRunData.data.resultData.error,
                    mode,
                },
                workflow: {
                    id: workflowId,
                    name: workflowData.name,
                },
            };
        }
        const { errorWorkflow } = (_a = workflowData.settings) !== null && _a !== void 0 ? _a : {};
        if (errorWorkflow && !(mode === 'error' && workflowId && errorWorkflow === workflowId)) {
            logger.verbose('Start external error workflow', {
                executionId,
                errorWorkflowId: errorWorkflow,
                workflowId,
            });
            if (!workflowId) {
                return;
            }
            typedi_1.Container.get(ownership_service_1.OwnershipService)
                .getWorkflowProjectCached(workflowId)
                .then((project) => {
                void typedi_1.Container.get(workflowExecution_service_1.WorkflowExecutionService).executeErrorWorkflow(errorWorkflow, workflowErrorData, project);
            })
                .catch((error) => {
                n8n_workflow_1.ErrorReporterProxy.error(error);
                logger.error(`Could not execute ErrorWorkflow for execution ID ${this.executionId} because of error querying the workflow owner`, {
                    executionId,
                    errorWorkflowId: errorWorkflow,
                    workflowId,
                    error,
                    workflowErrorData,
                });
            });
        }
        else if (mode !== 'error' &&
            workflowId !== undefined &&
            workflowData.nodes.some((node) => node.type === ERROR_TRIGGER_TYPE)) {
            logger.verbose('Start internal error workflow', { executionId, workflowId });
            void typedi_1.Container.get(ownership_service_1.OwnershipService)
                .getWorkflowProjectCached(workflowId)
                .then((project) => {
                void typedi_1.Container.get(workflowExecution_service_1.WorkflowExecutionService).executeErrorWorkflow(workflowId, workflowErrorData, project);
            });
        }
    }
}
exports.executeErrorWorkflow = executeErrorWorkflow;
function hookFunctionsPush() {
    const logger = typedi_1.Container.get(Logger_1.Logger);
    const pushInstance = typedi_1.Container.get(push_1.Push);
    return {
        nodeExecuteBefore: [
            async function (nodeName) {
                const { pushRef, executionId } = this;
                if (pushRef === undefined) {
                    return;
                }
                logger.debug(`Executing hook on node "${nodeName}" (hookFunctionsPush)`, {
                    executionId,
                    pushRef,
                    workflowId: this.workflowData.id,
                });
                pushInstance.send('nodeExecuteBefore', { executionId, nodeName }, pushRef);
            },
        ],
        nodeExecuteAfter: [
            async function (nodeName, data) {
                const { pushRef, executionId } = this;
                if (pushRef === undefined) {
                    return;
                }
                logger.debug(`Executing hook on node "${nodeName}" (hookFunctionsPush)`, {
                    executionId,
                    pushRef,
                    workflowId: this.workflowData.id,
                });
                pushInstance.send('nodeExecuteAfter', { executionId, nodeName, data }, pushRef);
            },
        ],
        workflowExecuteBefore: [
            async function () {
                const { pushRef, executionId } = this;
                const { id: workflowId, name: workflowName } = this.workflowData;
                logger.debug('Executing hook (hookFunctionsPush)', {
                    executionId,
                    pushRef,
                    workflowId,
                });
                if (pushRef === undefined) {
                    return;
                }
                pushInstance.send('executionStarted', {
                    executionId,
                    mode: this.mode,
                    startedAt: new Date(),
                    retryOf: this.retryOf,
                    workflowId,
                    pushRef,
                    workflowName,
                }, pushRef);
            },
        ],
        workflowExecuteAfter: [
            async function (fullRunData) {
                const { pushRef, executionId, retryOf } = this;
                const { id: workflowId } = this.workflowData;
                logger.debug('Executing hook (hookFunctionsPush)', {
                    executionId,
                    pushRef,
                    workflowId,
                });
                if (pushRef === undefined) {
                    return;
                }
                let pushRunData;
                if (fullRunData.mode === 'manual') {
                    pushRunData = fullRunData;
                }
                else {
                    pushRunData = {
                        ...fullRunData,
                        data: {
                            ...fullRunData.data,
                            resultData: {
                                ...fullRunData.data.resultData,
                                runData: {},
                            },
                        },
                    };
                }
                logger.debug(`Save execution progress to database for execution ID ${executionId} `, {
                    executionId,
                    workflowId,
                });
                const sendData = {
                    executionId,
                    data: pushRunData,
                    retryOf,
                };
                pushInstance.send('executionFinished', sendData, pushRef);
            },
        ],
    };
}
function hookFunctionsPreExecute() {
    const externalHooks = typedi_1.Container.get(ExternalHooks_1.ExternalHooks);
    return {
        workflowExecuteBefore: [
            async function (workflow) {
                await externalHooks.run('workflow.preExecute', [workflow, this.mode]);
            },
        ],
        nodeExecuteAfter: [
            async function (nodeName, data, executionData) {
                await (0, saveExecutionProgress_1.saveExecutionProgress)(this.workflowData, this.executionId, nodeName, data, executionData, this.pushRef);
            },
        ],
    };
}
exports.hookFunctionsPreExecute = hookFunctionsPreExecute;
function hookFunctionsSave() {
    const logger = typedi_1.Container.get(Logger_1.Logger);
    const eventsService = typedi_1.Container.get(events_service_1.EventsService);
    const eventRelay = typedi_1.Container.get(event_relay_service_1.EventRelay);
    return {
        nodeExecuteBefore: [
            async function (nodeName) {
                const { executionId, workflowData: workflow } = this;
                eventRelay.emit('node-pre-execute', { executionId, workflow, nodeName });
            },
        ],
        nodeExecuteAfter: [
            async function (nodeName) {
                const { executionId, workflowData: workflow } = this;
                eventRelay.emit('node-post-execute', { executionId, workflow, nodeName });
            },
        ],
        workflowExecuteBefore: [],
        workflowExecuteAfter: [
            async function (fullRunData, newStaticData) {
                logger.debug('Executing hook (hookFunctionsSave)', {
                    executionId: this.executionId,
                    workflowId: this.workflowData.id,
                });
                await (0, restoreBinaryDataId_1.restoreBinaryDataId)(fullRunData, this.executionId, this.mode);
                const isManualMode = this.mode === 'manual';
                try {
                    if (!isManualMode && (0, utils_1.isWorkflowIdValid)(this.workflowData.id) && newStaticData) {
                        try {
                            await typedi_1.Container.get(workflowStaticData_service_1.WorkflowStaticDataService).saveStaticDataById(this.workflowData.id, newStaticData);
                        }
                        catch (e) {
                            n8n_workflow_1.ErrorReporterProxy.error(e);
                            logger.error(`There was a problem saving the workflow with id "${this.workflowData.id}" to save changed staticData: "${e.message}" (hookFunctionsSave)`, { executionId: this.executionId, workflowId: this.workflowData.id });
                        }
                    }
                    const saveSettings = (0, toSaveSettings_1.toSaveSettings)(this.workflowData.settings);
                    if (isManualMode && !saveSettings.manual && !fullRunData.waitTill) {
                        await typedi_1.Container.get(execution_repository_1.ExecutionRepository).softDelete(this.executionId);
                        return;
                    }
                    const executionStatus = (0, sharedHookFunctions_1.determineFinalExecutionStatus)(fullRunData);
                    const shouldNotSave = (executionStatus === 'success' && !saveSettings.success) ||
                        (executionStatus !== 'success' && !saveSettings.error);
                    if (shouldNotSave) {
                        if (!fullRunData.waitTill && !isManualMode) {
                            executeErrorWorkflow(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                            await typedi_1.Container.get(execution_repository_1.ExecutionRepository).hardDelete({
                                workflowId: this.workflowData.id,
                                executionId: this.executionId,
                            });
                            return;
                        }
                    }
                    const fullExecutionData = (0, sharedHookFunctions_1.prepareExecutionDataForDbUpdate)({
                        runData: fullRunData,
                        workflowData: this.workflowData,
                        workflowStatusFinal: executionStatus,
                        retryOf: this.retryOf,
                    });
                    await (0, sharedHookFunctions_1.updateExistingExecution)({
                        executionId: this.executionId,
                        workflowId: this.workflowData.id,
                        executionData: fullExecutionData,
                    });
                    if (!isManualMode) {
                        executeErrorWorkflow(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                    }
                }
                catch (error) {
                    n8n_workflow_1.ErrorReporterProxy.error(error);
                    logger.error(`Failed saving execution data to DB on execution ID ${this.executionId}`, {
                        executionId: this.executionId,
                        workflowId: this.workflowData.id,
                        error,
                    });
                    if (!isManualMode) {
                        executeErrorWorkflow(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                    }
                }
                finally {
                    eventsService.emit('workflowExecutionCompleted', this.workflowData, fullRunData);
                }
            },
        ],
        nodeFetchedData: [
            async (workflowId, node) => {
                eventsService.emit('nodeFetchedData', workflowId, node);
            },
        ],
    };
}
function hookFunctionsSaveWorker() {
    const logger = typedi_1.Container.get(Logger_1.Logger);
    const internalHooks = typedi_1.Container.get(InternalHooks_1.InternalHooks);
    const eventsService = typedi_1.Container.get(events_service_1.EventsService);
    const eventRelay = typedi_1.Container.get(event_relay_service_1.EventRelay);
    return {
        nodeExecuteBefore: [
            async function (nodeName) {
                const { executionId, workflowData: workflow } = this;
                eventRelay.emit('node-pre-execute', { executionId, workflow, nodeName });
            },
        ],
        nodeExecuteAfter: [
            async function (nodeName) {
                const { executionId, workflowData: workflow } = this;
                eventRelay.emit('node-post-execute', { executionId, workflow, nodeName });
            },
        ],
        workflowExecuteBefore: [
            async function () {
                const { executionId, workflowData } = this;
                eventRelay.emit('workflow-pre-execute', { executionId, data: workflowData });
            },
        ],
        workflowExecuteAfter: [
            async function (fullRunData, newStaticData) {
                logger.debug('Executing hook (hookFunctionsSaveWorker)', {
                    executionId: this.executionId,
                    workflowId: this.workflowData.id,
                });
                try {
                    if ((0, utils_1.isWorkflowIdValid)(this.workflowData.id) && newStaticData) {
                        try {
                            await typedi_1.Container.get(workflowStaticData_service_1.WorkflowStaticDataService).saveStaticDataById(this.workflowData.id, newStaticData);
                        }
                        catch (e) {
                            n8n_workflow_1.ErrorReporterProxy.error(e);
                            logger.error(`There was a problem saving the workflow with id "${this.workflowData.id}" to save changed staticData: "${e.message}" (workflowExecuteAfter)`, { pushRef: this.pushRef, workflowId: this.workflowData.id });
                        }
                    }
                    const workflowStatusFinal = (0, sharedHookFunctions_1.determineFinalExecutionStatus)(fullRunData);
                    if (workflowStatusFinal !== 'success' && workflowStatusFinal !== 'waiting') {
                        executeErrorWorkflow(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                    }
                    const fullExecutionData = (0, sharedHookFunctions_1.prepareExecutionDataForDbUpdate)({
                        runData: fullRunData,
                        workflowData: this.workflowData,
                        workflowStatusFinal,
                        retryOf: this.retryOf,
                    });
                    await (0, sharedHookFunctions_1.updateExistingExecution)({
                        executionId: this.executionId,
                        workflowId: this.workflowData.id,
                        executionData: fullExecutionData,
                    });
                }
                catch (error) {
                    executeErrorWorkflow(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                }
                finally {
                    eventsService.emit('workflowExecutionCompleted', this.workflowData, fullRunData);
                }
            },
            async function (runData) {
                const { executionId, workflowData: workflow } = this;
                void internalHooks.onWorkflowPostExecute(executionId, workflow, runData);
                eventRelay.emit('workflow-post-execute', {
                    workflowId: workflow.id,
                    workflowName: workflow.name,
                    executionId,
                    success: runData.status === 'success',
                    isManual: runData.mode === 'manual',
                });
            },
            async function (fullRunData) {
                const externalHooks = typedi_1.Container.get(ExternalHooks_1.ExternalHooks);
                if (externalHooks.exists('workflow.postExecute')) {
                    try {
                        await externalHooks.run('workflow.postExecute', [
                            fullRunData,
                            this.workflowData,
                            this.executionId,
                        ]);
                    }
                    catch (error) {
                        n8n_workflow_1.ErrorReporterProxy.error(error);
                        typedi_1.Container.get(Logger_1.Logger).error('There was a problem running hook "workflow.postExecute"', error);
                    }
                }
            },
        ],
        nodeFetchedData: [
            async (workflowId, node) => {
                eventsService.emit('nodeFetchedData', workflowId, node);
            },
        ],
    };
}
async function getRunData(workflowData, inputData) {
    const mode = 'integrated';
    const startingNode = (0, utils_1.findSubworkflowStart)(workflowData.nodes);
    inputData = inputData || [
        {
            json: {},
        },
    ];
    const nodeExecutionStack = [];
    nodeExecutionStack.push({
        node: startingNode,
        data: {
            main: [inputData],
        },
        source: null,
    });
    const runExecutionData = {
        startData: {},
        resultData: {
            runData: {},
        },
        executionData: {
            contextData: {},
            metadata: {},
            nodeExecutionStack,
            waitingExecution: {},
            waitingExecutionSource: {},
        },
    };
    const runData = {
        executionMode: mode,
        executionData: runExecutionData,
        workflowData,
    };
    return runData;
}
exports.getRunData = getRunData;
async function getWorkflowData(workflowInfo, parentWorkflowId, parentWorkflowSettings) {
    var _a;
    if (workflowInfo.id === undefined && workflowInfo.code === undefined) {
        throw new n8n_workflow_1.ApplicationError('No information about the workflow to execute found. Please provide either the "id" or "code"!');
    }
    let workflowData;
    if (workflowInfo.id !== undefined) {
        const relations = config_1.default.getEnv('workflowTagsDisabled') ? [] : ['tags'];
        workflowData = await typedi_1.Container.get(workflow_repository_1.WorkflowRepository).get({ id: workflowInfo.id }, { relations });
        if (workflowData === undefined || workflowData === null) {
            throw new n8n_workflow_1.ApplicationError('Workflow does not exist.', {
                extra: { workflowId: workflowInfo.id },
            });
        }
    }
    else {
        workflowData = (_a = workflowInfo.code) !== null && _a !== void 0 ? _a : null;
        if (workflowData) {
            if (!workflowData.id) {
                workflowData.id = parentWorkflowId;
            }
            if (!workflowData.settings) {
                workflowData.settings = parentWorkflowSettings;
            }
        }
    }
    return workflowData;
}
exports.getWorkflowData = getWorkflowData;
async function executeWorkflow(workflowInfo, additionalData, options) {
    var _a, _b, _c;
    const internalHooks = typedi_1.Container.get(InternalHooks_1.InternalHooks);
    const externalHooks = typedi_1.Container.get(ExternalHooks_1.ExternalHooks);
    await externalHooks.init();
    const nodeTypes = typedi_1.Container.get(NodeTypes_1.NodeTypes);
    const activeExecutions = typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions);
    const eventRelay = typedi_1.Container.get(event_relay_service_1.EventRelay);
    const workflowData = (_a = options.loadedWorkflowData) !== null && _a !== void 0 ? _a : (await getWorkflowData(workflowInfo, options.parentWorkflowId, options.parentWorkflowSettings));
    const workflowName = workflowData ? workflowData.name : undefined;
    const workflow = new n8n_workflow_1.Workflow({
        id: workflowData.id,
        name: workflowName,
        nodes: workflowData.nodes,
        connections: workflowData.connections,
        active: workflowData.active,
        nodeTypes,
        staticData: workflowData.staticData,
        settings: workflowData.settings,
    });
    const runData = (_b = options.loadedRunData) !== null && _b !== void 0 ? _b : (await getRunData(workflowData, options.inputData));
    let executionId;
    if (options.parentExecutionId !== undefined) {
        executionId = options.parentExecutionId;
    }
    else {
        executionId = (_c = options.parentExecutionId) !== null && _c !== void 0 ? _c : (await activeExecutions.add(runData));
    }
    typedi_1.Container.get(event_relay_service_1.EventRelay).emit('workflow-pre-execute', { executionId, data: runData });
    let data;
    try {
        await typedi_1.Container.get(PermissionChecker_1.PermissionChecker).check(workflowData.id, workflowData.nodes);
        await typedi_1.Container.get(PermissionChecker_1.PermissionChecker).checkSubworkflowExecutePolicy(workflow, options.parentWorkflowId, options.node);
        const additionalDataIntegrated = await getBase();
        additionalDataIntegrated.hooks = getWorkflowHooksIntegrated(runData.executionMode, executionId, workflowData);
        additionalDataIntegrated.executionId = executionId;
        additionalDataIntegrated.parentCallbackManager = options.parentCallbackManager;
        additionalDataIntegrated.executeWorkflow = additionalData.executeWorkflow;
        let subworkflowTimeout = additionalData.executionTimeoutTimestamp;
        const workflowSettings = workflowData.settings;
        if ((workflowSettings === null || workflowSettings === void 0 ? void 0 : workflowSettings.executionTimeout) !== undefined && workflowSettings.executionTimeout > 0) {
            subworkflowTimeout = Math.min(additionalData.executionTimeoutTimestamp || Number.MAX_SAFE_INTEGER, Date.now() + workflowSettings.executionTimeout * 1000);
        }
        additionalDataIntegrated.executionTimeoutTimestamp = subworkflowTimeout;
        const runExecutionData = runData.executionData;
        const workflowExecute = new n8n_core_1.WorkflowExecute(additionalDataIntegrated, runData.executionMode, runExecutionData);
        if (options.parentExecutionId !== undefined) {
            return {
                startedAt: new Date(),
                workflow,
                workflowExecute,
            };
        }
        const execution = workflowExecute.processRunExecutionData(workflow);
        activeExecutions.attachWorkflowExecution(executionId, execution);
        data = await execution;
    }
    catch (error) {
        const executionError = error ? error : undefined;
        const fullRunData = {
            data: {
                resultData: {
                    error: executionError,
                    runData: {},
                },
            },
            finished: false,
            mode: 'integrated',
            startedAt: new Date(),
            stoppedAt: new Date(),
            status: 'error',
        };
        const fullExecutionData = {
            data: fullRunData.data,
            mode: fullRunData.mode,
            finished: fullRunData.finished ? fullRunData.finished : false,
            startedAt: fullRunData.startedAt,
            stoppedAt: fullRunData.stoppedAt,
            status: fullRunData.status,
            workflowData,
            workflowId: workflowData.id,
        };
        if (workflowData.id) {
            fullExecutionData.workflowId = workflowData.id;
        }
        activeExecutions.remove(executionId, fullRunData);
        await typedi_1.Container.get(execution_repository_1.ExecutionRepository).updateExistingExecution(executionId, fullExecutionData);
        throw objectToError({
            ...executionError,
            stack: executionError === null || executionError === void 0 ? void 0 : executionError.stack,
            message: executionError === null || executionError === void 0 ? void 0 : executionError.message,
        }, workflow);
    }
    await externalHooks.run('workflow.postExecute', [data, workflowData, executionId]);
    void internalHooks.onWorkflowPostExecute(executionId, workflowData, data, additionalData.userId);
    eventRelay.emit('workflow-post-execute', {
        workflowId: workflowData.id,
        workflowName: workflowData.name,
        executionId,
        success: data.status === 'success',
        isManual: data.mode === 'manual',
        userId: additionalData.userId,
    });
    if (data.finished === true || data.status === 'waiting') {
        activeExecutions.remove(executionId, data);
        const returnData = WorkflowHelpers.getDataLastExecutedNodeData(data);
        return returnData.data.main;
    }
    activeExecutions.remove(executionId, data);
    const { error } = data.data.resultData;
    throw objectToError({
        ...error,
        stack: error === null || error === void 0 ? void 0 : error.stack,
    }, workflow);
}
function setExecutionStatus(status) {
    const logger = typedi_1.Container.get(Logger_1.Logger);
    if (this.executionId === undefined) {
        logger.debug(`Setting execution status "${status}" failed because executionId is undefined`);
        return;
    }
    logger.debug(`Setting execution status for ${this.executionId} to "${status}"`);
    typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions).setStatus(this.executionId, status);
}
exports.setExecutionStatus = setExecutionStatus;
function sendDataToUI(type, data) {
    const { pushRef } = this;
    if (pushRef === undefined) {
        return;
    }
    try {
        const pushInstance = typedi_1.Container.get(push_1.Push);
        pushInstance.send(type, data, pushRef);
    }
    catch (error) {
        const logger = typedi_1.Container.get(Logger_1.Logger);
        logger.warn(`There was a problem sending message to UI: ${error.message}`);
    }
}
exports.sendDataToUI = sendDataToUI;
async function getBase(userId, currentNodeParameters, executionTimeoutTimestamp) {
    const urlBaseWebhook = typedi_1.Container.get(url_service_1.UrlService).getWebhookBaseUrl();
    const formWaitingBaseUrl = urlBaseWebhook + config_1.default.getEnv('endpoints.formWaiting');
    const webhookBaseUrl = urlBaseWebhook + config_1.default.getEnv('endpoints.webhook');
    const webhookTestBaseUrl = urlBaseWebhook + config_1.default.getEnv('endpoints.webhookTest');
    const webhookWaitingBaseUrl = urlBaseWebhook + config_1.default.getEnv('endpoints.webhookWaiting');
    const variables = await WorkflowHelpers.getVariables();
    return {
        credentialsHelper: typedi_1.Container.get(CredentialsHelper_1.CredentialsHelper),
        executeWorkflow,
        restApiUrl: urlBaseWebhook + config_1.default.getEnv('endpoints.rest'),
        instanceBaseUrl: urlBaseWebhook,
        formWaitingBaseUrl,
        webhookBaseUrl,
        webhookWaitingBaseUrl,
        webhookTestBaseUrl,
        currentNodeParameters,
        executionTimeoutTimestamp,
        userId,
        setExecutionStatus,
        variables,
        secretsHelpers: typedi_1.Container.get(SecretsHelpers_1.SecretsHelper),
        logAiEvent: async (eventName, payload) => {
            return await typedi_1.Container.get(MessageEventBus_1.MessageEventBus).sendAiNodeEvent({
                eventName,
                payload,
            });
        },
    };
}
exports.getBase = getBase;
function getWorkflowHooksIntegrated(mode, executionId, workflowData) {
    const hookFunctions = hookFunctionsSave();
    const preExecuteFunctions = hookFunctionsPreExecute();
    for (const key of Object.keys(preExecuteFunctions)) {
        if (hookFunctions[key] === undefined) {
            hookFunctions[key] = [];
        }
        hookFunctions[key].push.apply(hookFunctions[key], preExecuteFunctions[key]);
    }
    return new n8n_workflow_1.WorkflowHooks(hookFunctions, mode, executionId, workflowData);
}
function getWorkflowHooksWorkerExecuter(mode, executionId, workflowData, optionalParameters) {
    optionalParameters = optionalParameters || {};
    const hookFunctions = hookFunctionsSaveWorker();
    const preExecuteFunctions = hookFunctionsPreExecute();
    for (const key of Object.keys(preExecuteFunctions)) {
        if (hookFunctions[key] === undefined) {
            hookFunctions[key] = [];
        }
        hookFunctions[key].push.apply(hookFunctions[key], preExecuteFunctions[key]);
    }
    return new n8n_workflow_1.WorkflowHooks(hookFunctions, mode, executionId, workflowData, optionalParameters);
}
exports.getWorkflowHooksWorkerExecuter = getWorkflowHooksWorkerExecuter;
function getWorkflowHooksWorkerMain(mode, executionId, workflowData, optionalParameters) {
    optionalParameters = optionalParameters || {};
    const hookFunctions = hookFunctionsPreExecute();
    hookFunctions.nodeExecuteBefore = [];
    hookFunctions.nodeExecuteAfter = [];
    hookFunctions.workflowExecuteAfter = [
        async function (fullRunData) {
            const executionStatus = (0, sharedHookFunctions_1.determineFinalExecutionStatus)(fullRunData);
            const saveSettings = (0, toSaveSettings_1.toSaveSettings)(this.workflowData.settings);
            const shouldNotSave = (executionStatus === 'success' && !saveSettings.success) ||
                (executionStatus !== 'success' && !saveSettings.error);
            if (shouldNotSave) {
                await typedi_1.Container.get(execution_repository_1.ExecutionRepository).hardDelete({
                    workflowId: this.workflowData.id,
                    executionId: this.executionId,
                });
            }
        },
    ];
    return new n8n_workflow_1.WorkflowHooks(hookFunctions, mode, executionId, workflowData, optionalParameters);
}
exports.getWorkflowHooksWorkerMain = getWorkflowHooksWorkerMain;
function getWorkflowHooksMain(data, executionId) {
    const hookFunctions = hookFunctionsSave();
    const pushFunctions = hookFunctionsPush();
    for (const key of Object.keys(pushFunctions)) {
        if (hookFunctions[key] === undefined) {
            hookFunctions[key] = [];
        }
        hookFunctions[key].push.apply(hookFunctions[key], pushFunctions[key]);
    }
    const preExecuteFunctions = hookFunctionsPreExecute();
    for (const key of Object.keys(preExecuteFunctions)) {
        if (hookFunctions[key] === undefined) {
            hookFunctions[key] = [];
        }
        hookFunctions[key].push.apply(hookFunctions[key], preExecuteFunctions[key]);
    }
    if (!hookFunctions.nodeExecuteBefore)
        hookFunctions.nodeExecuteBefore = [];
    if (!hookFunctions.nodeExecuteAfter)
        hookFunctions.nodeExecuteAfter = [];
    return new n8n_workflow_1.WorkflowHooks(hookFunctions, data.executionMode, executionId, data.workflowData, {
        pushRef: data.pushRef,
        retryOf: data.retryOf,
    });
}
exports.getWorkflowHooksMain = getWorkflowHooksMain;
//# sourceMappingURL=WorkflowExecuteAdditionalData.js.map