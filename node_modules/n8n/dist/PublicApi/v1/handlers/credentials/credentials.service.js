"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toJsonSchema = exports.sanitizeCredentials = exports.encryptCredential = exports.removeCredential = exports.saveCredential = exports.createCredential = exports.getSharedCredentials = exports.getCredentials = void 0;
const n8n_core_1 = require("n8n-core");
const Db = __importStar(require("../../../../Db"));
const CredentialsEntity_1 = require("../../../../databases/entities/CredentialsEntity");
const SharedCredentials_1 = require("../../../../databases/entities/SharedCredentials");
const ExternalHooks_1 = require("../../../../ExternalHooks");
const typedi_1 = require("typedi");
const credentials_repository_1 = require("../../../../databases/repositories/credentials.repository");
const sharedCredentials_repository_1 = require("../../../../databases/repositories/sharedCredentials.repository");
const project_repository_1 = require("../../../../databases/repositories/project.repository");
const InternalHooks_1 = require("../../../../InternalHooks");
const event_relay_service_1 = require("../../../../eventbus/event-relay.service");
async function getCredentials(credentialId) {
    return await typedi_1.Container.get(credentials_repository_1.CredentialsRepository).findOneBy({ id: credentialId });
}
exports.getCredentials = getCredentials;
async function getSharedCredentials(userId, credentialId) {
    return await typedi_1.Container.get(sharedCredentials_repository_1.SharedCredentialsRepository).findOne({
        where: {
            project: { projectRelations: { userId } },
            credentialsId: credentialId,
        },
        relations: ['credentials'],
    });
}
exports.getSharedCredentials = getSharedCredentials;
async function createCredential(properties) {
    const newCredential = new CredentialsEntity_1.CredentialsEntity();
    Object.assign(newCredential, properties);
    return newCredential;
}
exports.createCredential = createCredential;
async function saveCredential(credential, user, encryptedData) {
    await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('credentials.create', [encryptedData]);
    void typedi_1.Container.get(InternalHooks_1.InternalHooks).onUserCreatedCredentials({
        user,
        credential_name: credential.name,
        credential_type: credential.type,
        credential_id: credential.id,
        public_api: true,
    });
    typedi_1.Container.get(event_relay_service_1.EventRelay).emit('credentials-created', {
        user,
        credentialName: credential.name,
        credentialType: credential.type,
        credentialId: credential.id,
    });
    return await Db.transaction(async (transactionManager) => {
        const savedCredential = await transactionManager.save(credential);
        savedCredential.data = credential.data;
        const newSharedCredential = new SharedCredentials_1.SharedCredentials();
        const personalProject = await typedi_1.Container.get(project_repository_1.ProjectRepository).getPersonalProjectForUserOrFail(user.id, transactionManager);
        Object.assign(newSharedCredential, {
            role: 'credential:owner',
            credentials: savedCredential,
            projectId: personalProject.id,
        });
        await transactionManager.save(newSharedCredential);
        return savedCredential;
    });
}
exports.saveCredential = saveCredential;
async function removeCredential(user, credentials) {
    await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('credentials.delete', [credentials.id]);
    void typedi_1.Container.get(InternalHooks_1.InternalHooks).onUserDeletedCredentials({
        user,
        credential_name: credentials.name,
        credential_type: credentials.type,
        credential_id: credentials.id,
    });
    typedi_1.Container.get(event_relay_service_1.EventRelay).emit('credentials-deleted', {
        user,
        credentialName: credentials.name,
        credentialType: credentials.type,
        credentialId: credentials.id,
    });
    return await typedi_1.Container.get(credentials_repository_1.CredentialsRepository).remove(credentials);
}
exports.removeCredential = removeCredential;
async function encryptCredential(credential) {
    const coreCredential = new n8n_core_1.Credentials({ id: null, name: credential.name }, credential.type);
    coreCredential.setData(credential.data);
    return coreCredential.getDataToSave();
}
exports.encryptCredential = encryptCredential;
function sanitizeCredentials(credentials) {
    const argIsArray = Array.isArray(credentials);
    const credentialsList = argIsArray ? credentials : [credentials];
    const sanitizedCredentials = credentialsList.map((credential) => {
        const { data, shared, ...rest } = credential;
        return rest;
    });
    return argIsArray ? sanitizedCredentials : sanitizedCredentials[0];
}
exports.sanitizeCredentials = sanitizeCredentials;
function toJsonSchema(properties) {
    const jsonSchema = {
        additionalProperties: false,
        type: 'object',
        properties: {},
        allOf: [],
        required: [],
    };
    const optionsValues = {};
    const resolveProperties = [];
    properties
        .filter((property) => property.type === 'options')
        .forEach((property) => {
        var _a;
        Object.assign(optionsValues, {
            [property.name]: (_a = property.options) === null || _a === void 0 ? void 0 : _a.map((option) => option.value),
        });
    });
    let requiredFields = [];
    const propertyRequiredDependencies = {};
    properties.forEach((property) => {
        var _a, _b, _c, _d, _e;
        if (property.required) {
            requiredFields.push(property.name);
        }
        if (property.type === 'options') {
            Object.assign(jsonSchema.properties, {
                [property.name]: {
                    type: 'string',
                    enum: (_a = property.options) === null || _a === void 0 ? void 0 : _a.map((data) => data.value),
                },
            });
        }
        else {
            Object.assign(jsonSchema.properties, {
                [property.name]: {
                    type: property.type,
                },
            });
        }
        if ((_b = property.displayOptions) === null || _b === void 0 ? void 0 : _b.show) {
            const dependantName = Object.keys((_c = property.displayOptions) === null || _c === void 0 ? void 0 : _c.show)[0] || '';
            const displayOptionsValues = property.displayOptions.show[dependantName];
            let dependantValue = '';
            if (displayOptionsValues && Array.isArray(displayOptionsValues) && displayOptionsValues[0]) {
                dependantValue = displayOptionsValues[0];
            }
            if (propertyRequiredDependencies[dependantName] === undefined) {
                propertyRequiredDependencies[dependantName] = {};
            }
            if (!resolveProperties.includes(dependantName)) {
                let conditionalValue;
                if (typeof dependantValue === 'object' && dependantValue._cnd) {
                    const [key, targetValue] = Object.entries(dependantValue._cnd)[0];
                    if (key === 'eq') {
                        conditionalValue = {
                            const: [targetValue],
                        };
                    }
                    else if (key === 'not') {
                        conditionalValue = {
                            not: {
                                const: [targetValue],
                            },
                        };
                    }
                    else if (key === 'gt') {
                        conditionalValue = {
                            type: 'number',
                            exclusiveMinimum: [targetValue],
                        };
                    }
                    else if (key === 'gte') {
                        conditionalValue = {
                            type: 'number',
                            minimum: [targetValue],
                        };
                    }
                    else if (key === 'lt') {
                        conditionalValue = {
                            type: 'number',
                            exclusiveMaximum: [targetValue],
                        };
                    }
                    else if (key === 'lte') {
                        conditionalValue = {
                            type: 'number',
                            maximum: [targetValue],
                        };
                    }
                    else if (key === 'startsWith') {
                        conditionalValue = {
                            type: 'string',
                            pattern: `^${targetValue}`,
                        };
                    }
                    else if (key === 'endsWith') {
                        conditionalValue = {
                            type: 'string',
                            pattern: `${targetValue}$`,
                        };
                    }
                    else if (key === 'includes') {
                        conditionalValue = {
                            type: 'string',
                            pattern: `${targetValue}`,
                        };
                    }
                    else if (key === 'regex') {
                        conditionalValue = {
                            type: 'string',
                            pattern: `${targetValue}`,
                        };
                    }
                    else {
                        conditionalValue = {
                            enum: [dependantValue],
                        };
                    }
                }
                else {
                    conditionalValue = {
                        enum: [dependantValue],
                    };
                }
                propertyRequiredDependencies[dependantName] = {
                    if: {
                        properties: {
                            [dependantName]: conditionalValue,
                        },
                    },
                    then: {
                        allOf: [],
                    },
                    else: {
                        allOf: [],
                    },
                };
            }
            (_d = propertyRequiredDependencies[dependantName].then) === null || _d === void 0 ? void 0 : _d.allOf.push({ required: [property.name] });
            (_e = propertyRequiredDependencies[dependantName].else) === null || _e === void 0 ? void 0 : _e.allOf.push({
                not: { required: [property.name] },
            });
            resolveProperties.push(dependantName);
            requiredFields = requiredFields.filter((field) => field !== property.name);
        }
    });
    Object.assign(jsonSchema, { required: requiredFields });
    jsonSchema.allOf = Object.values(propertyRequiredDependencies);
    if (!jsonSchema.allOf.length) {
        delete jsonSchema.allOf;
    }
    return jsonSchema;
}
exports.toJsonSchema = toJsonSchema;
//# sourceMappingURL=credentials.service.js.map