"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Webhook = void 0;
const typedi_1 = require("typedi");
const core_1 = require("@oclif/core");
const n8n_workflow_1 = require("n8n-workflow");
const config_1 = __importDefault(require("../config"));
const ActiveExecutions_1 = require("../ActiveExecutions");
const WebhookServer_1 = require("../WebhookServer");
const Queue_1 = require("../Queue");
const BaseCommand_1 = require("./BaseCommand");
const orchestration_webhook_service_1 = require("../services/orchestration/webhook/orchestration.webhook.service");
const orchestration_handler_webhook_service_1 = require("../services/orchestration/webhook/orchestration.handler.webhook.service");
class Webhook extends BaseCommand_1.BaseCommand {
    constructor(argv, cmdConfig) {
        super(argv, cmdConfig);
        this.server = typedi_1.Container.get(WebhookServer_1.WebhookServer);
        this.setInstanceType('webhook');
        if (this.queueModeId) {
            this.logger.debug(`Webhook Instance queue mode id: ${this.queueModeId}`);
        }
        this.setInstanceQueueModeId();
    }
    async stopProcess() {
        var _a;
        this.logger.info('\nStopping n8n...');
        try {
            await ((_a = this.externalHooks) === null || _a === void 0 ? void 0 : _a.run('n8n.stop', []));
            await typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions).shutdown();
        }
        catch (error) {
            await this.exitWithCrash('There was an error shutting down n8n.', error);
        }
        await this.exitSuccessFully();
    }
    async init() {
        if (config_1.default.getEnv('executions.mode') !== 'queue') {
            this.error('Webhook processes can only run with execution mode as queue.');
        }
        await this.initCrashJournal();
        this.logger.debug('Crash journal initialized');
        this.logger.info('Initializing n8n webhook process');
        this.logger.debug(`Queue mode id: ${this.queueModeId}`);
        await super.init();
        await this.initLicense();
        this.logger.debug('License init complete');
        await this.initOrchestration();
        this.logger.debug('Orchestration init complete');
        await this.initBinaryDataService();
        this.logger.debug('Binary data service init complete');
        await this.initExternalHooks();
        this.logger.debug('External hooks init complete');
        await this.initExternalSecrets();
        this.logger.debug('External seecrets init complete');
    }
    async run() {
        if (config_1.default.getEnv('multiMainSetup.enabled')) {
            throw new n8n_workflow_1.ApplicationError('Webhook process cannot be started when multi-main setup is enabled.');
        }
        await typedi_1.Container.get(Queue_1.Queue).init();
        await this.server.start();
        this.logger.debug(`Webhook listener ID: ${this.server.uniqueInstanceId}`);
        this.logger.info('Webhook listener waiting for requests.');
        await new Promise(() => { });
    }
    async catch(error) {
        await this.exitWithCrash('Exiting due to an error.', error);
    }
    async initOrchestration() {
        await typedi_1.Container.get(orchestration_webhook_service_1.OrchestrationWebhookService).init();
        await typedi_1.Container.get(orchestration_handler_webhook_service_1.OrchestrationHandlerWebhookService).init();
    }
}
exports.Webhook = Webhook;
Webhook.description = 'Starts n8n webhook process. Intercepts only production URLs.';
Webhook.examples = ['$ n8n webhook'];
Webhook.flags = {
    help: core_1.Flags.help({ char: 'h' }),
};
//# sourceMappingURL=webhook.js.map