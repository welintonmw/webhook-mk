"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseCommand = void 0;
require("reflect-metadata");
const typedi_1 = require("typedi");
const core_1 = require("@oclif/core");
const errors_1 = require("@oclif/core/lib/errors");
const n8n_workflow_1 = require("n8n-workflow");
const n8n_core_1 = require("n8n-core");
const Logger_1 = require("../Logger");
const config_1 = __importDefault(require("../config"));
const Db = __importStar(require("../Db"));
const CrashJournal = __importStar(require("../CrashJournal"));
const constants_1 = require("../constants");
const ErrorReporting_1 = require("../ErrorReporting");
const ExternalHooks_1 = require("../ExternalHooks");
const NodeTypes_1 = require("../NodeTypes");
const LoadNodesAndCredentials_1 = require("../LoadNodesAndCredentials");
const InternalHooks_1 = require("../InternalHooks");
const posthog_1 = require("../posthog");
const License_1 = require("../License");
const ExternalSecretsManager_ee_1 = require("../ExternalSecrets/ExternalSecretsManager.ee");
const ExpressionEvaluator_1 = require("../ExpressionEvaluator");
const generators_1 = require("../databases/utils/generators");
const workflowHistoryManager_ee_1 = require("../workflows/workflowHistory/workflowHistoryManager.ee");
const Shutdown_service_1 = require("../shutdown/Shutdown.service");
class BaseCommand extends core_1.Command {
    constructor() {
        super(...arguments);
        this.logger = typedi_1.Container.get(Logger_1.Logger);
        this.instanceType = 'main';
        this.shutdownService = typedi_1.Container.get(Shutdown_service_1.ShutdownService);
        this.gracefulShutdownTimeoutInS = config_1.default.getEnv('generic.gracefulShutdownTimeout');
    }
    async init() {
        var _a, _b, _c;
        await (0, ErrorReporting_1.initErrorHandling)();
        (0, ExpressionEvaluator_1.initExpressionEvaluator)();
        process.once('SIGTERM', this.onTerminationSignal('SIGTERM'));
        process.once('SIGINT', this.onTerminationSignal('SIGINT'));
        this.instanceSettings = typedi_1.Container.get(n8n_core_1.InstanceSettings);
        this.nodeTypes = typedi_1.Container.get(NodeTypes_1.NodeTypes);
        await typedi_1.Container.get(LoadNodesAndCredentials_1.LoadNodesAndCredentials).init();
        await Db.init().catch(async (error) => await this.exitWithCrash('There was an error initializing DB', error));
        if (constants_1.inDevelopment || constants_1.inTest) {
            this.shutdownService.validate();
        }
        await ((_a = this.server) === null || _a === void 0 ? void 0 : _a.init());
        await Db.migrate().catch(async (error) => await this.exitWithCrash('There was an error running database migrations', error));
        const dbType = config_1.default.getEnv('database.type');
        if (['mysqldb', 'mariadb'].includes(dbType)) {
            this.logger.warn('Support for MySQL/MariaDB has been deprecated and will be removed with an upcoming version of n8n. Please migrate to PostgreSQL.');
        }
        if (process.env.N8N_SKIP_WEBHOOK_DEREGISTRATION_SHUTDOWN) {
            this.logger.warn('The flag to skip webhook deregistration N8N_SKIP_WEBHOOK_DEREGISTRATION_SHUTDOWN has been removed. n8n no longer deregisters webhooks at startup and shutdown, in main and queue mode.');
        }
        if (config_1.default.getEnv('executions.mode') === 'queue' && dbType === 'sqlite') {
            this.logger.warn('Queue mode is not officially supported with sqlite. Please switch to PostgreSQL.');
        }
        if ((_c = (_b = process.env.N8N_BINARY_DATA_TTL) !== null && _b !== void 0 ? _b : process.env.N8N_PERSISTED_BINARY_DATA_TTL) !== null && _c !== void 0 ? _c : process.env.EXECUTIONS_DATA_PRUNE_TIMEOUT) {
            this.logger.warn('The env vars N8N_BINARY_DATA_TTL and N8N_PERSISTED_BINARY_DATA_TTL and EXECUTIONS_DATA_PRUNE_TIMEOUT no longer have any effect and can be safely removed. Instead of relying on a TTL system for binary data, n8n currently cleans up binary data together with executions during pruning.');
        }
        await typedi_1.Container.get(posthog_1.PostHogClient).init();
        await typedi_1.Container.get(InternalHooks_1.InternalHooks).init();
    }
    setInstanceType(instanceType) {
        this.instanceType = instanceType;
        config_1.default.set('generic.instanceType', instanceType);
    }
    setInstanceQueueModeId() {
        if (config_1.default.get('redis.queueModeId')) {
            this.queueModeId = config_1.default.get('redis.queueModeId');
            return;
        }
        this.queueModeId = (0, generators_1.generateHostInstanceId)(this.instanceType);
        config_1.default.set('redis.queueModeId', this.queueModeId);
    }
    async stopProcess() {
    }
    async initCrashJournal() {
        await CrashJournal.init();
    }
    async exitSuccessFully() {
        try {
            await Promise.all([CrashJournal.cleanup(), Db.close()]);
        }
        finally {
            process.exit();
        }
    }
    async exitWithCrash(message, error) {
        n8n_workflow_1.ErrorReporterProxy.error(new Error(message, { cause: error }), { level: 'fatal' });
        await (0, n8n_workflow_1.sleep)(2000);
        process.exit(1);
    }
    async initObjectStoreService() {
        const isSelected = config_1.default.getEnv('binaryDataManager.mode') === 's3';
        const isAvailable = config_1.default.getEnv('binaryDataManager.availableModes').includes('s3');
        if (!isSelected && !isAvailable)
            return;
        if (isSelected && !isAvailable) {
            throw new n8n_workflow_1.ApplicationError('External storage selected but unavailable. Please make external storage available by adding "s3" to `N8N_AVAILABLE_BINARY_DATA_MODES`.');
        }
        const isLicensed = typedi_1.Container.get(License_1.License).isFeatureEnabled(constants_1.LICENSE_FEATURES.BINARY_DATA_S3);
        if (isSelected && isAvailable && isLicensed) {
            this.logger.debug('License found for external storage - object store to init in read-write mode');
            await this._initObjectStoreService();
            return;
        }
        if (isSelected && isAvailable && !isLicensed) {
            this.logger.debug('No license found for external storage - object store to init with writes blocked. To enable writes, please upgrade to a license that supports this feature.');
            await this._initObjectStoreService({ isReadOnly: true });
            return;
        }
        if (!isSelected && isAvailable) {
            this.logger.debug('External storage unselected but available - object store to init with writes unused');
            await this._initObjectStoreService();
            return;
        }
    }
    async _initObjectStoreService(options = { isReadOnly: false }) {
        const objectStoreService = typedi_1.Container.get(n8n_core_1.ObjectStoreService);
        const host = config_1.default.getEnv('externalStorage.s3.host');
        if (host === '') {
            throw new n8n_workflow_1.ApplicationError('External storage host not configured. Please set `N8N_EXTERNAL_STORAGE_S3_HOST`.');
        }
        const bucket = {
            name: config_1.default.getEnv('externalStorage.s3.bucket.name'),
            region: config_1.default.getEnv('externalStorage.s3.bucket.region'),
        };
        if (bucket.name === '') {
            throw new n8n_workflow_1.ApplicationError('External storage bucket name not configured. Please set `N8N_EXTERNAL_STORAGE_S3_BUCKET_NAME`.');
        }
        if (bucket.region === '') {
            throw new n8n_workflow_1.ApplicationError('External storage bucket region not configured. Please set `N8N_EXTERNAL_STORAGE_S3_BUCKET_REGION`.');
        }
        const credentials = {
            accessKey: config_1.default.getEnv('externalStorage.s3.credentials.accessKey'),
            accessSecret: config_1.default.getEnv('externalStorage.s3.credentials.accessSecret'),
        };
        if (credentials.accessKey === '') {
            throw new n8n_workflow_1.ApplicationError('External storage access key not configured. Please set `N8N_EXTERNAL_STORAGE_S3_ACCESS_KEY`.');
        }
        if (credentials.accessSecret === '') {
            throw new n8n_workflow_1.ApplicationError('External storage access secret not configured. Please set `N8N_EXTERNAL_STORAGE_S3_ACCESS_SECRET`.');
        }
        this.logger.debug('Initializing object store service');
        try {
            await objectStoreService.init(host, bucket, credentials);
            objectStoreService.setReadonly(options.isReadOnly);
            this.logger.debug('Object store init completed');
        }
        catch (e) {
            const error = e instanceof Error ? e : new Error(`${e}`);
            this.logger.debug('Object store init failed', { error });
        }
    }
    async initBinaryDataService() {
        try {
            await this.initObjectStoreService();
        }
        catch (e) {
            const error = e instanceof Error ? e : new Error(`${e}`);
            this.logger.error(`Failed to init object store: ${error.message}`, { error });
            process.exit(1);
        }
        const binaryDataConfig = config_1.default.getEnv('binaryDataManager');
        await typedi_1.Container.get(n8n_core_1.BinaryDataService).init(binaryDataConfig);
    }
    async initExternalHooks() {
        this.externalHooks = typedi_1.Container.get(ExternalHooks_1.ExternalHooks);
        await this.externalHooks.init();
    }
    async initLicense() {
        var _a;
        this.license = typedi_1.Container.get(License_1.License);
        await this.license.init((_a = this.instanceType) !== null && _a !== void 0 ? _a : 'main');
        const activationKey = config_1.default.getEnv('license.activationKey');
        if (activationKey) {
            const hasCert = (await this.license.loadCertStr()).length > 0;
            if (hasCert) {
                return this.logger.debug('Skipping license activation');
            }
            try {
                this.logger.debug('Attempting license activation');
                await this.license.activate(activationKey);
                this.logger.debug('License init complete');
            }
            catch (e) {
                this.logger.error('Could not activate license', e);
            }
        }
    }
    async initExternalSecrets() {
        const secretsManager = typedi_1.Container.get(ExternalSecretsManager_ee_1.ExternalSecretsManager);
        await secretsManager.init();
    }
    initWorkflowHistory() {
        typedi_1.Container.get(workflowHistoryManager_ee_1.WorkflowHistoryManager).init();
    }
    async finally(error) {
        if (constants_1.inTest || this.id === 'start')
            return;
        if (Db.connectionState.connected) {
            await (0, n8n_workflow_1.sleep)(100);
            await Db.close();
        }
        const exitCode = error instanceof errors_1.ExitError ? error.oclif.exit : error ? 1 : 0;
        this.exit(exitCode);
    }
    onTerminationSignal(signal) {
        return async () => {
            if (this.shutdownService.isShuttingDown()) {
                this.logger.info(`Received ${signal}. Already shutting down...`);
                return;
            }
            const forceShutdownTimer = setTimeout(async () => {
                this.logger.info(`process exited after ${this.gracefulShutdownTimeoutInS}s`);
                const errorMsg = `Shutdown timed out after ${this.gracefulShutdownTimeoutInS} seconds`;
                await this.exitWithCrash(errorMsg, new Error(errorMsg));
            }, this.gracefulShutdownTimeoutInS * 1000);
            this.logger.info(`Received ${signal}. Shutting down...`);
            this.shutdownService.shutdown();
            await Promise.all([this.stopProcess(), this.shutdownService.waitForShutdown()]);
            clearTimeout(forceShutdownTimer);
        };
    }
}
exports.BaseCommand = BaseCommand;
//# sourceMappingURL=BaseCommand.js.map