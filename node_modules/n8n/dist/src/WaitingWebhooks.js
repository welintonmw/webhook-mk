"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WaitingWebhooks = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const _1 = require(".");
class WaitingWebhooks {
    async executeWebhook(httpMethod, fullPath, req, res) {
        var _a;
        n8n_workflow_1.LoggerProxy.debug(`Received waiting-webhoook "${httpMethod}" for path "${fullPath}"`);
        req.params = {};
        if (fullPath.endsWith('/')) {
            fullPath = fullPath.slice(0, -1);
        }
        const pathParts = fullPath.split('/');
        const executionId = pathParts.shift();
        const path = pathParts.join('/');
        const execution = await ((_a = _1.Db.collections.Execution) === null || _a === void 0 ? void 0 : _a.findOne(executionId));
        if (execution === undefined) {
            throw new _1.ResponseHelper.ResponseError(`The execution "${executionId} does not exist.`, 404, 404);
        }
        const fullExecutionData = _1.ResponseHelper.unflattenExecutionData(execution);
        if (fullExecutionData.finished || fullExecutionData.data.resultData.error) {
            throw new _1.ResponseHelper.ResponseError(`The execution "${executionId} has finished already.`, 409, 409);
        }
        return this.startExecution(httpMethod, path, fullExecutionData, req, res);
    }
    async startExecution(httpMethod, path, fullExecutionData, req, res) {
        const executionId = fullExecutionData.id;
        if (fullExecutionData.finished) {
            throw new Error('The execution did succeed and can so not be started again.');
        }
        const lastNodeExecuted = fullExecutionData.data.resultData.lastNodeExecuted;
        fullExecutionData.data.executionData.nodeExecutionStack[0].node.disabled = true;
        fullExecutionData.data.waitTill = undefined;
        fullExecutionData.data.resultData.runData[lastNodeExecuted].pop();
        const { workflowData } = fullExecutionData;
        const nodeTypes = _1.NodeTypes();
        const workflow = new n8n_workflow_1.Workflow({
            id: workflowData.id.toString(),
            name: workflowData.name,
            nodes: workflowData.nodes,
            connections: workflowData.connections,
            active: workflowData.active,
            nodeTypes,
            staticData: workflowData.staticData,
            settings: workflowData.settings,
        });
        const additionalData = await _1.WorkflowExecuteAdditionalData.getBase();
        const webhookData = n8n_workflow_1.NodeHelpers.getNodeWebhooks(workflow, workflow.getNode(lastNodeExecuted), additionalData).filter((webhook) => {
            return (webhook.httpMethod === httpMethod &&
                webhook.path === path &&
                webhook.webhookDescription.restartWebhook === true);
        })[0];
        if (webhookData === undefined) {
            const errorMessage = `The execution "${executionId}" with webhook suffix path "${path}" is not known.`;
            throw new _1.ResponseHelper.ResponseError(errorMessage, 404, 404);
        }
        const workflowStartNode = workflow.getNode(lastNodeExecuted);
        if (workflowStartNode === null) {
            throw new _1.ResponseHelper.ResponseError('Could not find node to process webhook.', 404, 404);
        }
        const runExecutionData = fullExecutionData.data;
        return new Promise((resolve, reject) => {
            const executionMode = 'webhook';
            _1.WebhookHelpers.executeWebhook(workflow, webhookData, workflowData, workflowStartNode, executionMode, undefined, runExecutionData, fullExecutionData.id, req, res, (error, data) => {
                if (error !== null) {
                    return reject(error);
                }
                resolve(data);
            });
        });
    }
}
exports.WaitingWebhooks = WaitingWebhooks;
//# sourceMappingURL=WaitingWebhooks.js.map