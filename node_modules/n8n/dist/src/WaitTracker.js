"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WaitTracker = exports.WaitTrackerClass = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const typeorm_1 = require("typeorm");
const DateUtils_1 = require("typeorm/util/DateUtils");
const _1 = require(".");
class WaitTrackerClass {
    constructor() {
        this.waitingExecutions = {};
        this.activeExecutionsInstance = _1.ActiveExecutions.getInstance();
        this.mainTimer = setInterval(() => {
            this.getwaitingExecutions();
        }, 60000);
        this.getwaitingExecutions();
    }
    async getwaitingExecutions() {
        n8n_workflow_1.LoggerProxy.debug('Wait tracker querying database for waiting executions');
        const findQuery = {
            select: ['id', 'waitTill'],
            where: {
                waitTill: typeorm_1.LessThanOrEqual(new Date(Date.now() + 70000)),
            },
            order: {
                waitTill: 'ASC',
            },
        };
        const dbType = (await _1.GenericHelpers.getConfigValue('database.type'));
        if (dbType === 'sqlite') {
            findQuery.where.waitTill = typeorm_1.LessThanOrEqual(DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(new Date(Date.now() + 70000)));
        }
        const executions = await _1.Db.collections.Execution.find(findQuery);
        if (executions.length === 0) {
            return;
        }
        const executionIds = executions.map((execution) => execution.id.toString()).join(', ');
        n8n_workflow_1.LoggerProxy.debug(`Wait tracker found ${executions.length} executions. Setting timer for IDs: ${executionIds}`);
        for (const execution of executions) {
            const executionId = execution.id.toString();
            if (this.waitingExecutions[executionId] === undefined) {
                const triggerTime = execution.waitTill.getTime() - new Date().getTime();
                this.waitingExecutions[executionId] = {
                    executionId,
                    timer: setTimeout(() => {
                        this.startExecution(executionId);
                    }, triggerTime),
                };
            }
        }
    }
    async stopExecution(executionId) {
        if (this.waitingExecutions[executionId] !== undefined) {
            clearTimeout(this.waitingExecutions[executionId].timer);
            delete this.waitingExecutions[executionId];
        }
        const execution = await _1.Db.collections.Execution.findOne(executionId);
        if (execution === undefined || !execution.waitTill) {
            throw new Error(`The execution ID "${executionId}" could not be found.`);
        }
        const fullExecutionData = _1.ResponseHelper.unflattenExecutionData(execution);
        const error = new n8n_workflow_1.WorkflowOperationError('Workflow-Execution has been canceled!');
        fullExecutionData.data.resultData.error = Object.assign(Object.assign({}, error), { message: error.message, stack: error.stack });
        fullExecutionData.stoppedAt = new Date();
        fullExecutionData.waitTill = undefined;
        await _1.Db.collections.Execution.update(executionId, _1.ResponseHelper.flattenExecutionData(fullExecutionData));
        return {
            mode: fullExecutionData.mode,
            startedAt: new Date(fullExecutionData.startedAt),
            stoppedAt: fullExecutionData.stoppedAt ? new Date(fullExecutionData.stoppedAt) : undefined,
            finished: fullExecutionData.finished,
        };
    }
    startExecution(executionId) {
        n8n_workflow_1.LoggerProxy.debug(`Wait tracker resuming execution ${executionId}`, { executionId });
        delete this.waitingExecutions[executionId];
        (async () => {
            const fullExecutionDataFlatted = await _1.Db.collections.Execution.findOne(executionId);
            if (fullExecutionDataFlatted === undefined) {
                throw new Error(`The execution with the id "${executionId}" does not exist.`);
            }
            const fullExecutionData = _1.ResponseHelper.unflattenExecutionData(fullExecutionDataFlatted);
            if (fullExecutionData.finished) {
                throw new Error('The execution did succeed and can so not be started again.');
            }
            const data = {
                executionMode: fullExecutionData.mode,
                executionData: fullExecutionData.data,
                workflowData: fullExecutionData.workflowData,
            };
            const workflowRunner = new _1.WorkflowRunner();
            await workflowRunner.run(data, false, false, executionId);
        })().catch((error) => {
            n8n_workflow_1.LoggerProxy.error(`There was a problem starting the waiting execution with id "${executionId}": "${error.message}"`, { executionId });
        });
    }
}
exports.WaitTrackerClass = WaitTrackerClass;
let waitTrackerInstance;
function WaitTracker() {
    if (waitTrackerInstance === undefined) {
        waitTrackerInstance = new WaitTrackerClass();
    }
    return waitTrackerInstance;
}
exports.WaitTracker = WaitTracker;
//# sourceMappingURL=WaitTracker.js.map