"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateUniqueName = exports.getConfigValue = exports.getVersions = exports.getSessionId = exports.getBaseUrl = void 0;
const path_1 = require("path");
const promises_1 = require("fs/promises");
const config = require("../config");
const _1 = require(".");
const typeorm_1 = require("typeorm");
let versionCache;
function getBaseUrl() {
    const protocol = config.get('protocol');
    const host = config.get('host');
    const port = config.get('port');
    const path = config.get('path');
    if ((protocol === 'http' && port === 80) || (protocol === 'https' && port === 443)) {
        return `${protocol}://${host}${path}`;
    }
    return `${protocol}://${host}:${port}${path}`;
}
exports.getBaseUrl = getBaseUrl;
function getSessionId(req) {
    return req.headers.sessionid;
}
exports.getSessionId = getSessionId;
async function getVersions() {
    if (versionCache !== undefined) {
        return versionCache;
    }
    const packageFile = await promises_1.readFile(path_1.join(__dirname, '../../package.json'), 'utf8');
    const packageData = JSON.parse(packageFile);
    versionCache = {
        cli: packageData.version,
    };
    return versionCache;
}
exports.getVersions = getVersions;
function extractSchemaForKey(configKey, configSchema) {
    const configKeyParts = configKey.split('.');
    for (const key of configKeyParts) {
        if (configSchema[key] === undefined) {
            throw new Error(`Key "${key}" of ConfigKey "${configKey}" does not exist`);
        }
        else if (configSchema[key]._cvtProperties === undefined) {
            configSchema = configSchema[key];
        }
        else {
            configSchema = configSchema[key]._cvtProperties;
        }
    }
    return configSchema;
}
async function getConfigValue(configKey) {
    const configSchema = config.getSchema();
    const currentSchema = extractSchemaForKey(configKey, configSchema._cvtProperties);
    if (currentSchema.env === undefined) {
        return config.get(configKey);
    }
    const fileEnvironmentVariable = process.env[`${currentSchema.env}_FILE`];
    if (fileEnvironmentVariable === undefined) {
        return config.get(configKey);
    }
    let data;
    try {
        data = await promises_1.readFile(fileEnvironmentVariable, 'utf8');
    }
    catch (error) {
        if (error.code === 'ENOENT') {
            throw new Error(`The file "${fileEnvironmentVariable}" could not be found.`);
        }
        throw error;
    }
    return data;
}
exports.getConfigValue = getConfigValue;
async function generateUniqueName(requestedName, entityType) {
    const findConditions = {
        select: ['name'],
        where: {
            name: typeorm_1.Like(`${requestedName}%`),
        },
    };
    const found = entityType === 'workflow'
        ? await _1.Db.collections.Workflow.find(findConditions)
        : await _1.Db.collections.Credentials.find(findConditions);
    if (found.length === 0) {
        return { name: requestedName };
    }
    const maxSuffix = found.reduce((acc, { name }) => {
        const parts = name.split(`${requestedName} `);
        if (parts.length > 2)
            return acc;
        const suffix = Number(parts[1]);
        if (!isNaN(suffix) && Math.ceil(suffix) > acc) {
            acc = Math.ceil(suffix);
        }
        return acc;
    }, 0);
    if (maxSuffix === 0) {
        return { name: `${requestedName} 2` };
    }
    return { name: `${requestedName} ${maxSuffix + 1}` };
}
exports.generateUniqueName = generateUniqueName;
//# sourceMappingURL=GenericHelpers.js.map