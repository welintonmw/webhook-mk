"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Telemetry = void 0;
const TelemetryClient = require("@rudderstack/rudder-sdk-node");
const n8n_workflow_1 = require("n8n-workflow");
const config = require("../../config");
const Logger_1 = require("../Logger");
class Telemetry {
    constructor(instanceId) {
        this.executionCountsBuffer = {};
        this.instanceId = instanceId;
        const enabled = config.get('diagnostics.enabled');
        if (enabled) {
            const conf = config.get('diagnostics.config.backend');
            const [key, url] = conf.split(';');
            if (!key || !url) {
                const logger = Logger_1.getLogger();
                n8n_workflow_1.LoggerProxy.init(logger);
                logger.warn('Diagnostics backend config is invalid');
                return;
            }
            this.client = new TelemetryClient(key, url);
            this.pulseIntervalReference = setInterval(async () => {
                void this.pulse();
            }, 6 * 60 * 60 * 1000);
        }
    }
    async pulse() {
        if (!this.client) {
            return Promise.resolve();
        }
        const allPromises = Object.keys(this.executionCountsBuffer).map(async (workflowId) => {
            const promise = this.track('Workflow execution count', Object.assign({ workflow_id: workflowId }, this.executionCountsBuffer[workflowId]));
            this.executionCountsBuffer[workflowId].manual_error_count = 0;
            this.executionCountsBuffer[workflowId].manual_success_count = 0;
            this.executionCountsBuffer[workflowId].prod_error_count = 0;
            this.executionCountsBuffer[workflowId].prod_success_count = 0;
            return promise;
        });
        allPromises.push(this.track('pulse'));
        return Promise.all(allPromises);
    }
    async trackWorkflowExecution(properties) {
        var _a;
        if (this.client) {
            const workflowId = properties.workflow_id;
            this.executionCountsBuffer[workflowId] = (_a = this.executionCountsBuffer[workflowId]) !== null && _a !== void 0 ? _a : {
                manual_error_count: 0,
                manual_success_count: 0,
                prod_error_count: 0,
                prod_success_count: 0,
            };
            if (properties.success === false &&
                properties.error_node_type &&
                properties.error_node_type.startsWith('n8n-nodes-base')) {
                void this.track('Workflow execution errored', properties);
                if (properties.is_manual) {
                    this.executionCountsBuffer[workflowId].manual_error_count++;
                }
                else {
                    this.executionCountsBuffer[workflowId].prod_error_count++;
                }
            }
            else if (properties.is_manual) {
                this.executionCountsBuffer[workflowId].manual_success_count++;
            }
            else {
                this.executionCountsBuffer[workflowId].prod_success_count++;
            }
        }
    }
    async trackN8nStop() {
        clearInterval(this.pulseIntervalReference);
        void this.track('User instance stopped');
        return new Promise((resolve) => {
            if (this.client) {
                this.client.flush(resolve);
            }
            else {
                resolve();
            }
        });
    }
    async identify(traits) {
        return new Promise((resolve) => {
            if (this.client) {
                this.client.identify({
                    userId: this.instanceId,
                    anonymousId: '000000000000',
                    traits: Object.assign(Object.assign({}, traits), { instanceId: this.instanceId }),
                }, resolve);
            }
            else {
                resolve();
            }
        });
    }
    async track(eventName, properties) {
        return new Promise((resolve) => {
            if (this.client) {
                this.client.track({
                    userId: this.instanceId,
                    anonymousId: '000000000000',
                    event: eventName,
                    properties,
                }, resolve);
            }
            else {
                resolve();
            }
        });
    }
}
exports.Telemetry = Telemetry;
//# sourceMappingURL=index.js.map