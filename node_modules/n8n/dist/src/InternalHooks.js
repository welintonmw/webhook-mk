"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalHooksClass = void 0;
const n8n_workflow_1 = require("n8n-workflow");
class InternalHooksClass {
    constructor(telemetry) {
        this.telemetry = telemetry;
    }
    async onServerStarted(diagnosticInfo) {
        const info = {
            version_cli: diagnosticInfo.versionCli,
            db_type: diagnosticInfo.databaseType,
            n8n_version_notifications_enabled: diagnosticInfo.notificationsEnabled,
            n8n_disable_production_main_process: diagnosticInfo.disableProductionWebhooksOnMainProcess,
            n8n_basic_auth_active: diagnosticInfo.basicAuthActive,
            system_info: diagnosticInfo.systemInfo,
            execution_variables: diagnosticInfo.executionVariables,
            n8n_deployment_type: diagnosticInfo.deploymentType,
        };
        return Promise.all([
            this.telemetry.identify(info),
            this.telemetry.track('Instance started', info),
        ]);
    }
    async onPersonalizationSurveySubmitted(answers) {
        return this.telemetry.track('User responded to personalization questions', {
            company_size: answers.companySize,
            coding_skill: answers.codingSkill,
            work_area: answers.workArea,
            other_work_area: answers.otherWorkArea,
        });
    }
    async onWorkflowCreated(workflow) {
        return this.telemetry.track('User created workflow', {
            workflow_id: workflow.id,
            node_graph: n8n_workflow_1.TelemetryHelpers.generateNodesGraph(workflow).nodeGraph,
        });
    }
    async onWorkflowDeleted(workflowId) {
        return this.telemetry.track('User deleted workflow', {
            workflow_id: workflowId,
        });
    }
    async onWorkflowSaved(workflow) {
        return this.telemetry.track('User saved workflow', {
            workflow_id: workflow.id,
            node_graph: n8n_workflow_1.TelemetryHelpers.generateNodesGraph(workflow).nodeGraph,
        });
    }
    async onWorkflowPostExecute(workflow, runData) {
        var _a, _b;
        const properties = {
            workflow_id: workflow.id,
            is_manual: false,
        };
        if (runData !== undefined) {
            properties.execution_mode = runData.mode;
            if (runData.mode === 'manual') {
                properties.is_manual = true;
            }
            properties.success = !!runData.finished;
            if (!properties.success && (runData === null || runData === void 0 ? void 0 : runData.data.resultData.error)) {
                properties.error_message = runData === null || runData === void 0 ? void 0 : runData.data.resultData.error.message;
                let errorNodeName = (_a = runData === null || runData === void 0 ? void 0 : runData.data.resultData.error.node) === null || _a === void 0 ? void 0 : _a.name;
                properties.error_node_type = (_b = runData === null || runData === void 0 ? void 0 : runData.data.resultData.error.node) === null || _b === void 0 ? void 0 : _b.type;
                if (runData.data.resultData.lastNodeExecuted) {
                    const lastNode = n8n_workflow_1.TelemetryHelpers.getNodeTypeForName(workflow, runData.data.resultData.lastNodeExecuted);
                    if (lastNode !== undefined) {
                        properties.error_node_type = lastNode.type;
                        errorNodeName = lastNode.name;
                    }
                }
                if (properties.is_manual) {
                    const nodeGraphResult = n8n_workflow_1.TelemetryHelpers.generateNodesGraph(workflow);
                    properties.node_graph = nodeGraphResult.nodeGraph;
                    if (errorNodeName) {
                        properties.error_node_id = nodeGraphResult.nameIndices[errorNodeName];
                    }
                }
            }
        }
        return this.telemetry.trackWorkflowExecution(properties);
    }
    async onN8nStop() {
        const timeoutPromise = new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, 3000);
        });
        return Promise.race([timeoutPromise, this.telemetry.trackN8nStop()]);
    }
}
exports.InternalHooksClass = InternalHooksClass;
//# sourceMappingURL=InternalHooks.js.map