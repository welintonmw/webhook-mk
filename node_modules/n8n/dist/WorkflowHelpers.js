"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVariables = exports.getExecutionStartNode = exports.replaceInvalidCredentials = exports.addNodeIds = exports.getDataLastExecutedNodeData = exports.generateFailedExecutionFromError = void 0;
const typedi_1 = require("typedi");
const uuid_1 = require("uuid");
const credentials_repository_1 = require("./databases/repositories/credentials.repository");
const variables_service_ee_1 = require("./environments/variables/variables.service.ee");
function generateFailedExecutionFromError(mode, error, node) {
    return {
        data: {
            startData: {
                destinationNode: node.name,
                runNodeFilter: [node.name],
            },
            resultData: {
                error,
                runData: {
                    [node.name]: [
                        {
                            startTime: 0,
                            executionTime: 0,
                            error,
                            source: [],
                        },
                    ],
                },
                lastNodeExecuted: node.name,
            },
            executionData: {
                contextData: {},
                metadata: {},
                nodeExecutionStack: [
                    {
                        node,
                        data: {},
                        source: null,
                    },
                ],
                waitingExecution: {},
                waitingExecutionSource: {},
            },
        },
        finished: false,
        mode,
        startedAt: new Date(),
        stoppedAt: new Date(),
        status: 'error',
    };
}
exports.generateFailedExecutionFromError = generateFailedExecutionFromError;
function getDataLastExecutedNodeData(inputData) {
    const { runData, pinData = {} } = inputData.data.resultData;
    const { lastNodeExecuted } = inputData.data.resultData;
    if (lastNodeExecuted === undefined) {
        return undefined;
    }
    if (runData[lastNodeExecuted] === undefined) {
        return undefined;
    }
    const lastNodeRunData = runData[lastNodeExecuted][runData[lastNodeExecuted].length - 1];
    let lastNodePinData = pinData[lastNodeExecuted];
    if (lastNodePinData && inputData.mode === 'manual') {
        if (!Array.isArray(lastNodePinData))
            lastNodePinData = [lastNodePinData];
        const itemsPerRun = lastNodePinData.map((item, index) => {
            return { json: item, pairedItem: { item: index } };
        });
        return {
            startTime: 0,
            executionTime: 0,
            data: { main: [itemsPerRun] },
            source: lastNodeRunData.source,
        };
    }
    return lastNodeRunData;
}
exports.getDataLastExecutedNodeData = getDataLastExecutedNodeData;
function addNodeIds(workflow) {
    const { nodes } = workflow;
    if (!nodes)
        return;
    nodes.forEach((node) => {
        if (!node.id) {
            node.id = (0, uuid_1.v4)();
        }
    });
}
exports.addNodeIds = addNodeIds;
async function replaceInvalidCredentials(workflow) {
    const { nodes } = workflow;
    if (!nodes)
        return workflow;
    const credentialsByName = {};
    const credentialsById = {};
    for (const node of nodes) {
        if (!node.credentials || node.disabled) {
            continue;
        }
        const allNodeCredentials = Object.entries(node.credentials);
        for (const [nodeCredentialType, nodeCredentials] of allNodeCredentials) {
            if (typeof nodeCredentials === 'string' || nodeCredentials.id === null) {
                const name = typeof nodeCredentials === 'string' ? nodeCredentials : nodeCredentials.name;
                if (!credentialsByName[nodeCredentialType]) {
                    credentialsByName[nodeCredentialType] = {};
                }
                if (credentialsByName[nodeCredentialType][name] === undefined) {
                    const credentials = await typedi_1.Container.get(credentials_repository_1.CredentialsRepository).findBy({
                        name,
                        type: nodeCredentialType,
                    });
                    if ((credentials === null || credentials === void 0 ? void 0 : credentials.length) === 1) {
                        credentialsByName[nodeCredentialType][name] = {
                            id: credentials[0].id,
                            name: credentials[0].name,
                        };
                        node.credentials[nodeCredentialType] = credentialsByName[nodeCredentialType][name];
                        continue;
                    }
                    credentialsByName[nodeCredentialType][name] = {
                        id: null,
                        name,
                    };
                }
                else {
                    node.credentials[nodeCredentialType] = credentialsByName[nodeCredentialType][name];
                }
                continue;
            }
            if (!credentialsById[nodeCredentialType]) {
                credentialsById[nodeCredentialType] = {};
            }
            if (credentialsById[nodeCredentialType][nodeCredentials.id] === undefined) {
                const credentials = await typedi_1.Container.get(credentials_repository_1.CredentialsRepository).findOneBy({
                    id: nodeCredentials.id,
                    type: nodeCredentialType,
                });
                if (credentials) {
                    credentialsById[nodeCredentialType][nodeCredentials.id] = {
                        id: credentials.id,
                        name: credentials.name,
                    };
                    node.credentials[nodeCredentialType] =
                        credentialsById[nodeCredentialType][nodeCredentials.id];
                    continue;
                }
                const credsByName = await typedi_1.Container.get(credentials_repository_1.CredentialsRepository).findBy({
                    name: nodeCredentials.name,
                    type: nodeCredentialType,
                });
                if ((credsByName === null || credsByName === void 0 ? void 0 : credsByName.length) === 1) {
                    credentialsById[nodeCredentialType][credsByName[0].id] = {
                        id: credsByName[0].id,
                        name: credsByName[0].name,
                    };
                    node.credentials[nodeCredentialType] =
                        credentialsById[nodeCredentialType][credsByName[0].id];
                    continue;
                }
                credentialsById[nodeCredentialType][nodeCredentials.id] = nodeCredentials;
                continue;
            }
            node.credentials[nodeCredentialType] =
                credentialsById[nodeCredentialType][nodeCredentials.id];
        }
    }
    return workflow;
}
exports.replaceInvalidCredentials = replaceInvalidCredentials;
function getExecutionStartNode(data, workflow) {
    var _a, _b, _c;
    let startNode;
    if (((_a = data.startNodes) === null || _a === void 0 ? void 0 : _a.length) === 1 &&
        Object.keys((_b = data.pinData) !== null && _b !== void 0 ? _b : {}).includes(data.startNodes[0].name)) {
        startNode = (_c = workflow.getNode(data.startNodes[0].name)) !== null && _c !== void 0 ? _c : undefined;
    }
    return startNode;
}
exports.getExecutionStartNode = getExecutionStartNode;
async function getVariables() {
    const variables = await typedi_1.Container.get(variables_service_ee_1.VariablesService).getAllCached();
    return Object.freeze(variables.reduce((prev, curr) => {
        prev[curr.key] = curr.value;
        return prev;
    }, {}));
}
exports.getVariables = getVariables;
//# sourceMappingURL=WorkflowHelpers.js.map