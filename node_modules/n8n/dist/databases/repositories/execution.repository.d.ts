import { DataSource, Repository } from '@n8n/typeorm';
import type { FindManyOptions, FindOperator, FindOptionsWhere } from '@n8n/typeorm';
import { type ExecutionStatus, type ExecutionSummary } from 'n8n-workflow';
import { BinaryDataService } from 'n8n-core';
import type { ExecutionPayload, IExecutionBase, IExecutionFlattedDb, IExecutionResponse } from '../../Interfaces';
import { ExecutionEntity } from '../entities/ExecutionEntity';
import { ExecutionDataRepository } from './executionData.repository';
import { Logger } from '../../Logger';
import type { ExecutionSummaries } from '../../executions/execution.types';
export interface IGetExecutionsQueryFilter {
    id?: FindOperator<string> | string;
    finished?: boolean;
    mode?: string;
    retryOf?: string;
    retrySuccessId?: string;
    status?: ExecutionStatus[];
    workflowId?: string;
    waitTill?: FindOperator<any> | boolean;
    metadata?: Array<{
        key: string;
        value: string;
    }>;
    startedAfter?: string;
    startedBefore?: string;
}
export declare class ExecutionRepository extends Repository<ExecutionEntity> {
    private readonly logger;
    private readonly executionDataRepository;
    private readonly binaryDataService;
    private hardDeletionBatchSize;
    constructor(dataSource: DataSource, logger: Logger, executionDataRepository: ExecutionDataRepository, binaryDataService: BinaryDataService);
    findMultipleExecutions(queryParams: FindManyOptions<ExecutionEntity>, options?: {
        unflattenData: true;
        includeData?: true;
    }): Promise<IExecutionResponse[]>;
    findMultipleExecutions(queryParams: FindManyOptions<ExecutionEntity>, options?: {
        unflattenData?: false | undefined;
        includeData?: true;
    }): Promise<IExecutionFlattedDb[]>;
    findMultipleExecutions(queryParams: FindManyOptions<ExecutionEntity>, options?: {
        unflattenData?: boolean;
        includeData?: boolean;
    }): Promise<IExecutionBase[]>;
    reportInvalidExecutions(executions: ExecutionEntity[]): void;
    findSingleExecution(id: string, options?: {
        includeData: true;
        unflattenData: true;
        where?: FindOptionsWhere<ExecutionEntity>;
    }): Promise<IExecutionResponse | undefined>;
    findSingleExecution(id: string, options?: {
        includeData: true;
        unflattenData?: false | undefined;
        where?: FindOptionsWhere<ExecutionEntity>;
    }): Promise<IExecutionFlattedDb | undefined>;
    findSingleExecution(id: string, options?: {
        includeData?: boolean;
        unflattenData?: boolean;
        where?: FindOptionsWhere<ExecutionEntity>;
    }): Promise<IExecutionBase | undefined>;
    createNewExecution(execution: ExecutionPayload): Promise<string>;
    markAsCrashed(executionIds: string | string[]): Promise<void>;
    hardDelete(ids: {
        workflowId: string;
        executionId: string;
    }): Promise<[import("@n8n/typeorm").DeleteResult, void]>;
    updateStatus(executionId: string, status: ExecutionStatus): Promise<void>;
    resetStartedAt(executionId: string): Promise<void>;
    updateExistingExecution(executionId: string, execution: Partial<IExecutionResponse>): Promise<void>;
    deleteExecutionsByFilter(filters: IGetExecutionsQueryFilter | undefined, accessibleWorkflowIds: string[], deleteConditions: {
        deleteBefore?: Date;
        ids?: string[];
    }): Promise<void>;
    getIdsSince(date: Date): Promise<string[]>;
    softDeletePrunableExecutions(): Promise<import("@n8n/typeorm").UpdateResult>;
    hardDeleteSoftDeletedExecutions(): Promise<{
        workflowId: string;
        executionId: string;
    }[]>;
    deleteByIds(executionIds: string[]): Promise<import("@n8n/typeorm").DeleteResult>;
    getWaitingExecutions(): Promise<IExecutionResponse[]>;
    getExecutionsCountForPublicApi(data: {
        limit: number;
        lastId?: string;
        workflowIds?: string[];
        status?: ExecutionStatus;
        excludedWorkflowIds?: string[];
    }): Promise<number>;
    private getStatusCondition;
    getExecutionsForPublicApi(params: {
        limit: number;
        includeData?: boolean;
        lastId?: string;
        workflowIds?: string[];
        status?: ExecutionStatus;
        excludedExecutionsIds?: string[];
    }): Promise<IExecutionBase[]>;
    getExecutionInWorkflowsForPublicApi(id: string, workflowIds: string[], includeData?: boolean): Promise<IExecutionBase | undefined>;
    findWithUnflattenedData(executionId: string, accessibleWorkflowIds: string[]): Promise<IExecutionResponse | undefined>;
    findIfShared(executionId: string, sharedWorkflowIds: string[]): Promise<IExecutionFlattedDb | undefined>;
    findIfAccessible(executionId: string, accessibleWorkflowIds: string[]): Promise<IExecutionBase | undefined>;
    cancel(executionId: string): Promise<void>;
    cancelMany(executionIds: string[]): Promise<void>;
    private summaryFields;
    findManyByRangeQuery(query: ExecutionSummaries.RangeQuery): Promise<ExecutionSummary[]>;
    private toSummary;
    fetchCount(query: ExecutionSummaries.CountQuery): Promise<number>;
    getLiveExecutionRowsOnPostgres(): Promise<number>;
    private toQueryBuilder;
    getAllIds(): Promise<string[]>;
    getInProgressExecutionIds(batchSize: number): Promise<string[]>;
}
