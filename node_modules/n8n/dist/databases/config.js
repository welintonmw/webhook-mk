"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConnectionOptions = exports.getOptionOverrides = void 0;
const path_1 = __importDefault(require("path"));
const typedi_1 = require("typedi");
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const config_1 = __importDefault(require("../config"));
const entities_1 = require("./entities");
const subscribers_1 = require("./subscribers");
const mysqldb_1 = require("./migrations/mysqldb");
const postgresdb_1 = require("./migrations/postgresdb");
const sqlite_1 = require("./migrations/sqlite");
const getCommonOptions = () => {
    const entityPrefix = config_1.default.getEnv('database.tablePrefix');
    const maxQueryExecutionTime = config_1.default.getEnv('database.logging.maxQueryExecutionTime');
    let loggingOption = config_1.default.getEnv('database.logging.enabled');
    if (loggingOption) {
        const optionsString = config_1.default.getEnv('database.logging.options').replace(/\s+/g, '');
        if (optionsString === 'all') {
            loggingOption = optionsString;
        }
        else {
            loggingOption = optionsString.split(',');
        }
    }
    return {
        entityPrefix,
        entities: Object.values(entities_1.entities),
        subscribers: Object.values(subscribers_1.subscribers),
        migrationsTableName: `${entityPrefix}migrations`,
        migrationsRun: false,
        synchronize: false,
        maxQueryExecutionTime,
        logging: loggingOption,
    };
};
const getOptionOverrides = (dbType) => ({
    database: config_1.default.getEnv(`database.${dbType}.database`),
    host: config_1.default.getEnv(`database.${dbType}.host`),
    port: config_1.default.getEnv(`database.${dbType}.port`),
    username: config_1.default.getEnv(`database.${dbType}.user`),
    password: config_1.default.getEnv(`database.${dbType}.password`),
});
exports.getOptionOverrides = getOptionOverrides;
const getSqliteConnectionOptions = () => {
    const poolSize = config_1.default.getEnv('database.sqlite.poolSize');
    const commonOptions = {
        ...getCommonOptions(),
        database: path_1.default.resolve(typedi_1.Container.get(n8n_core_1.InstanceSettings).n8nFolder, config_1.default.getEnv('database.sqlite.database')),
        migrations: sqlite_1.sqliteMigrations,
    };
    if (poolSize > 0) {
        return {
            type: 'sqlite-pooled',
            poolSize,
            enableWAL: true,
            acquireTimeout: 60000,
            destroyTimeout: 5000,
            ...commonOptions,
        };
    }
    else {
        return {
            type: 'sqlite',
            enableWAL: config_1.default.getEnv('database.sqlite.enableWAL'),
            ...commonOptions,
        };
    }
};
const getPostgresConnectionOptions = () => {
    const sslCa = config_1.default.getEnv('database.postgresdb.ssl.ca');
    const sslCert = config_1.default.getEnv('database.postgresdb.ssl.cert');
    const sslKey = config_1.default.getEnv('database.postgresdb.ssl.key');
    const sslRejectUnauthorized = config_1.default.getEnv('database.postgresdb.ssl.rejectUnauthorized');
    let ssl = config_1.default.getEnv('database.postgresdb.ssl.enabled');
    if (sslCa !== '' || sslCert !== '' || sslKey !== '' || !sslRejectUnauthorized) {
        ssl = {
            ca: sslCa || undefined,
            cert: sslCert || undefined,
            key: sslKey || undefined,
            rejectUnauthorized: sslRejectUnauthorized,
        };
    }
    return {
        type: 'postgres',
        ...getCommonOptions(),
        ...(0, exports.getOptionOverrides)('postgresdb'),
        schema: config_1.default.getEnv('database.postgresdb.schema'),
        poolSize: config_1.default.getEnv('database.postgresdb.poolSize'),
        migrations: postgresdb_1.postgresMigrations,
        ssl,
    };
};
const getMysqlConnectionOptions = (dbType) => ({
    type: dbType === 'mysqldb' ? 'mysql' : 'mariadb',
    ...getCommonOptions(),
    ...(0, exports.getOptionOverrides)('mysqldb'),
    migrations: mysqldb_1.mysqlMigrations,
    timezone: 'Z',
});
function getConnectionOptions() {
    const dbType = config_1.default.getEnv('database.type');
    switch (dbType) {
        case 'sqlite':
            return getSqliteConnectionOptions();
        case 'postgresdb':
            return getPostgresConnectionOptions();
        case 'mariadb':
        case 'mysqldb':
            return getMysqlConnectionOptions(dbType);
        default:
            throw new n8n_workflow_1.ApplicationError('Database type currently not supported', { extra: { dbType } });
    }
}
exports.getConnectionOptions = getConnectionOptions;
//# sourceMappingURL=config.js.map