"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrontendService = void 0;
const typedi_1 = require("typedi");
const uniq_1 = __importDefault(require("lodash/uniq"));
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const path_1 = __importDefault(require("path"));
const n8n_core_1 = require("n8n-core");
const config_1 = __importDefault(require("../config"));
const constants_1 = require("../constants");
const CredentialsOverwrites_1 = require("../CredentialsOverwrites");
const CredentialTypes_1 = require("../CredentialTypes");
const LoadNodesAndCredentials_1 = require("../LoadNodesAndCredentials");
const License_1 = require("../License");
const ssoHelpers_1 = require("../sso/ssoHelpers");
const helpers_1 = require("../Ldap/helpers");
const samlHelpers_1 = require("../sso/saml/samlHelpers");
const environmentHelpers_1 = require("../environments/variables/environmentHelpers");
const workflowHistoryHelper_ee_1 = require("../workflows/workflowHistory/workflowHistoryHelper.ee");
const email_1 = require("../UserManagement/email");
const Logger_1 = require("../Logger");
const url_service_1 = require("./url.service");
const InternalHooks_1 = require("../InternalHooks");
const PublicApi_1 = require("../PublicApi");
let FrontendService = class FrontendService {
    constructor(logger, loadNodesAndCredentials, credentialTypes, credentialsOverwrites, license, mailer, instanceSettings, urlService, internalHooks) {
        this.logger = logger;
        this.loadNodesAndCredentials = loadNodesAndCredentials;
        this.credentialTypes = credentialTypes;
        this.credentialsOverwrites = credentialsOverwrites;
        this.license = license;
        this.mailer = mailer;
        this.instanceSettings = instanceSettings;
        this.urlService = urlService;
        this.internalHooks = internalHooks;
        loadNodesAndCredentials.addPostProcessor(async () => await this.generateTypes());
        void this.generateTypes();
        this.initSettings();
        if (config_1.default.getEnv('nodes.communityPackages.enabled')) {
            void Promise.resolve().then(() => __importStar(require('../services/communityPackages.service'))).then(({ CommunityPackagesService }) => {
                this.communityPackagesService = typedi_1.Container.get(CommunityPackagesService);
            });
        }
    }
    initSettings() {
        var _a, _b, _c, _d;
        const instanceBaseUrl = this.urlService.getInstanceBaseUrl();
        const restEndpoint = config_1.default.getEnv('endpoints.rest');
        const telemetrySettings = {
            enabled: config_1.default.getEnv('diagnostics.enabled'),
        };
        if (telemetrySettings.enabled) {
            const conf = config_1.default.getEnv('diagnostics.config.frontend');
            const [key, url] = conf.split(';');
            if (!key || !url) {
                this.logger.warn('Diagnostics frontend config is invalid');
                telemetrySettings.enabled = false;
            }
            telemetrySettings.config = { key, url };
        }
        this.settings = {
            previewMode: process.env.N8N_PREVIEW_MODE === 'true',
            endpointForm: config_1.default.getEnv('endpoints.form'),
            endpointFormTest: config_1.default.getEnv('endpoints.formTest'),
            endpointFormWaiting: config_1.default.getEnv('endpoints.formWaiting'),
            endpointWebhook: config_1.default.getEnv('endpoints.webhook'),
            endpointWebhookTest: config_1.default.getEnv('endpoints.webhookTest'),
            saveDataErrorExecution: config_1.default.getEnv('executions.saveDataOnError'),
            saveDataSuccessExecution: config_1.default.getEnv('executions.saveDataOnSuccess'),
            saveManualExecutions: config_1.default.getEnv('executions.saveDataManualExecutions'),
            executionTimeout: config_1.default.getEnv('executions.timeout'),
            maxExecutionTimeout: config_1.default.getEnv('executions.maxTimeout'),
            workflowCallerPolicyDefaultOption: config_1.default.getEnv('workflows.callerPolicyDefaultOption'),
            timezone: config_1.default.getEnv('generic.timezone'),
            urlBaseWebhook: this.urlService.getWebhookBaseUrl(),
            urlBaseEditor: instanceBaseUrl,
            binaryDataMode: config_1.default.getEnv('binaryDataManager.mode'),
            versionCli: '',
            authCookie: {
                secure: config_1.default.getEnv('secure_cookie'),
            },
            releaseChannel: config_1.default.getEnv('generic.releaseChannel'),
            oauthCallbackUrls: {
                oauth1: `${instanceBaseUrl}/${restEndpoint}/oauth1-credential/callback`,
                oauth2: `${instanceBaseUrl}/${restEndpoint}/oauth2-credential/callback`,
            },
            versionNotifications: {
                enabled: config_1.default.getEnv('versionNotifications.enabled'),
                endpoint: config_1.default.getEnv('versionNotifications.endpoint'),
                infoUrl: config_1.default.getEnv('versionNotifications.infoUrl'),
            },
            instanceId: this.instanceSettings.instanceId,
            telemetry: telemetrySettings,
            posthog: {
                enabled: config_1.default.getEnv('diagnostics.enabled'),
                apiHost: config_1.default.getEnv('diagnostics.config.posthog.apiHost'),
                apiKey: config_1.default.getEnv('diagnostics.config.posthog.apiKey'),
                autocapture: false,
                disableSessionRecording: config_1.default.getEnv('deployment.type') !== 'cloud',
                debug: config_1.default.getEnv('logs.level') === 'debug',
            },
            personalizationSurveyEnabled: config_1.default.getEnv('personalization.enabled') && config_1.default.getEnv('diagnostics.enabled'),
            defaultLocale: config_1.default.getEnv('defaultLocale'),
            userManagement: {
                quota: this.license.getUsersLimit(),
                showSetupOnFirstLoad: !config_1.default.getEnv('userManagement.isInstanceOwnerSetUp'),
                smtpSetup: this.mailer.isEmailSetUp,
                authenticationMethod: (0, ssoHelpers_1.getCurrentAuthenticationMethod)(),
            },
            sso: {
                saml: {
                    loginEnabled: false,
                    loginLabel: '',
                },
                ldap: {
                    loginEnabled: false,
                    loginLabel: '',
                },
            },
            publicApi: {
                enabled: (0, PublicApi_1.isApiEnabled)(),
                latestVersion: 1,
                path: config_1.default.getEnv('publicApi.path'),
                swaggerUi: {
                    enabled: !config_1.default.getEnv('publicApi.swaggerUi.disabled'),
                },
            },
            workflowTagsDisabled: config_1.default.getEnv('workflowTagsDisabled'),
            logLevel: config_1.default.getEnv('logs.level'),
            hiringBannerEnabled: config_1.default.getEnv('hiringBanner.enabled'),
            templates: {
                enabled: config_1.default.getEnv('templates.enabled'),
                host: config_1.default.getEnv('templates.host'),
            },
            onboardingCallPromptEnabled: config_1.default.getEnv('onboardingCallPrompt.enabled'),
            executionMode: config_1.default.getEnv('executions.mode'),
            pushBackend: config_1.default.getEnv('push.backend'),
            communityNodesEnabled: config_1.default.getEnv('nodes.communityPackages.enabled'),
            deployment: {
                type: config_1.default.getEnv('deployment.type'),
            },
            isNpmAvailable: false,
            allowedModules: {
                builtIn: (_b = (_a = process.env.NODE_FUNCTION_ALLOW_BUILTIN) === null || _a === void 0 ? void 0 : _a.split(',')) !== null && _b !== void 0 ? _b : undefined,
                external: (_d = (_c = process.env.NODE_FUNCTION_ALLOW_EXTERNAL) === null || _c === void 0 ? void 0 : _c.split(',')) !== null && _d !== void 0 ? _d : undefined,
            },
            enterprise: {
                sharing: false,
                ldap: false,
                saml: false,
                logStreaming: false,
                advancedExecutionFilters: false,
                variables: false,
                sourceControl: false,
                auditLogs: false,
                externalSecrets: false,
                showNonProdBanner: false,
                debugInEditor: false,
                binaryDataS3: false,
                workflowHistory: false,
                workerView: false,
                advancedPermissions: false,
                projects: {
                    team: {
                        limit: 0,
                    },
                },
            },
            mfa: {
                enabled: false,
            },
            hideUsagePage: config_1.default.getEnv('hideUsagePage'),
            license: {
                environment: config_1.default.getEnv('license.tenantId') === 1 ? 'production' : 'staging',
            },
            variables: {
                limit: 0,
            },
            expressions: {
                evaluator: config_1.default.getEnv('expression.evaluator'),
            },
            banners: {
                dismissed: [],
            },
            ai: {
                enabled: config_1.default.getEnv('ai.enabled'),
                provider: config_1.default.getEnv('ai.provider'),
                features: {
                    generateCurl: !!config_1.default.getEnv('ai.openAI.apiKey'),
                },
            },
            workflowHistory: {
                pruneTime: -1,
                licensePruneTime: -1,
            },
        };
    }
    async generateTypes() {
        this.overwriteCredentialsProperties();
        const { staticCacheDir } = this.instanceSettings;
        await (0, promises_1.mkdir)(path_1.default.join(staticCacheDir, 'types'), { recursive: true });
        const { credentials, nodes } = this.loadNodesAndCredentials.types;
        this.writeStaticJSON('nodes', nodes);
        this.writeStaticJSON('credentials', credentials);
    }
    getSettings(pushRef) {
        var _a;
        void this.internalHooks.onFrontendSettingsAPI(pushRef);
        const restEndpoint = config_1.default.getEnv('endpoints.rest');
        const instanceBaseUrl = this.urlService.getInstanceBaseUrl();
        this.settings.urlBaseWebhook = this.urlService.getWebhookBaseUrl();
        this.settings.urlBaseEditor = instanceBaseUrl;
        this.settings.oauthCallbackUrls = {
            oauth1: `${instanceBaseUrl}/${restEndpoint}/oauth1-credential/callback`,
            oauth2: `${instanceBaseUrl}/${restEndpoint}/oauth2-credential/callback`,
        };
        Object.assign(this.settings.userManagement, {
            quota: this.license.getUsersLimit(),
            authenticationMethod: (0, ssoHelpers_1.getCurrentAuthenticationMethod)(),
            showSetupOnFirstLoad: !config_1.default.getEnv('userManagement.isInstanceOwnerSetUp') &&
                !config_1.default.getEnv('deployment.type').startsWith('desktop_'),
        });
        let dismissedBanners = [];
        try {
            dismissedBanners = (_a = config_1.default.getEnv('ui.banners.dismissed')) !== null && _a !== void 0 ? _a : [];
        }
        catch {
        }
        this.settings.banners.dismissed = dismissedBanners;
        const isS3Selected = config_1.default.getEnv('binaryDataManager.mode') === 's3';
        const isS3Available = config_1.default.getEnv('binaryDataManager.availableModes').includes('s3');
        const isS3Licensed = this.license.isBinaryDataS3Licensed();
        Object.assign(this.settings.enterprise, {
            sharing: this.license.isSharingEnabled(),
            logStreaming: this.license.isLogStreamingEnabled(),
            ldap: this.license.isLdapEnabled(),
            saml: this.license.isSamlEnabled(),
            advancedExecutionFilters: this.license.isAdvancedExecutionFiltersEnabled(),
            variables: this.license.isVariablesEnabled(),
            sourceControl: this.license.isSourceControlLicensed(),
            externalSecrets: this.license.isExternalSecretsEnabled(),
            showNonProdBanner: this.license.isFeatureEnabled(constants_1.LICENSE_FEATURES.SHOW_NON_PROD_BANNER),
            debugInEditor: this.license.isDebugInEditorLicensed(),
            binaryDataS3: isS3Available && isS3Selected && isS3Licensed,
            workflowHistory: this.license.isWorkflowHistoryLicensed() && config_1.default.getEnv('workflowHistory.enabled'),
            workerView: this.license.isWorkerViewLicensed(),
            advancedPermissions: this.license.isAdvancedPermissionsLicensed(),
        });
        if (this.license.isLdapEnabled()) {
            Object.assign(this.settings.sso.ldap, {
                loginLabel: (0, helpers_1.getLdapLoginLabel)(),
                loginEnabled: config_1.default.getEnv('sso.ldap.loginEnabled'),
            });
        }
        if (this.license.isSamlEnabled()) {
            Object.assign(this.settings.sso.saml, {
                loginLabel: (0, samlHelpers_1.getSamlLoginLabel)(),
                loginEnabled: config_1.default.getEnv('sso.saml.loginEnabled'),
            });
        }
        if (this.license.isVariablesEnabled()) {
            this.settings.variables.limit = (0, environmentHelpers_1.getVariablesLimit)();
        }
        if (this.license.isWorkflowHistoryLicensed() && config_1.default.getEnv('workflowHistory.enabled')) {
            Object.assign(this.settings.workflowHistory, {
                pruneTime: (0, workflowHistoryHelper_ee_1.getWorkflowHistoryPruneTime)(),
                licensePruneTime: (0, workflowHistoryHelper_ee_1.getWorkflowHistoryLicensePruneTime)(),
            });
        }
        if (this.communityPackagesService) {
            this.settings.missingPackages = this.communityPackagesService.hasMissingPackages;
        }
        this.settings.mfa.enabled = config_1.default.get('mfa.enabled');
        this.settings.executionMode = config_1.default.getEnv('executions.mode');
        this.settings.binaryDataMode = config_1.default.getEnv('binaryDataManager.mode');
        this.settings.enterprise.projects.team.limit = this.license.getTeamProjectLimit();
        return this.settings;
    }
    addToSettings(newSettings) {
        this.settings = { ...this.settings, ...newSettings };
    }
    writeStaticJSON(name, data) {
        const { staticCacheDir } = this.instanceSettings;
        const filePath = path_1.default.join(staticCacheDir, `types/${name}.json`);
        const stream = (0, fs_1.createWriteStream)(filePath, 'utf-8');
        stream.write('[\n');
        data.forEach((entry, index) => {
            stream.write(JSON.stringify(entry));
            if (index !== data.length - 1)
                stream.write(',');
            stream.write('\n');
        });
        stream.write(']\n');
        stream.end();
    }
    overwriteCredentialsProperties() {
        const { credentials } = this.loadNodesAndCredentials.types;
        const credentialsOverwrites = this.credentialsOverwrites.getAll();
        for (const credential of credentials) {
            const overwrittenProperties = [];
            this.credentialTypes
                .getParentTypes(credential.name)
                .reverse()
                .map((name) => credentialsOverwrites[name])
                .forEach((overwrite) => {
                if (overwrite)
                    overwrittenProperties.push(...Object.keys(overwrite));
            });
            if (credential.name in credentialsOverwrites) {
                overwrittenProperties.push(...Object.keys(credentialsOverwrites[credential.name]));
            }
            if (overwrittenProperties.length) {
                credential.__overwrittenProperties = (0, uniq_1.default)(overwrittenProperties);
            }
        }
    }
};
exports.FrontendService = FrontendService;
exports.FrontendService = FrontendService = __decorate([
    (0, typedi_1.Service)(),
    __metadata("design:paramtypes", [Logger_1.Logger,
        LoadNodesAndCredentials_1.LoadNodesAndCredentials,
        CredentialTypes_1.CredentialTypes,
        CredentialsOverwrites_1.CredentialsOverwrites,
        License_1.License,
        email_1.UserManagementMailer,
        n8n_core_1.InstanceSettings,
        url_service_1.UrlService,
        InternalHooks_1.InternalHooks])
], FrontendService);
//# sourceMappingURL=frontend.service.js.map