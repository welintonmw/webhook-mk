"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleCommandMessageMain = void 0;
const typedi_1 = require("typedi");
const helpers_1 = require("../helpers");
const config_1 = __importDefault(require("../../../config"));
const MessageEventBus_1 = require("../../../eventbus/MessageEventBus/MessageEventBus");
const ExternalSecretsManager_ee_1 = require("../../../ExternalSecrets/ExternalSecretsManager.ee");
const License_1 = require("../../../License");
const Logger_1 = require("../../../Logger");
const ActiveWorkflowManager_1 = require("../../../ActiveWorkflowManager");
const push_1 = require("../../../push");
const TestWebhooks_1 = require("../../../TestWebhooks");
const orchestration_service_1 = require("../../../services/orchestration.service");
const workflow_repository_1 = require("../../../databases/repositories/workflow.repository");
async function handleCommandMessageMain(messageString) {
    var _a, _b, _c, _d, _e;
    const queueModeId = config_1.default.getEnv('redis.queueModeId');
    const isMainInstance = config_1.default.getEnv('generic.instanceType') === 'main';
    const message = (0, helpers_1.messageToRedisServiceCommandObject)(messageString);
    const logger = typedi_1.Container.get(Logger_1.Logger);
    if (message) {
        logger.debug(`RedisCommandHandler(main): Received command message ${message.command} from ${message.senderId}`);
        const selfSendingAllowed = [
            'add-webhooks-triggers-and-pollers',
            'remove-triggers-and-pollers',
        ].includes(message.command);
        if (!selfSendingAllowed &&
            (message.senderId === queueModeId ||
                (message.targets && !message.targets.includes(queueModeId)))) {
            logger.debug(`Skipping command message ${message.command} because it's not for this instance.`);
            return message;
        }
        const push = typedi_1.Container.get(push_1.Push);
        switch (message.command) {
            case 'reloadLicense':
                if (!(0, helpers_1.debounceMessageReceiver)(message, 500)) {
                    message.payload = {
                        result: 'debounced',
                    };
                    return message;
                }
                if (isMainInstance && !config_1.default.getEnv('multiMainSetup.enabled')) {
                    logger.error('Received command to reload license via Redis, but this should not have happened and is not supported on the main instance yet.');
                    return message;
                }
                await typedi_1.Container.get(License_1.License).reload();
                break;
            case 'restartEventBus':
                if (!(0, helpers_1.debounceMessageReceiver)(message, 200)) {
                    message.payload = {
                        result: 'debounced',
                    };
                    return message;
                }
                await typedi_1.Container.get(MessageEventBus_1.MessageEventBus).restart();
            case 'reloadExternalSecretsProviders':
                if (!(0, helpers_1.debounceMessageReceiver)(message, 200)) {
                    message.payload = {
                        result: 'debounced',
                    };
                    return message;
                }
                await typedi_1.Container.get(ExternalSecretsManager_ee_1.ExternalSecretsManager).reloadAllProviders();
                break;
            case 'add-webhooks-triggers-and-pollers': {
                if (!(0, helpers_1.debounceMessageReceiver)(message, 100)) {
                    message.payload = { result: 'debounced' };
                    return message;
                }
                const orchestrationService = typedi_1.Container.get(orchestration_service_1.OrchestrationService);
                if (orchestrationService.isFollower)
                    break;
                if (typeof ((_a = message.payload) === null || _a === void 0 ? void 0 : _a.workflowId) !== 'string')
                    break;
                const { workflowId } = message.payload;
                try {
                    await typedi_1.Container.get(ActiveWorkflowManager_1.ActiveWorkflowManager).add(workflowId, 'activate', undefined, {
                        shouldPublish: false,
                    });
                    push.broadcast('workflowActivated', { workflowId });
                    await orchestrationService.publish('display-workflow-activation', { workflowId });
                }
                catch (error) {
                    if (error instanceof Error) {
                        await typedi_1.Container.get(workflow_repository_1.WorkflowRepository).update(workflowId, { active: false });
                        typedi_1.Container.get(push_1.Push).broadcast('workflowFailedToActivate', {
                            workflowId,
                            errorMessage: error.message,
                        });
                        await typedi_1.Container.get(orchestration_service_1.OrchestrationService).publish('workflow-failed-to-activate', {
                            workflowId,
                            errorMessage: error.message,
                        });
                    }
                }
                break;
            }
            case 'remove-triggers-and-pollers': {
                if (!(0, helpers_1.debounceMessageReceiver)(message, 100)) {
                    message.payload = { result: 'debounced' };
                    return message;
                }
                const orchestrationService = typedi_1.Container.get(orchestration_service_1.OrchestrationService);
                if (orchestrationService.isFollower)
                    break;
                if (typeof ((_b = message.payload) === null || _b === void 0 ? void 0 : _b.workflowId) !== 'string')
                    break;
                const { workflowId } = message.payload;
                const activeWorkflowManager = typedi_1.Container.get(ActiveWorkflowManager_1.ActiveWorkflowManager);
                await activeWorkflowManager.removeActivationError(workflowId);
                await activeWorkflowManager.removeWorkflowTriggersAndPollers(workflowId);
                push.broadcast('workflowDeactivated', { workflowId });
                await orchestrationService.publish('display-workflow-deactivation', { workflowId });
                break;
            }
            case 'display-workflow-activation': {
                if (!(0, helpers_1.debounceMessageReceiver)(message, 100)) {
                    message.payload = { result: 'debounced' };
                    return message;
                }
                const { workflowId } = (_c = message.payload) !== null && _c !== void 0 ? _c : {};
                if (typeof workflowId !== 'string')
                    break;
                push.broadcast('workflowActivated', { workflowId });
                break;
            }
            case 'display-workflow-deactivation': {
                if (!(0, helpers_1.debounceMessageReceiver)(message, 100)) {
                    message.payload = { result: 'debounced' };
                    return message;
                }
                const { workflowId } = (_d = message.payload) !== null && _d !== void 0 ? _d : {};
                if (typeof workflowId !== 'string')
                    break;
                push.broadcast('workflowDeactivated', { workflowId });
                break;
            }
            case 'workflow-failed-to-activate': {
                if (!(0, helpers_1.debounceMessageReceiver)(message, 100)) {
                    message.payload = { result: 'debounced' };
                    return message;
                }
                const { workflowId, errorMessage } = (_e = message.payload) !== null && _e !== void 0 ? _e : {};
                if (typeof workflowId !== 'string' || typeof errorMessage !== 'string')
                    break;
                typedi_1.Container.get(push_1.Push).broadcast('workflowFailedToActivate', { workflowId, errorMessage });
                break;
            }
            case 'relay-execution-lifecycle-event': {
                const { type, args, pushRef } = message.payload;
                if (!push.getBackend().hasPushRef(pushRef))
                    break;
                push.send(type, args, pushRef);
                break;
            }
            case 'clear-test-webhooks': {
                if (!(0, helpers_1.debounceMessageReceiver)(message, 100)) {
                    message.payload = { result: 'debounced' };
                    return message;
                }
                const { webhookKey, workflowEntity, pushRef } = message.payload;
                if (!push.getBackend().hasPushRef(pushRef))
                    break;
                const testWebhooks = typedi_1.Container.get(TestWebhooks_1.TestWebhooks);
                testWebhooks.clearTimeout(webhookKey);
                const workflow = testWebhooks.toWorkflow(workflowEntity);
                await testWebhooks.deactivateWebhooks(workflow);
                break;
            }
            default:
                break;
        }
        return message;
    }
    return;
}
exports.handleCommandMessageMain = handleCommandMessageMain;
//# sourceMappingURL=handleCommandMessageMain.js.map