"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiMainSetup = void 0;
const node_events_1 = require("node:events");
const config_1 = __importDefault(require("../../../config"));
const typedi_1 = require("typedi");
const constants_1 = require("../../../constants");
const n8n_workflow_1 = require("n8n-workflow");
const Logger_1 = require("../../../Logger");
const RedisServicePubSubPublisher_1 = require("../../../services/redis/RedisServicePubSubPublisher");
const redis_client_service_1 = require("../../../services/redis/redis-client.service");
let MultiMainSetup = class MultiMainSetup extends node_events_1.EventEmitter {
    constructor(logger, redisPublisher, redisClientService) {
        super();
        this.logger = logger;
        this.redisPublisher = redisPublisher;
        this.redisClientService = redisClientService;
        this.leaderKeyTtl = config_1.default.getEnv('multiMainSetup.ttl');
    }
    get instanceId() {
        return config_1.default.getEnv('redis.queueModeId');
    }
    async init() {
        const prefix = config_1.default.getEnv('redis.prefix');
        const validPrefix = this.redisClientService.toValidPrefix(prefix);
        this.leaderKey = validPrefix + ':main_instance_leader';
        await this.tryBecomeLeader();
        this.leaderCheckInterval = setInterval(async () => {
            await this.checkLeader();
        }, config_1.default.getEnv('multiMainSetup.interval') * constants_1.TIME.SECOND);
    }
    async shutdown() {
        clearInterval(this.leaderCheckInterval);
        const isLeader = config_1.default.getEnv('multiMainSetup.instanceType') === 'leader';
        if (isLeader)
            await this.redisPublisher.clear(this.leaderKey);
    }
    async checkLeader() {
        const leaderId = await this.redisPublisher.get(this.leaderKey);
        if (leaderId === this.instanceId) {
            this.logger.debug(`[Instance ID ${this.instanceId}] Leader is this instance`);
            await this.redisPublisher.setExpiration(this.leaderKey, this.leaderKeyTtl);
            return;
        }
        if (leaderId && leaderId !== this.instanceId) {
            this.logger.debug(`[Instance ID ${this.instanceId}] Leader is other instance "${leaderId}"`);
            if (config_1.default.getEnv('multiMainSetup.instanceType') === 'leader') {
                config_1.default.set('multiMainSetup.instanceType', 'follower');
                this.emit('leader-stepdown');
                n8n_workflow_1.ErrorReporterProxy.info('[Multi-main setup] Leader failed to renew leader key');
            }
            return;
        }
        if (!leaderId) {
            this.logger.debug(`[Instance ID ${this.instanceId}] Leadership vacant, attempting to become leader...`);
            config_1.default.set('multiMainSetup.instanceType', 'follower');
            this.emit('leader-stepdown');
            await this.tryBecomeLeader();
        }
    }
    async tryBecomeLeader() {
        const keySetSuccessfully = await this.redisPublisher.setIfNotExists(this.leaderKey, this.instanceId);
        if (keySetSuccessfully) {
            this.logger.debug(`[Instance ID ${this.instanceId}] Leader is now this instance`);
            config_1.default.set('multiMainSetup.instanceType', 'leader');
            await this.redisPublisher.setExpiration(this.leaderKey, this.leaderKeyTtl);
            this.emit('leader-takeover');
        }
        else {
            config_1.default.set('multiMainSetup.instanceType', 'follower');
        }
    }
    async fetchLeaderKey() {
        return await this.redisPublisher.get(this.leaderKey);
    }
};
exports.MultiMainSetup = MultiMainSetup;
exports.MultiMainSetup = MultiMainSetup = __decorate([
    (0, typedi_1.Service)(),
    __metadata("design:paramtypes", [Logger_1.Logger,
        RedisServicePubSubPublisher_1.RedisServicePubSubPublisher,
        redis_client_service_1.RedisClientService])
], MultiMainSetup);
//# sourceMappingURL=MultiMainSetup.ee.js.map