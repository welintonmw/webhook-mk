"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleCommandMessageWebhook = void 0;
const ExternalSecretsManager_ee_1 = require("../../../ExternalSecrets/ExternalSecretsManager.ee");
const License_1 = require("../../../License");
const MessageEventBus_1 = require("../../../eventbus/MessageEventBus/MessageEventBus");
const typedi_1 = __importDefault(require("typedi"));
const winston_1 = require("winston");
const helpers_1 = require("../helpers");
const config_1 = __importDefault(require("../../../config"));
async function handleCommandMessageWebhook(messageString) {
    const queueModeId = config_1.default.getEnv('redis.queueModeId');
    const isMainInstance = config_1.default.getEnv('generic.instanceType') === 'main';
    const message = (0, helpers_1.messageToRedisServiceCommandObject)(messageString);
    const logger = typedi_1.default.get(winston_1.Logger);
    if (message) {
        logger.debug(`RedisCommandHandler(main): Received command message ${message.command} from ${message.senderId}`);
        if (message.senderId === queueModeId ||
            (message.targets && !message.targets.includes(queueModeId))) {
            logger.debug(`Skipping command message ${message.command} because it's not for this instance.`);
            return message;
        }
        switch (message.command) {
            case 'reloadLicense':
                if (!(0, helpers_1.debounceMessageReceiver)(message, 500)) {
                    message.payload = {
                        result: 'debounced',
                    };
                    return message;
                }
                if (isMainInstance && !config_1.default.getEnv('multiMainSetup.enabled')) {
                    logger.error('Received command to reload license via Redis, but this should not have happened and is not supported on the main instance yet.');
                    return message;
                }
                await typedi_1.default.get(License_1.License).reload();
                break;
            case 'restartEventBus':
                if (!(0, helpers_1.debounceMessageReceiver)(message, 200)) {
                    message.payload = {
                        result: 'debounced',
                    };
                    return message;
                }
                await typedi_1.default.get(MessageEventBus_1.MessageEventBus).restart();
            case 'reloadExternalSecretsProviders':
                if (!(0, helpers_1.debounceMessageReceiver)(message, 200)) {
                    message.payload = {
                        result: 'debounced',
                    };
                    return message;
                }
                await typedi_1.default.get(ExternalSecretsManager_ee_1.ExternalSecretsManager).reloadAllProviders();
                break;
            default:
                break;
        }
        return message;
    }
    return;
}
exports.handleCommandMessageWebhook = handleCommandMessageWebhook;
//# sourceMappingURL=handleCommandMessageWebhook.js.map